{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sistemas Hardware-Software \u00b6 Bem vindo ao curso de Sistemas Hardware-Software 2020/2. Professor : Igor Montagner Avalia\u00e7\u00e3o \u00b6 A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; Os Laborat\u00f3rios ser\u00e3o disponibilizados neste site e dever\u00e3o ser entregues no reposit\u00f3rio de atividades da disciplina. A m\u00e9dia final \u00e9 dada por 10% Atividades 40% Laborat\u00f3rios 50% m\u00e9dia de Provas Condi\u00e7\u00f5es de barreira M\u00e9dia de provas >= 4,5 PI, PF >= 4,0 Laborat\u00f3rios >= 5 Caso estas condi\u00e7\u00f5es n\u00e3o sejam cumpridas ver detalhes na aula 01 Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.","title":"Home"},{"location":"#sistemas-hardware-software","text":"Bem vindo ao curso de Sistemas Hardware-Software 2020/2. Professor : Igor Montagner","title":"Sistemas Hardware-Software"},{"location":"#avaliacao","text":"A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; Os Laborat\u00f3rios ser\u00e3o disponibilizados neste site e dever\u00e3o ser entregues no reposit\u00f3rio de atividades da disciplina. A m\u00e9dia final \u00e9 dada por 10% Atividades 40% Laborat\u00f3rios 50% m\u00e9dia de Provas Condi\u00e7\u00f5es de barreira M\u00e9dia de provas >= 4,5 PI, PF >= 4,0 Laborat\u00f3rios >= 5 Caso estas condi\u00e7\u00f5es n\u00e3o sejam cumpridas ver detalhes na aula 01 Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.","title":"Avalia\u00e7\u00e3o"},{"location":"sobre/","text":"Plano de aulas \u00b6 SEG 13:30 - 15:40 QUI 15:45 - 17:45 Atendimento: QUI 14:00 - 15:30 Plano de aulas Data Quest\u00e3o/Problema Conte\u00fado/Atividade 24/08 Mutir\u00e3o C Exerc\u00edcios pr\u00e1ticos de revis\u00e3o 27/08 Mutir\u00e3o C Exerc\u00edcios pr\u00e1ticos de revis\u00e3o 31/08 Como a CPU representa dados em baixo n\u00edvel? Representa\u00e7\u00e3o de inteiros na CPU: n\u00fameros bin\u00e1rios e hexadecimais, complemento de dois, opera\u00e7\u00f5es bit a bit. Leitura: Cap 2 CS:APP; Cap 9 Stallings 03/09 Como a CPU representa dados em baixo n\u00edvel? Representa\u00e7\u00e3o de ponteiros, arrays e estruturas em RAM. Leitura: Cap 2 CS:APP; Cap 9 Stallings 07/09 FERIADO FERIADO 10/09 Como a CPU representa e executa um programa escrito em C? Arquitetura de computadores: registradores, mem\u00f3ria e endere\u00e7amento Assembly: Organiza\u00e7\u00e3o de um execut\u00e1vel no disco e na mem\u00f3ria Leitura: Cap 3.1 \u2013 3.4 CS:APP 14/09 Como a CPU representa e executa um programa escrito em C? Arquitetura de computadores: chamadas de fun\u00e7\u00e3o e pilha Assembly: Exerc\u00edcios com chamadas de fun\u00e7\u00e3o e opera\u00e7\u00f5es com inteiros Leitura: Cap 3.5 CS:APP 17/09 Como a CPU representa e executa um programa escrito em C? Assembly: express\u00f5es booleanas e estruturas de controle condicionais 21/09 Como a CPU representa e executa um programa escrito em C? Assembly: estruturas de controle de loop Leitura: Cap 3.6 CS:APP 24/09 Como a CPU representa e executa um programa escrito em C? Revis\u00e3o; organiza\u00e7\u00e3o de execut\u00e1vel no disco e na mem\u00f3ria Assembly: vari\u00e1veis locais, strings e arrays Leitura: Cap 3.7 \u2013 3.8 CS:APP 28/09 Como a CPU representa e executa um programa escrito em C? Exerc\u00edcios pr\u00e1ticos de revis\u00e3o 01/10 E se meu programa precisar de mais mem\u00f3ria? A fun\u00e7\u00e3o malloc e a aloca\u00e7\u00e3o din\u00e2mica de estruturas, arrays e strings. Uso da ferramenta valgrind para checagem de mem\u00f3ria Leituras: Cap 16 Kochan (Prog in C); Cap 9.9 CS:APP 05/10 E se meu programa precisar de mais mem\u00f3ria? Tipos Abstratos de dados e aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria Leituras: Cap 6 K&R 08/10 PROVA INTERMEDI\u00c1RIA PROVA INTERMEDI\u00c1RIA 12/10 FERIADO FERIADO 15/10 O que \u00e9 um sistema operacional? Como os programas se comunicam com ele? Vis\u00e3o global de um sistema: kernel, sistema de arquivos, biblioteca padr\u00e3o e bootloaders Leitura: Cap 10.2 Tanenbaum; Kivity et al 2014. 19/10 Como tudo isto est\u00e1 organizado em um sistema operacional? Aula est\u00fadio para projeto: Linux do Zero 22/10 Como tudo isto est\u00e1 organizado em um sistema operacional? Aula est\u00fadio para projeto: Linux do Zero 26/10 O que \u00e9 um sistema operacional? Como os programas se comunicam com ele? Sistemas operacionais: processos. Explorando chamadas de sistemas para entrada/sa\u00edda Leitura: Cap 8 CS:APP, 29/10 O que \u00e9 um sistema operacional? Como os programas se comunicam com ele? Sistemas operacionais: processos. Explorando chamadas de sistemas para cria\u00e7\u00e3o de processo (fork) e espera de seus resultados (wait). Leitura: Cap 8 CS:APP, Leitura complementar sobre escalonamento de processos: Cap 5 Silberschats 02/11 FERIADO PROVA INTERMEDI\u00c1RIA 05/11 O que \u00e9 um sistema operacional? Como os programas se comunicam com ele? Sistemas operacionais: processos. Explorando chamadas de sistemas para execu\u00e7\u00e3o de programas (exec) Leitura: Cap 8 CS:APP, 09/11 E se o SO quiser avisar um processo que algo ocorreu? Sinais: conceitos, captura e bloqueio. Introdu\u00e7\u00e3o \u00e0 ideia de concorr\u00eancia 12/11 E se o SO quiser avisar um processo que algo ocorreu? Captura e bloqueio de sinais: teoria e exerc\u00edcios pr\u00e1ticos 16/11 Como envio informa\u00e7\u00f5es entre processos? Entrada e sa\u00edda padr\u00e3o, chamadas de sistema pipe, dup2 para redirecionamento de arquivos. 19/11 \u00c9 poss\u00edvel dividir o trabalho em partes que executem ao mesmo tempo? Introdu\u00e7\u00e3o ao conceito de threads e sua utiliza\u00e7\u00e3o Cria\u00e7\u00e3o de threads usando pthreads. Leitura: Cap 12 CS:APP 23/11 \u00c9 poss\u00edvel dividir o trabalho em partes que executem ao mesmo tempo? Tarefas IO- e CPU-bound. Sincroniza\u00e7\u00e3o usando sem\u00e1foros. Leitura: Cap 12 CS:APP 26/11 PROVA FINAL PROVA FINAL 30/11 PROVA FINAL PROVA FINAL 03/12 nan nan 07/12 PROVA SUB PROVA SUB","title":"Burocracias"},{"location":"sobre/#plano-de-aulas","text":"SEG 13:30 - 15:40 QUI 15:45 - 17:45 Atendimento: QUI 14:00 - 15:30 Plano de aulas Data Quest\u00e3o/Problema Conte\u00fado/Atividade 24/08 Mutir\u00e3o C Exerc\u00edcios pr\u00e1ticos de revis\u00e3o 27/08 Mutir\u00e3o C Exerc\u00edcios pr\u00e1ticos de revis\u00e3o 31/08 Como a CPU representa dados em baixo n\u00edvel? Representa\u00e7\u00e3o de inteiros na CPU: n\u00fameros bin\u00e1rios e hexadecimais, complemento de dois, opera\u00e7\u00f5es bit a bit. Leitura: Cap 2 CS:APP; Cap 9 Stallings 03/09 Como a CPU representa dados em baixo n\u00edvel? Representa\u00e7\u00e3o de ponteiros, arrays e estruturas em RAM. Leitura: Cap 2 CS:APP; Cap 9 Stallings 07/09 FERIADO FERIADO 10/09 Como a CPU representa e executa um programa escrito em C? Arquitetura de computadores: registradores, mem\u00f3ria e endere\u00e7amento Assembly: Organiza\u00e7\u00e3o de um execut\u00e1vel no disco e na mem\u00f3ria Leitura: Cap 3.1 \u2013 3.4 CS:APP 14/09 Como a CPU representa e executa um programa escrito em C? Arquitetura de computadores: chamadas de fun\u00e7\u00e3o e pilha Assembly: Exerc\u00edcios com chamadas de fun\u00e7\u00e3o e opera\u00e7\u00f5es com inteiros Leitura: Cap 3.5 CS:APP 17/09 Como a CPU representa e executa um programa escrito em C? Assembly: express\u00f5es booleanas e estruturas de controle condicionais 21/09 Como a CPU representa e executa um programa escrito em C? Assembly: estruturas de controle de loop Leitura: Cap 3.6 CS:APP 24/09 Como a CPU representa e executa um programa escrito em C? Revis\u00e3o; organiza\u00e7\u00e3o de execut\u00e1vel no disco e na mem\u00f3ria Assembly: vari\u00e1veis locais, strings e arrays Leitura: Cap 3.7 \u2013 3.8 CS:APP 28/09 Como a CPU representa e executa um programa escrito em C? Exerc\u00edcios pr\u00e1ticos de revis\u00e3o 01/10 E se meu programa precisar de mais mem\u00f3ria? A fun\u00e7\u00e3o malloc e a aloca\u00e7\u00e3o din\u00e2mica de estruturas, arrays e strings. Uso da ferramenta valgrind para checagem de mem\u00f3ria Leituras: Cap 16 Kochan (Prog in C); Cap 9.9 CS:APP 05/10 E se meu programa precisar de mais mem\u00f3ria? Tipos Abstratos de dados e aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria Leituras: Cap 6 K&R 08/10 PROVA INTERMEDI\u00c1RIA PROVA INTERMEDI\u00c1RIA 12/10 FERIADO FERIADO 15/10 O que \u00e9 um sistema operacional? Como os programas se comunicam com ele? Vis\u00e3o global de um sistema: kernel, sistema de arquivos, biblioteca padr\u00e3o e bootloaders Leitura: Cap 10.2 Tanenbaum; Kivity et al 2014. 19/10 Como tudo isto est\u00e1 organizado em um sistema operacional? Aula est\u00fadio para projeto: Linux do Zero 22/10 Como tudo isto est\u00e1 organizado em um sistema operacional? Aula est\u00fadio para projeto: Linux do Zero 26/10 O que \u00e9 um sistema operacional? Como os programas se comunicam com ele? Sistemas operacionais: processos. Explorando chamadas de sistemas para entrada/sa\u00edda Leitura: Cap 8 CS:APP, 29/10 O que \u00e9 um sistema operacional? Como os programas se comunicam com ele? Sistemas operacionais: processos. Explorando chamadas de sistemas para cria\u00e7\u00e3o de processo (fork) e espera de seus resultados (wait). Leitura: Cap 8 CS:APP, Leitura complementar sobre escalonamento de processos: Cap 5 Silberschats 02/11 FERIADO PROVA INTERMEDI\u00c1RIA 05/11 O que \u00e9 um sistema operacional? Como os programas se comunicam com ele? Sistemas operacionais: processos. Explorando chamadas de sistemas para execu\u00e7\u00e3o de programas (exec) Leitura: Cap 8 CS:APP, 09/11 E se o SO quiser avisar um processo que algo ocorreu? Sinais: conceitos, captura e bloqueio. Introdu\u00e7\u00e3o \u00e0 ideia de concorr\u00eancia 12/11 E se o SO quiser avisar um processo que algo ocorreu? Captura e bloqueio de sinais: teoria e exerc\u00edcios pr\u00e1ticos 16/11 Como envio informa\u00e7\u00f5es entre processos? Entrada e sa\u00edda padr\u00e3o, chamadas de sistema pipe, dup2 para redirecionamento de arquivos. 19/11 \u00c9 poss\u00edvel dividir o trabalho em partes que executem ao mesmo tempo? Introdu\u00e7\u00e3o ao conceito de threads e sua utiliza\u00e7\u00e3o Cria\u00e7\u00e3o de threads usando pthreads. Leitura: Cap 12 CS:APP 23/11 \u00c9 poss\u00edvel dividir o trabalho em partes que executem ao mesmo tempo? Tarefas IO- e CPU-bound. Sincroniza\u00e7\u00e3o usando sem\u00e1foros. Leitura: Cap 12 CS:APP 26/11 PROVA FINAL PROVA FINAL 30/11 PROVA FINAL PROVA FINAL 03/12 nan nan 07/12 PROVA SUB PROVA SUB","title":"Plano de aulas"},{"location":"aulas/99-corretor-automatico/","text":"99 - Corretor Autom\u00e1tico \u00b6 Algumas atividades de sala de aula entrar\u00e3o na nota final. Elas est\u00e3o marcadas como Entrega no in\u00edcio e ser\u00e3o entregues via um reposit\u00f3rio especial no Github. Preencha a pesquisa de usu\u00e1rios do Github Voc\u00ea receber\u00e1 um convite para reposit\u00f3rio. Todas as atividades ser\u00e3o disponibilizadas neste reposit\u00f3rio e suas solu\u00e7\u00f5es devem ser adicionadas nos arquivos correspondentes. O corretor autom\u00e1tico depende do pacote grading-tools , que dever\u00e1 ser instalado como abaixo. $> python3.8 -m pip install --user git+https://github.com/igordsm/grading-tools Python 3.8 no Ubuntu Se seu python3 \u00e9 uma vers\u00e3o inferior ao 3.8, voc\u00ea pode instal\u00e1-lo com os pacotes abaixo: python3.8 python3.8-dev A partir da\u00ed poder\u00e1 seguir normalmente as instru\u00e7\u00f5es desta p\u00e1gina. Com isso configurado, \u00e9 s\u00f3 compilar seu programa e rodar python3.8 corretor.py executavel . Para baixar os novos exerc\u00edcios \u00e9 s\u00f3 rodar git pull . Os exerc\u00edcios ser\u00e3o entregues criando um commit com sua resposta e dando git push . Warning Fique atento a atualiza\u00e7\u00f5es no seu reposit\u00f3rio de atividades. Todo novo exerc\u00edcio para entrega disponibilizado nos handouts devera aparecer no seu reposit\u00f3rio tamb\u00e9m. Ser\u00e1 avisado em aula se for necess\u00e1rio atualizar tamb\u00e9m o pacote acima.","title":"99 - Corretor Autom\u00e1tico"},{"location":"aulas/99-corretor-automatico/#99-corretor-automatico","text":"Algumas atividades de sala de aula entrar\u00e3o na nota final. Elas est\u00e3o marcadas como Entrega no in\u00edcio e ser\u00e3o entregues via um reposit\u00f3rio especial no Github. Preencha a pesquisa de usu\u00e1rios do Github Voc\u00ea receber\u00e1 um convite para reposit\u00f3rio. Todas as atividades ser\u00e3o disponibilizadas neste reposit\u00f3rio e suas solu\u00e7\u00f5es devem ser adicionadas nos arquivos correspondentes. O corretor autom\u00e1tico depende do pacote grading-tools , que dever\u00e1 ser instalado como abaixo. $> python3.8 -m pip install --user git+https://github.com/igordsm/grading-tools Python 3.8 no Ubuntu Se seu python3 \u00e9 uma vers\u00e3o inferior ao 3.8, voc\u00ea pode instal\u00e1-lo com os pacotes abaixo: python3.8 python3.8-dev A partir da\u00ed poder\u00e1 seguir normalmente as instru\u00e7\u00f5es desta p\u00e1gina. Com isso configurado, \u00e9 s\u00f3 compilar seu programa e rodar python3.8 corretor.py executavel . Para baixar os novos exerc\u00edcios \u00e9 s\u00f3 rodar git pull . Os exerc\u00edcios ser\u00e3o entregues criando um commit com sua resposta e dando git push . Warning Fique atento a atualiza\u00e7\u00f5es no seu reposit\u00f3rio de atividades. Todo novo exerc\u00edcio para entrega disponibilizado nos handouts devera aparecer no seu reposit\u00f3rio tamb\u00e9m. Ser\u00e1 avisado em aula se for necess\u00e1rio atualizar tamb\u00e9m o pacote acima.","title":"99 - Corretor Autom\u00e1tico"},{"location":"aulas/01-introducao/","text":"01 e 02 - Exerc\u00edcios de C \u00b6 O in\u00edcio do nosso curso ser\u00e1 uma revis\u00e3o de programa\u00e7\u00e3o em C . Flu\u00eancia nessa linguagem \u00e9 importante tanto para a primeira parte, em que examinamos como c\u00f3digo \u00e9 transformado em instru\u00e7\u00f5es de m\u00e1quina, quanto na segunda, em que usamos C para interagir com o sistema operacional. Importante Os exerc\u00edcios desta p\u00e1gina s\u00e3o complementares ao material do Mutir\u00e3o C . Pode ser uma boa revisitar o material do semestre passado para se recordar da estrutura b\u00e1sica de um programa em C e para as explica\u00e7\u00f5es detalhadas de cada funcionalidade usada nos exerc\u00edcios. Os exerc\u00edcios para entrega nesta p\u00e1gina contar\u00e3o na nota de atividades assim como os do restante do curso. Example Fa\u00e7a um programa que receba dois inteiros e mostre sua divis\u00e3o inteira, seu resto e sua divis\u00e3o fracion\u00e1ria (com at\u00e9 4 casas decimais). Se o segundo n\u00famero for 0, seu programa dever\u00e1 mostrar tr\u00eas 0 na sa\u00edda. Entrada 2 3 Sa\u00edda 0 2 0.6667 Example Fa\u00e7a um programa que mostra os d\u00edgitos de um n\u00famero ao contr\u00e1rio. Dica : use o operador resto da divis\u00e3o % . Entrada 123456 Sa\u00edda 6 5 4 3 2 1 Example Fa\u00e7a um programa que l\u00ea um inteiro n e depois n inteiros e computa sua m\u00e9dia. Entrada 4 1 2 3 4 Sa\u00edda 2.5 Example Entrega : Fa\u00e7a um programa que l\u00ea um inteiro n e mostre os n primeiros n\u00fameros da tabuada para todos os n\u00fameros entre 2 e n . Entrada 4 Sa\u00edda 2 4 6 8 3 6 9 12 4 8 12 16 Example Fa\u00e7a um programa que l\u00ea tr\u00eas inteiros n , d1 e d2 e imprime todos os inteiros entre 2 e n que s\u00e3o divis\u00edveis ao mesmo tempo por d1 e d2 . Entrada 15 3 2 Sa\u00edda 6 12 Example Fa\u00e7a um programa que l\u00ea at\u00e9 100 inteiros e os guarda em um vetor global nums . Voc\u00ea deve parar de ler inteiros ao receber um inteiro negativo, que n\u00e3o dever\u00e1 ser guardado. Depois de armazen\u00e1-los, leia um um n\u00famero d e imprima na tela quantos n\u00fameros lidos s\u00e3o maiores que d . Entrada : 1 2 3 4 -1 3 Sa\u00edda 1 Example Fa\u00e7a um programa que l\u00ea uma linha de texto e mostra no terminal seu tamanho. Entrada : abcdefgh Sa\u00edda 8 Example Fa\u00e7a um programa que l\u00ea uma linha de texto e conta quantas palavras tem na linha. Todo caractere n\u00e3o alfanum\u00e9rico divide uma palavra. Veja o exemplo abaixo. Entrada : palavra dois tres,quatro1continua. Cinco 3seis#sete Sa\u00edda 7 Example Entrega : Fa\u00e7a uma fun\u00e7\u00e3o que determina se uma string \u00e9 igual se lida de tr\u00e1s para frente. Voc\u00ea dever\u00e1 ignorar todos os caracteres n\u00e3o alfanum\u00e9ricos. Dica : Se necess\u00e1rio, consulte novamente a se\u00e7ao de Strings do Mutir\u00e3o. Como voc\u00ea checaria todos os caracteres entre '0' e '9'? E para as letras mai\u00fasculas e min\u00fasculas? Voc\u00ea pode precisar consultar a Tabela ASCII para entender melhor como fazer isso. Entrada : igual a laugi Sa\u00edda SIM Example Fa\u00e7a um programa que l\u00ea dois inteiros m < 100 e n < 100 . Ent\u00e3o seu programa dever\u00e1 ler uma matriz de m linhas por n colunas e mostrar no terminal o \u00edndice do maior valor de cada coluna. Declare sua matriz como vari\u00e1vel global. Iremos aprender como alocar matrizes de tamanho arbitr\u00e1rio no curso. Entrada : 3 4 1 2 5.8 6 3 6 9 8 5 2 3 2.0 Sa\u00edda 2 1 1 0 Example Entrega : Fa\u00e7a um programa que encontra \"vales\" em uma matriz. Uma posi\u00e7\u00e3o i,j \u00e9 um vale se todos os seus vizinhos diretos s\u00e3o maiores que ele. Considere que todas as posi\u00e7\u00f5es fora da matriz tem valor 0. Entrada : 5 5 1 1 2 4 7 4 5 -1 -2 8 1 1 1 1 2 4 5 0 6 10 4 4 4 4 4 Sa\u00edda 1 3 3 2","title":"01 e 02 - Exerc\u00edcios de C"},{"location":"aulas/01-introducao/#01-e-02-exercicios-de-c","text":"O in\u00edcio do nosso curso ser\u00e1 uma revis\u00e3o de programa\u00e7\u00e3o em C . Flu\u00eancia nessa linguagem \u00e9 importante tanto para a primeira parte, em que examinamos como c\u00f3digo \u00e9 transformado em instru\u00e7\u00f5es de m\u00e1quina, quanto na segunda, em que usamos C para interagir com o sistema operacional. Importante Os exerc\u00edcios desta p\u00e1gina s\u00e3o complementares ao material do Mutir\u00e3o C . Pode ser uma boa revisitar o material do semestre passado para se recordar da estrutura b\u00e1sica de um programa em C e para as explica\u00e7\u00f5es detalhadas de cada funcionalidade usada nos exerc\u00edcios. Os exerc\u00edcios para entrega nesta p\u00e1gina contar\u00e3o na nota de atividades assim como os do restante do curso. Example Fa\u00e7a um programa que receba dois inteiros e mostre sua divis\u00e3o inteira, seu resto e sua divis\u00e3o fracion\u00e1ria (com at\u00e9 4 casas decimais). Se o segundo n\u00famero for 0, seu programa dever\u00e1 mostrar tr\u00eas 0 na sa\u00edda. Entrada 2 3 Sa\u00edda 0 2 0.6667 Example Fa\u00e7a um programa que mostra os d\u00edgitos de um n\u00famero ao contr\u00e1rio. Dica : use o operador resto da divis\u00e3o % . Entrada 123456 Sa\u00edda 6 5 4 3 2 1 Example Fa\u00e7a um programa que l\u00ea um inteiro n e depois n inteiros e computa sua m\u00e9dia. Entrada 4 1 2 3 4 Sa\u00edda 2.5 Example Entrega : Fa\u00e7a um programa que l\u00ea um inteiro n e mostre os n primeiros n\u00fameros da tabuada para todos os n\u00fameros entre 2 e n . Entrada 4 Sa\u00edda 2 4 6 8 3 6 9 12 4 8 12 16 Example Fa\u00e7a um programa que l\u00ea tr\u00eas inteiros n , d1 e d2 e imprime todos os inteiros entre 2 e n que s\u00e3o divis\u00edveis ao mesmo tempo por d1 e d2 . Entrada 15 3 2 Sa\u00edda 6 12 Example Fa\u00e7a um programa que l\u00ea at\u00e9 100 inteiros e os guarda em um vetor global nums . Voc\u00ea deve parar de ler inteiros ao receber um inteiro negativo, que n\u00e3o dever\u00e1 ser guardado. Depois de armazen\u00e1-los, leia um um n\u00famero d e imprima na tela quantos n\u00fameros lidos s\u00e3o maiores que d . Entrada : 1 2 3 4 -1 3 Sa\u00edda 1 Example Fa\u00e7a um programa que l\u00ea uma linha de texto e mostra no terminal seu tamanho. Entrada : abcdefgh Sa\u00edda 8 Example Fa\u00e7a um programa que l\u00ea uma linha de texto e conta quantas palavras tem na linha. Todo caractere n\u00e3o alfanum\u00e9rico divide uma palavra. Veja o exemplo abaixo. Entrada : palavra dois tres,quatro1continua. Cinco 3seis#sete Sa\u00edda 7 Example Entrega : Fa\u00e7a uma fun\u00e7\u00e3o que determina se uma string \u00e9 igual se lida de tr\u00e1s para frente. Voc\u00ea dever\u00e1 ignorar todos os caracteres n\u00e3o alfanum\u00e9ricos. Dica : Se necess\u00e1rio, consulte novamente a se\u00e7ao de Strings do Mutir\u00e3o. Como voc\u00ea checaria todos os caracteres entre '0' e '9'? E para as letras mai\u00fasculas e min\u00fasculas? Voc\u00ea pode precisar consultar a Tabela ASCII para entender melhor como fazer isso. Entrada : igual a laugi Sa\u00edda SIM Example Fa\u00e7a um programa que l\u00ea dois inteiros m < 100 e n < 100 . Ent\u00e3o seu programa dever\u00e1 ler uma matriz de m linhas por n colunas e mostrar no terminal o \u00edndice do maior valor de cada coluna. Declare sua matriz como vari\u00e1vel global. Iremos aprender como alocar matrizes de tamanho arbitr\u00e1rio no curso. Entrada : 3 4 1 2 5.8 6 3 6 9 8 5 2 3 2.0 Sa\u00edda 2 1 1 0 Example Entrega : Fa\u00e7a um programa que encontra \"vales\" em uma matriz. Uma posi\u00e7\u00e3o i,j \u00e9 um vale se todos os seus vizinhos diretos s\u00e3o maiores que ele. Considere que todas as posi\u00e7\u00f5es fora da matriz tem valor 0. Entrada : 5 5 1 1 2 4 7 4 5 -1 -2 8 1 1 1 1 2 4 5 0 6 10 4 4 4 4 4 Sa\u00edda 1 3 3 2","title":"01 e 02 - Exerc\u00edcios de C"},{"location":"aulas/02-inteiros/","text":"02 - Inteiros na CPU \u00b6 Esta aula possui uma se\u00e7\u00e3o de exerc\u00edcios no reposit\u00f3rio de atividades: 04-inteiros .","title":"02 - Inteiros na CPU"},{"location":"aulas/02-inteiros/#02-inteiros-na-cpu","text":"Esta aula possui uma se\u00e7\u00e3o de exerc\u00edcios no reposit\u00f3rio de atividades: 04-inteiros .","title":"02 - Inteiros na CPU"},{"location":"aulas/03-ram/","text":"03 - Representa\u00e7\u00e3o de dados em RAM \u00b6 Experimentos \u00b6 Vamos trabalhar com os arquivos experimento0-4.c . Compile e execute cada um deles e coloque suas sa\u00eddas abaixo. Comente os resultados comparando os valores das constantes no c\u00f3digo em C e a sa\u00edda dos programas. Question Examine o c\u00f3digo C do arquivo experimento0.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento1.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento2.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento3.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento4.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Representa\u00e7\u00e3o de struct em RAM \u00b6 A utiliza\u00e7\u00e3o de struct junta tudo que j\u00e1 vimos sobre representa\u00e7\u00e3o de todos os tipos de dados na mem\u00f3ria. N\u00e3o se esque\u00e7a de levar em conta as quest\u00f5es de alinhamento mostradas na parte expositiva da aula. Warning Voc\u00ea n\u00e3o dever\u00e1 abrir o c\u00f3digo de parte1.c . Ele est\u00e1 no reposit\u00f3rio para voc\u00ea poder conferir suas respostas. Example A segunda parte da sa\u00edda de parte1 mostra os endere\u00e7os de cada campo do struct. Note que &one e &one.icon s\u00e3o iguais. Voc\u00ea consegue explicar por que? Se n\u00e3o, volte na aula expositiva e reveja a parte sobre struct e alinhamento de mem\u00f3ria. Example Os endere\u00e7os mostrados na sa\u00edda de parte1 pertencem a um s\u00f3 struct declarado como struct player one . Quais s\u00e3o os tamanhos de cada campo? Dica : pode n\u00e3o ser poss\u00edvel identificar exatamente o tamanho de cada campo, mas \u00e9 esperado que voc\u00ea identifique ao menos o tamanho m\u00e1ximo de cada um. Question Baseado nas respostas acima, declare abaixo o struct . Escreva-o da mesma maneira que usaria em um programa em C . Examinando a execu\u00e7\u00e3o de programas usando gdb \u00b6 Podemos examinar um programa durante sua execu\u00e7\u00e3o usando o gdb . Podemos parar em qualquer instru\u00e7\u00e3o do programa, examinar conte\u00fado de registradores e da mem\u00f3ria e listar todos os s\u00edmbolos dispon\u00edveis (que podem ser fun\u00e7\u00f5es ou vari\u00e1veis globais). Example Para compilar um programa com suporte a debugging usamos a flag -g do gcc $> gcc -g -Wall -pedantic exemplo1.c Siga os passos abaixo para para carregar um programa usando o gdb . Lance o gdb e passe para ele seu programa: $> gdb ./exemplo1 Isto nos colocar\u00e1 em um prompt esperando comandos. Para rodar o programa at\u00e9 o fim execute (gdb) run Para sair, (gdb) quit Tip O gdb \u00e9 uma ferramenta poderosa que possui muitas op\u00e7\u00f5es. Sua documenta\u00e7\u00e3o est\u00e1 online e pode ser vista em https://sourceware.org/gdb/current/onlinedocs/gdb/index.html#Top . Nesta primeira parte iremos abrir o arquivo parte2.c e olhar seu conte\u00fado. Tamb\u00e9m executaremos o programa compilado parte2 . Question Abra o c\u00f3digo parte2.c e liste os nomes das vari\u00e1veis globais declaradas e seus tamanhos. Anote tamb\u00e9m as fun\u00e7\u00f5es declaradas. Question O comando info mostra informa\u00e7\u00f5es que podem ser obtidas a partir de um execut\u00e1vel. Pesquise como usar este comando para listar as vari\u00e1veis globais e as fun\u00e7\u00f5es deste execut\u00e1vel. Voc\u00ea consegue encontrar as informa\u00e7\u00f5es listadas no exerc\u00edcio anterior? Escreva abaixo os comandos usados e as informa\u00e7\u00f5es obtidas Warning Muitos dos nomes s\u00e3o estranhos. Eles fazem parte do padr\u00e3o de arquivos execut\u00e1veis ELF , que cont\u00e9m informa\u00e7\u00f5es espec\u00edficas do sistema operacional usado. Voc\u00ea n\u00e3o precisa se preocupar com estes nomes. Question Qual \u00e9 o significado da primeira coluna do comando info variables ? Dica : o valor est\u00e1 em hexadecimal, que usamos na expositiva para mostrar ponteiros. Example Podemos usar o comando print para mostrar o valor inicial das vari\u00e1veis globais identificadas. Fa\u00e7a isto para as vari\u00e1veis identificadas acima. Escreva os comandos abaixo. Dicas: Pode n\u00e3o funcionar de primeira. O qu\u00ea a mensagem de erro diz? A sintaxe de convers\u00e3o de tipos ( casting ) pode ser \u00fatil aqui. Example Podemos usar o gdb tamb\u00e9m para examinar a mem\u00f3ria de um execut\u00e1vel. A se\u00e7\u00e3o 10.6 da documenta\u00e7\u00e3o explica como usar o comando explore ( x ) para examinar a mem\u00f3ria. Acesse esta p\u00e1gina da documenta\u00e7\u00e3o, entenda seu conte\u00fado e escreva abaixo qual o comando usado para mostrar o conte\u00fado do segundo item do vetor global_array . Dicas : volte no exerc\u00edcio 3 e encontre o endere\u00e7o do in\u00edcio do vetor calcule o endere\u00e7o do segundo elemento manualmente e passe para o comando x n\u00e3o se esque\u00e7a de buscar na mem\u00f3ria o tamanho correto do elemento Example Mostre agora o conte\u00fado de cada um dos bytes do item anterior. Ou seja, voc\u00ea dever\u00e1 dar dois comandos para examinar a mem\u00f3ria. Explique como converter esses dois bytes para o valor mostrado no exerc\u00edcio anterior. Example Use agora o comando x para exibir global_str como uma string . Escreva o comando abaixo.","title":"03 - Representa\u00e7\u00e3o de dados em RAM"},{"location":"aulas/03-ram/#03-representacao-de-dados-em-ram","text":"","title":"03 - Representa\u00e7\u00e3o de dados em RAM"},{"location":"aulas/03-ram/#experimentos","text":"Vamos trabalhar com os arquivos experimento0-4.c . Compile e execute cada um deles e coloque suas sa\u00eddas abaixo. Comente os resultados comparando os valores das constantes no c\u00f3digo em C e a sa\u00edda dos programas. Question Examine o c\u00f3digo C do arquivo experimento0.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento1.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento2.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento3.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento4.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa.","title":"Experimentos"},{"location":"aulas/03-ram/#representacao-de-struct-em-ram","text":"A utiliza\u00e7\u00e3o de struct junta tudo que j\u00e1 vimos sobre representa\u00e7\u00e3o de todos os tipos de dados na mem\u00f3ria. N\u00e3o se esque\u00e7a de levar em conta as quest\u00f5es de alinhamento mostradas na parte expositiva da aula. Warning Voc\u00ea n\u00e3o dever\u00e1 abrir o c\u00f3digo de parte1.c . Ele est\u00e1 no reposit\u00f3rio para voc\u00ea poder conferir suas respostas. Example A segunda parte da sa\u00edda de parte1 mostra os endere\u00e7os de cada campo do struct. Note que &one e &one.icon s\u00e3o iguais. Voc\u00ea consegue explicar por que? Se n\u00e3o, volte na aula expositiva e reveja a parte sobre struct e alinhamento de mem\u00f3ria. Example Os endere\u00e7os mostrados na sa\u00edda de parte1 pertencem a um s\u00f3 struct declarado como struct player one . Quais s\u00e3o os tamanhos de cada campo? Dica : pode n\u00e3o ser poss\u00edvel identificar exatamente o tamanho de cada campo, mas \u00e9 esperado que voc\u00ea identifique ao menos o tamanho m\u00e1ximo de cada um. Question Baseado nas respostas acima, declare abaixo o struct . Escreva-o da mesma maneira que usaria em um programa em C .","title":"Representa\u00e7\u00e3o de struct em RAM"},{"location":"aulas/03-ram/#examinando-a-execucao-de-programas-usando-gdb","text":"Podemos examinar um programa durante sua execu\u00e7\u00e3o usando o gdb . Podemos parar em qualquer instru\u00e7\u00e3o do programa, examinar conte\u00fado de registradores e da mem\u00f3ria e listar todos os s\u00edmbolos dispon\u00edveis (que podem ser fun\u00e7\u00f5es ou vari\u00e1veis globais). Example Para compilar um programa com suporte a debugging usamos a flag -g do gcc $> gcc -g -Wall -pedantic exemplo1.c Siga os passos abaixo para para carregar um programa usando o gdb . Lance o gdb e passe para ele seu programa: $> gdb ./exemplo1 Isto nos colocar\u00e1 em um prompt esperando comandos. Para rodar o programa at\u00e9 o fim execute (gdb) run Para sair, (gdb) quit Tip O gdb \u00e9 uma ferramenta poderosa que possui muitas op\u00e7\u00f5es. Sua documenta\u00e7\u00e3o est\u00e1 online e pode ser vista em https://sourceware.org/gdb/current/onlinedocs/gdb/index.html#Top . Nesta primeira parte iremos abrir o arquivo parte2.c e olhar seu conte\u00fado. Tamb\u00e9m executaremos o programa compilado parte2 . Question Abra o c\u00f3digo parte2.c e liste os nomes das vari\u00e1veis globais declaradas e seus tamanhos. Anote tamb\u00e9m as fun\u00e7\u00f5es declaradas. Question O comando info mostra informa\u00e7\u00f5es que podem ser obtidas a partir de um execut\u00e1vel. Pesquise como usar este comando para listar as vari\u00e1veis globais e as fun\u00e7\u00f5es deste execut\u00e1vel. Voc\u00ea consegue encontrar as informa\u00e7\u00f5es listadas no exerc\u00edcio anterior? Escreva abaixo os comandos usados e as informa\u00e7\u00f5es obtidas Warning Muitos dos nomes s\u00e3o estranhos. Eles fazem parte do padr\u00e3o de arquivos execut\u00e1veis ELF , que cont\u00e9m informa\u00e7\u00f5es espec\u00edficas do sistema operacional usado. Voc\u00ea n\u00e3o precisa se preocupar com estes nomes. Question Qual \u00e9 o significado da primeira coluna do comando info variables ? Dica : o valor est\u00e1 em hexadecimal, que usamos na expositiva para mostrar ponteiros. Example Podemos usar o comando print para mostrar o valor inicial das vari\u00e1veis globais identificadas. Fa\u00e7a isto para as vari\u00e1veis identificadas acima. Escreva os comandos abaixo. Dicas: Pode n\u00e3o funcionar de primeira. O qu\u00ea a mensagem de erro diz? A sintaxe de convers\u00e3o de tipos ( casting ) pode ser \u00fatil aqui. Example Podemos usar o gdb tamb\u00e9m para examinar a mem\u00f3ria de um execut\u00e1vel. A se\u00e7\u00e3o 10.6 da documenta\u00e7\u00e3o explica como usar o comando explore ( x ) para examinar a mem\u00f3ria. Acesse esta p\u00e1gina da documenta\u00e7\u00e3o, entenda seu conte\u00fado e escreva abaixo qual o comando usado para mostrar o conte\u00fado do segundo item do vetor global_array . Dicas : volte no exerc\u00edcio 3 e encontre o endere\u00e7o do in\u00edcio do vetor calcule o endere\u00e7o do segundo elemento manualmente e passe para o comando x n\u00e3o se esque\u00e7a de buscar na mem\u00f3ria o tamanho correto do elemento Example Mostre agora o conte\u00fado de cada um dos bytes do item anterior. Ou seja, voc\u00ea dever\u00e1 dar dois comandos para examinar a mem\u00f3ria. Explique como converter esses dois bytes para o valor mostrado no exerc\u00edcio anterior. Example Use agora o comando x para exibir global_str como uma string . Escreva o comando abaixo.","title":"Examinando a execu\u00e7\u00e3o de programas usando gdb"},{"location":"aulas/04-asm-1/","text":"04 - Registradores x64 e vari\u00e1veis globais \u00b6 No handout passado usamos o gdb para listar vari\u00e1veis globais, nomes de fun\u00e7\u00f5es e examinar endere\u00e7os de mem\u00f3ria. Neste handout vamos come\u00e7ar a usar o gdb tamb\u00e9m para examinar nossos programas durante sua execu\u00e7\u00e3o . Parando e continuando a execu\u00e7\u00e3o de um programa. \u00b6 Example Compile funcao1.c usando as flags da disciplina ( -Og -g -Wall -std=c99 ) Example Abra o arquivo com o gdb e liste suas fun\u00e7\u00f5es e suas vari\u00e1veis globais. N\u00e3o rode o programa ainda! Anote abaixo seus endere\u00e7os e nomes. Example O comando disas \u00e9 usado para mostrar as instru\u00e7\u00f5es de m\u00e1quina de uma fun\u00e7\u00e3o. Use-o para ver o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao1 . Liste abaixo quais registradores foram usados nesta fun\u00e7\u00e3o e qual o tamanho dos dados guardados neles. Example Com base nos tamanhos identificados, voc\u00ea consegue associar os registradores acima com as vari\u00e1veis no c\u00f3digo de funcao1 ? Example Use o comando breakpoint funcao1 para parar a execu\u00e7\u00e3o do programa quando a fun\u00e7\u00e3o funcao1 come\u00e7ar a executar. Execute o programa usando run . O qu\u00ea ocorre? Example Podemos usar o comando info registers edi para ver o conte\u00fado atual do registrador %edi . Qual \u00e9 este valor? Verifique quais argumentos s\u00e3o passados para funcao1 no c\u00f3digo C e, com estas informa\u00e7\u00f5es em m\u00e3os, verifique sua resposta do exerc\u00edcio 3 e escreva abaixo suas novas conclus\u00f5es. Example O comando stepi executa exatamente uma instru\u00e7\u00e3o de m\u00e1quina. Use-o uma vez e execute novamente disas funcao1 . O que aconteceu? \u00c9 poss\u00edvel saber em qual instru\u00e7\u00e3o o programa est\u00e1 parado? Example Cheque novamente o valor de %edi . Este valor condiz com a instru\u00e7\u00e3o executada? O que ela faz, exatamente? Example Use stepi para parar logo antes do retorno da fun\u00e7\u00e3o. Verifique o conte\u00fado do registrador %eax e compare-o com os prints feitos pelo program. Voc\u00ea consegue dizer seu uso? \\vspace{3em} Example Vamos agora analisar o registrador %rsi . Toda vez que um registrador aparece entre ( ) estamos fazendo um acesso a mem\u00f3ria. Ao mostrar seu conte\u00fado usando info registers rsi recebemos o endere\u00e7o de mem\u00f3ria que cont\u00e9m o dado que queremos acessar. Use o comando x para mostrar, em decimal, o int que est\u00e1 armazenado neste endere\u00e7o. \\vspace{3em} Example Execute o comando continue para continuar rodando o programa. Ele ir\u00e1 rodar at\u00e9 que o pr\u00f3ximo breakpoint seja alcan\u00e7ado ou at\u00e9 que o programa termine. Endere\u00e7amento relativo e vari\u00e1veis globais \u00b6 Na parte anterior analisamos o c\u00f3digo Assembly de nossa primeira fun\u00e7\u00e3o e vimos como mostrar o c\u00f3digo fonte de uma fun\u00e7\u00e3o usando disas mostrar o conte\u00fado de um registrador usando info registers executar exatamente uma instru\u00e7\u00e3o usando stepi Tamb\u00e9m vimos que ao colocar um registrador entre ( ) estamos fazendo um acesso a mem\u00f3ria. Esta opera\u00e7\u00e3o \u00e9 equivalente a desreferenciar um ponteiro usando *p . Neste roteiro iremos adicionar um detalhe importante: podemos fazer contas com endere\u00e7os usando esta nota\u00e7\u00e3o. Nos exemplo abaixo nos referimos a mem\u00f3ria como um grande vetor de bytes unsigned char M[] . Ou seja, ao acessar M[%rax] , por exemplo, estamos acessando o lugar na mem\u00f3ria cujo endere\u00e7o est\u00e1 escrito em %rax . 10(%rax) : acessa a mem\u00f3ria M[%rax + 10] . (%rax, %rdi, 4) : acessa a mem\u00f3ria M[%rax + 4 * % rdi] . Note que isto se parece com aritm\u00e9tica de ponteiros cujo tipo apontado seja inteiro, pois os endere\u00e7os pulam de 4 em 4 bytes. Example Saia e abra o gdb novamente. Mostre o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao2 e coloque um breakpoint em sua primeira instru\u00e7\u00e3o. Example Execute agora o programa. A execu\u00e7\u00e3o deve ter parado no in\u00edcio de funcao2 . Rode disas funcao2 . Question Voc\u00ea consegue identificar acessos a mem\u00f3ria em funcao2 ? Quais s\u00e3o de leitura e quais s\u00e3o de escrita? Qual o tamanho dos dados lidos/escritos? Question Qual o significado do registrador %rip ? Se n\u00e3o se lembrar reveja os slides. O tipo de acesso a mem\u00f3ria que estamos realizando se chama rip relative addressing . Este tipo de acesso \u00e9 reservado para vari\u00e1veis globais e dados somente leitura. Estes dados tem uma caracter\u00edstica especial: eles s\u00e3o copiados para a mem\u00f3ria seguindo o mesmo layout do arquivo execut\u00e1vel. Ou seja, as posi\u00e7\u00f5es relativas entre o c\u00f3digo e os dados globais s\u00e3o fixas. Question Anote abaixo o ende\u00e7o das fun\u00e7\u00f5es MOV que utilizam este acesso. Baseado nos exemplos acima, descubra o endere\u00e7o das vari\u00e1veis acessadas. Example Confira se o valor identificado na quest\u00e3o anterior \u00e9 o mesmo mostrado a direita das instru\u00e7\u00f5es MOV na sa\u00edda do disas . O gdb j\u00e1 calcula este endere\u00e7o para facilitar nossa vida, mas \u00e9 interessante calcular isto manualmente uma vez para entender melhor o processo. Question Use o comando continue para continuar o programa. Voc\u00ea deve estar agora na segunda execu\u00e7\u00e3o de funcao2 . Use o comando x para mostrar o valor armazenado na mem\u00f3ria calculada acima. Lendo o c\u00f3digo do programa, voc\u00ea consegue dizer qual vari\u00e1vel \u00e9 armazenada neste endere\u00e7o? O valor atual \u00e9 o esperado para a segunda execu\u00e7\u00e3o de funcao2 ? Al\u00e9m de poder mostrar valores na mem\u00f3ria podemos escrever valores tamb\u00e9m. A sintaxe usada \u00e9 a seguinte: set *( (tipo *) 0x.....) = valor onde devemos substituir tipo por um tipo b\u00e1sico de C , 0x... pelo endere\u00e7o desejado e valor pelo valor que queremos escrever. Note que o que estamos fazendo \u00e9 um cast do endere\u00e7o 0x.... para um ponteiro de tipo e depois estamos acessando o valor apontado usando * ! Question Escreva o valor -10 na mem\u00f3ria da vari\u00e1vel global usada em funcao2 . Rode o programa at\u00e9 o fim. O resultado foi o esperado? Escreva abaixo os comandos utilizados. \\vspace{5em} Desafio Localize na fun\u00e7\u00e3o main as chamadas ao comando printf . Encontre ent\u00e3o o endere\u00e7o das strings de formata\u00e7\u00e3o e use o comando x para mostr\u00e1-las no gdb. Escreva os comandos usados abaixo.","title":"04 - Registradores x64 e vari\u00e1veis globais"},{"location":"aulas/04-asm-1/#04-registradores-x64-e-variaveis-globais","text":"No handout passado usamos o gdb para listar vari\u00e1veis globais, nomes de fun\u00e7\u00f5es e examinar endere\u00e7os de mem\u00f3ria. Neste handout vamos come\u00e7ar a usar o gdb tamb\u00e9m para examinar nossos programas durante sua execu\u00e7\u00e3o .","title":"04 - Registradores x64 e vari\u00e1veis globais"},{"location":"aulas/04-asm-1/#parando-e-continuando-a-execucao-de-um-programa","text":"Example Compile funcao1.c usando as flags da disciplina ( -Og -g -Wall -std=c99 ) Example Abra o arquivo com o gdb e liste suas fun\u00e7\u00f5es e suas vari\u00e1veis globais. N\u00e3o rode o programa ainda! Anote abaixo seus endere\u00e7os e nomes. Example O comando disas \u00e9 usado para mostrar as instru\u00e7\u00f5es de m\u00e1quina de uma fun\u00e7\u00e3o. Use-o para ver o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao1 . Liste abaixo quais registradores foram usados nesta fun\u00e7\u00e3o e qual o tamanho dos dados guardados neles. Example Com base nos tamanhos identificados, voc\u00ea consegue associar os registradores acima com as vari\u00e1veis no c\u00f3digo de funcao1 ? Example Use o comando breakpoint funcao1 para parar a execu\u00e7\u00e3o do programa quando a fun\u00e7\u00e3o funcao1 come\u00e7ar a executar. Execute o programa usando run . O qu\u00ea ocorre? Example Podemos usar o comando info registers edi para ver o conte\u00fado atual do registrador %edi . Qual \u00e9 este valor? Verifique quais argumentos s\u00e3o passados para funcao1 no c\u00f3digo C e, com estas informa\u00e7\u00f5es em m\u00e3os, verifique sua resposta do exerc\u00edcio 3 e escreva abaixo suas novas conclus\u00f5es. Example O comando stepi executa exatamente uma instru\u00e7\u00e3o de m\u00e1quina. Use-o uma vez e execute novamente disas funcao1 . O que aconteceu? \u00c9 poss\u00edvel saber em qual instru\u00e7\u00e3o o programa est\u00e1 parado? Example Cheque novamente o valor de %edi . Este valor condiz com a instru\u00e7\u00e3o executada? O que ela faz, exatamente? Example Use stepi para parar logo antes do retorno da fun\u00e7\u00e3o. Verifique o conte\u00fado do registrador %eax e compare-o com os prints feitos pelo program. Voc\u00ea consegue dizer seu uso? \\vspace{3em} Example Vamos agora analisar o registrador %rsi . Toda vez que um registrador aparece entre ( ) estamos fazendo um acesso a mem\u00f3ria. Ao mostrar seu conte\u00fado usando info registers rsi recebemos o endere\u00e7o de mem\u00f3ria que cont\u00e9m o dado que queremos acessar. Use o comando x para mostrar, em decimal, o int que est\u00e1 armazenado neste endere\u00e7o. \\vspace{3em} Example Execute o comando continue para continuar rodando o programa. Ele ir\u00e1 rodar at\u00e9 que o pr\u00f3ximo breakpoint seja alcan\u00e7ado ou at\u00e9 que o programa termine.","title":"Parando e continuando a execu\u00e7\u00e3o de um programa."},{"location":"aulas/04-asm-1/#enderecamento-relativo-e-variaveis-globais","text":"Na parte anterior analisamos o c\u00f3digo Assembly de nossa primeira fun\u00e7\u00e3o e vimos como mostrar o c\u00f3digo fonte de uma fun\u00e7\u00e3o usando disas mostrar o conte\u00fado de um registrador usando info registers executar exatamente uma instru\u00e7\u00e3o usando stepi Tamb\u00e9m vimos que ao colocar um registrador entre ( ) estamos fazendo um acesso a mem\u00f3ria. Esta opera\u00e7\u00e3o \u00e9 equivalente a desreferenciar um ponteiro usando *p . Neste roteiro iremos adicionar um detalhe importante: podemos fazer contas com endere\u00e7os usando esta nota\u00e7\u00e3o. Nos exemplo abaixo nos referimos a mem\u00f3ria como um grande vetor de bytes unsigned char M[] . Ou seja, ao acessar M[%rax] , por exemplo, estamos acessando o lugar na mem\u00f3ria cujo endere\u00e7o est\u00e1 escrito em %rax . 10(%rax) : acessa a mem\u00f3ria M[%rax + 10] . (%rax, %rdi, 4) : acessa a mem\u00f3ria M[%rax + 4 * % rdi] . Note que isto se parece com aritm\u00e9tica de ponteiros cujo tipo apontado seja inteiro, pois os endere\u00e7os pulam de 4 em 4 bytes. Example Saia e abra o gdb novamente. Mostre o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao2 e coloque um breakpoint em sua primeira instru\u00e7\u00e3o. Example Execute agora o programa. A execu\u00e7\u00e3o deve ter parado no in\u00edcio de funcao2 . Rode disas funcao2 . Question Voc\u00ea consegue identificar acessos a mem\u00f3ria em funcao2 ? Quais s\u00e3o de leitura e quais s\u00e3o de escrita? Qual o tamanho dos dados lidos/escritos? Question Qual o significado do registrador %rip ? Se n\u00e3o se lembrar reveja os slides. O tipo de acesso a mem\u00f3ria que estamos realizando se chama rip relative addressing . Este tipo de acesso \u00e9 reservado para vari\u00e1veis globais e dados somente leitura. Estes dados tem uma caracter\u00edstica especial: eles s\u00e3o copiados para a mem\u00f3ria seguindo o mesmo layout do arquivo execut\u00e1vel. Ou seja, as posi\u00e7\u00f5es relativas entre o c\u00f3digo e os dados globais s\u00e3o fixas. Question Anote abaixo o ende\u00e7o das fun\u00e7\u00f5es MOV que utilizam este acesso. Baseado nos exemplos acima, descubra o endere\u00e7o das vari\u00e1veis acessadas. Example Confira se o valor identificado na quest\u00e3o anterior \u00e9 o mesmo mostrado a direita das instru\u00e7\u00f5es MOV na sa\u00edda do disas . O gdb j\u00e1 calcula este endere\u00e7o para facilitar nossa vida, mas \u00e9 interessante calcular isto manualmente uma vez para entender melhor o processo. Question Use o comando continue para continuar o programa. Voc\u00ea deve estar agora na segunda execu\u00e7\u00e3o de funcao2 . Use o comando x para mostrar o valor armazenado na mem\u00f3ria calculada acima. Lendo o c\u00f3digo do programa, voc\u00ea consegue dizer qual vari\u00e1vel \u00e9 armazenada neste endere\u00e7o? O valor atual \u00e9 o esperado para a segunda execu\u00e7\u00e3o de funcao2 ? Al\u00e9m de poder mostrar valores na mem\u00f3ria podemos escrever valores tamb\u00e9m. A sintaxe usada \u00e9 a seguinte: set *( (tipo *) 0x.....) = valor onde devemos substituir tipo por um tipo b\u00e1sico de C , 0x... pelo endere\u00e7o desejado e valor pelo valor que queremos escrever. Note que o que estamos fazendo \u00e9 um cast do endere\u00e7o 0x.... para um ponteiro de tipo e depois estamos acessando o valor apontado usando * ! Question Escreva o valor -10 na mem\u00f3ria da vari\u00e1vel global usada em funcao2 . Rode o programa at\u00e9 o fim. O resultado foi o esperado? Escreva abaixo os comandos utilizados. \\vspace{5em} Desafio Localize na fun\u00e7\u00e3o main as chamadas ao comando printf . Encontre ent\u00e3o o endere\u00e7o das strings de formata\u00e7\u00e3o e use o comando x para mostr\u00e1-las no gdb. Escreva os comandos usados abaixo.","title":"Endere\u00e7amento relativo e vari\u00e1veis globais"},{"location":"aulas/05-funcoes/","text":"05 - Fun\u00e7\u00f5es \u00b6 Neste handout vamos trabalhar pela primeira vez na tradu\u00e7\u00e3o reversa de programas em Assembly para C . Nas \u00faltimas aulas vimos as instru\u00e7\u00f5es mov e add e na aula de hoje vimos uma tabela grande com as instru\u00e7\u00f5es aritm\u00e9ticas ( add , sub , mul , imul , div , etc). Como em todas as aulas, veremos hoje um detalhe a mais sobre arquitetura x64 : chamadas de fun\u00e7\u00f5es e argumentos. Fun\u00e7\u00f5es e seus argumentos \u00b6 Em x64 os argumentos das fun\u00e7\u00f5es s\u00e3o passados nos registradores e o valor de retorno \u00e9 colocado tamb\u00e9m em um registrador. Argumentos inteiros ou ponteiros s\u00e3o passados nos registradores %rdi , %rsi , %rdx , %rcx , %r8 e %r9 ( nesta ordem ). Argumentos ponto flutuante s\u00e3o passados nos registradores %xmm0 at\u00e9 %xmm7 . Valores de retorno inteiros ou ponteiros s\u00e3o colocados no registrador %rax . Valores de retorno ponto flutuante s\u00e3o colocados no registrador %xmm0 . Para chamar fun\u00e7\u00f5es usamos a instru\u00e7\u00e3o call seguido do endere\u00e7o de mem\u00f3ria da fun\u00e7\u00e3o. O gdb cria um \"apelido\" para estes endere\u00e7os de mem\u00f3ria usando o nome original da fun\u00e7\u00e3o no arquivo .c . Assim, estas instru\u00e7\u00f5es s\u00e3o mostradas, normalmente, como call func1 , por exemplo. Note que antes de cada call devemos preencher os argumentos nos registradores corretos. Para retornar usamos a instru\u00e7\u00e3o ret . Ela \u00e9 equivalente ao comando return de C e devolver\u00e1 o valor armazenado no %rax (ou %xmm0 para ponto flutuante). N\u00e3o se esque\u00e7a da equival\u00eancia entre o tamanhos dos registradores e os tipos inteiros em C . Um resumo gr\u00e1fico pode ser visto nas figuras acima. 64 bits ( %rax , %rdi e outros que come\u00e7am com r ): ( unsigned ) long ou ponteiro; 32 bits ( %eax , %edi e outros que come\u00e7a com e e os que terminam em d como r10d ): int ou unsigned int ; 16 bits ( %ax , %di e outros com duas letras somente terminando em x ): short ou unsigned short 8 bits ( %al , %ah e outros com duas letras terminando em h ou l ): char ou unsigned char . Vamos agora praticar fazendo a tradu\u00e7\u00e3o de fun\u00e7\u00f5es que fazem aritm\u00e9tica simples entre inteiros (usando ou n\u00e3o ponteiros). O exemplo abaixo mostra todas as etapas que precisamos seguir para fazer a tradu\u00e7\u00e3o Assembly -> C. Exemplo guiado \u00b6 Dado o c\u00f3digo Assembly abaixo, fa\u00e7a sua tradu\u00e7\u00e3o para C 0000000000000000 <misterio1>: 0: 48 01 f7 add %rsi,%rdi 3: 48 8d 04 57 lea (%rdi,%rdx,2),%rax 7: c3 retq Assinatura da fun\u00e7\u00e3o \u00b6 Vamos come\u00e7ar pela assinatura da fun\u00e7\u00e3o. \u00c9 sempre \u00fatil identificar quais registradores s\u00e3o lidos antes de serem escritos. Isso nos ajuda a entender se um registrador \u00e9 um argumento da fun\u00e7\u00e3o ou se ele \u00e9 apenas usado como vari\u00e1vel local. Faremos isso escrevendo todos os registradores que podem ser argumentos em ordem e vendo se s\u00e3o lidos ou escritos primeiro: %rdi - lido primeiro ( add faz a opera\u00e7\u00e3o += ) %rsi - lido primeiro (no lado esquerdo do add ) %rdx - lido primeiro (no lado esquerdo do lea ) %rcx - n\u00e3o usado %r8 - n\u00e3o usado %r9 - n\u00e3o usado Logo, os registradores %rdi , %rsi e %rdx s\u00e3o argumentos da fun\u00e7\u00e3o. Consultando o box de arquitetura de computadores, vemos que a fun\u00e7\u00e3o recebe tr\u00eas argumentos do tipo long (pois usa os registradores de 64 bits). Note que o resultado das computa\u00e7\u00f5es \u00e9 guardado em %rax , que guarda sempre o retorno da fun\u00e7\u00e3o. Por usar a por\u00e7\u00e3o de 64 bits do registrador, o tipo de retorno tamb\u00e9m \u00e9 long . A assinatura da fun\u00e7\u00e3o \u00e9, portanto long misterio1(long a, long b, long c); Tip Ponteiros tamb\u00e9m usam os registradores de 64 bits. Por\u00e9m, olhando rapidamente o c\u00f3digo notamos que n\u00e3o h\u00e1 nenhum acesso a mem\u00f3ria. Logo, se trata realmente de long . O c\u00f3digo \u00b6 Vamos agora para o c\u00f3digo. Nossa primeira estrat\u00e9gia \u00e9 atribuir um nome para cada registrador. Os tr\u00eas registradores de argumentos j\u00e1 receberam os nomes a , b e c . Para deixar expl\u00edcito o papel do %rax vamos nome\u00e1-lo de retval . A primeira instru\u00e7\u00e3o add %rsi, %rdi realiza a adi\u00e7\u00e3o dos dois registradores e armazena em %rdi . Logo, sua tradu\u00e7\u00e3o direta seria: a += b ; A instru\u00e7\u00e3o lea (%rdi, %rdx, 2), %rax \u00e9 usada tanto para calcular endere\u00e7os de mem\u00f3ria quanto para aritm\u00e9tica simples. Vemos que \u00e9 o segundo caso pois, no c\u00f3digo seguinte, n\u00e3o acessamos a mem\u00f3ria com o valor calculado. Logo, podemos traduzir este trecho como retval = a + 2 * c ; Logo ap\u00f3s temos o ret , que \u00e9 traduzido como return retval ; Logo, nossa fun\u00e7\u00e3o \u00e9 traduzida como long misterio1 ( long a , long b , long c ){ long retval ; a += b ; retval = a + 2 * c ; return retval ; } Finalmente, podemos deixar nosso c\u00f3digo leg\u00edvel e escrev\u00ea-lo como long misterio1 ( long a , long b , long c ){ return a + b + 2 * c ; } Voc\u00ea pode verificar o c\u00f3digo original no arquivo exemplo1.c . O processo acima pode ser formalizado no seguinte algoritmo: Identifique quantos argumentos a fun\u00e7\u00e3o recebe Identifique os tipos de cada argumento (pode ser necess\u00e1rio olhar o c\u00f3digo assembly da fun\u00e7\u00e3o) D\u00ea um nome para cada registrador. Se um mesmo registrador \u00e9 usado com tamanhos diferentes ( %rdi e %edi s\u00e3o usados no c\u00f3digo), d\u00ea um nome diferente para cada tamanho. Fa\u00e7a a tradu\u00e7\u00e3o de cada instru\u00e7\u00e3o separadamente. Fique atento aos valores colocados em %rax e %eax perto do fim do c\u00f3digo. Esses valores ser\u00e3o retornados pela fun\u00e7\u00e3o. O c\u00f3digo gerado costuma ser ileg\u00edvel. Refatore-o para melhorar sua legibilidade. Tip A instru\u00e7\u00e3o lea pode ser usada tanto para aritm\u00e9tica quanto para c\u00e1lculo de endere\u00e7os. Para tirar a d\u00favida basta olhar se as pr\u00f3ximas instru\u00e7\u00f5es fazem acesso \u00e0 mem\u00f3ria com o endere\u00e7o calculado ou apenas usam o valor diretamente (aritm\u00e9tica). Os registradores de tamanhos menores s\u00e3o virtuais. Quanto escrevo em %ax estou escrevendo nos 16 bits menos significativos de %rax e de %eax tamb\u00e9m. Muitas instru\u00e7\u00f5es com operadores de 32bits zeram os 32bits superiores. Assim, vemos por exemplo a instru\u00e7\u00e3o mov $0, %eax sendo usada para zerar um long . Nesses casos \u00e9 necess\u00e1rio verificar se a fun\u00e7\u00e3o continua usando %eax (\u00e9 int mesmo) ou se ela magicamente passa a usar %rax (o tipo era long ). Pr\u00e1tica \u00b6 Vamos agora exercitar. Cada exerc\u00edcio faz um c\u00e1lculo diferente. Se houver alguma instru\u00e7\u00e3o desconhecida, pesquise-a no google para encontrar seu significado. Normalmente algo como \"asm x64 instruction\" + a instru\u00e7\u00e3o desconhecida d\u00e1 respostas corretas. Warning Usaremos o gdb para abrir os arquivos .o nesta aula. Este tipo de arquivo cont\u00e9m fun\u00e7\u00f5es compiladas, mas n\u00e3o \u00e9 um execut\u00e1vel completo por n\u00e3o ter uma fun\u00e7\u00e3o main . Arquivo ex1.o \u00b6 Question O c\u00f3digo abaixo foi retirado do arquivo ex1.o . Fa\u00e7a sua tradu\u00e7\u00e3o para C . 0000000000000000 <ex1>: 0: 89 f8 mov %edi,%eax 2: 29 f0 sub %esi,%eax 4: c3 retq Arquivo ex2.o \u00b6 Question Use o gdb para listar as fun\u00e7\u00f5es definidas em ex2.o e escreva-as abaixo. Question Fa\u00e7a a tradu\u00e7\u00e3o das fun\u00e7\u00f5es acima para C Arquivo ex3.o \u00b6 A fun\u00e7\u00e3o abaixo foi obtida de ex3.o . 0000000000000000 <ex3>: 0: 8b 06 mov (%rsi),%eax 2: 0f af c0 imul %eax,%eax 5: 89 07 mov %eax,(%rdi) 7: c3 retq Question O qu\u00ea faz a instru\u00e7\u00e3o imul ? Question Traduza esta fun\u00e7\u00e3o para C . Fique atento ao tamanho dos registradores usados para identificar o tamanho dos vari\u00e1veis inteiras. Antes de prosseguir, valide suas solu\u00e7\u00f5es da se\u00e7\u00e3o anterior com o professor. Vamos agora trabalhar com execut\u00e1veis \"completos\". Vamos analisar n\u00e3o somente o c\u00f3digo das fun\u00e7\u00f5es mas tamb\u00e9m sua chamada. Arquivo ex4 \u00b6 Example Use o gdb para obter o conte\u00fado das fun\u00e7\u00f5es main e ex4 . Dica : lembre-se do comando disas Localize a chamada da fun\u00e7\u00e3o ex4 no main. As intru\u00e7\u00f5es acima do call colocam os argumentos nos lugares corretos para ex4 rodar. Question Quantos argumentos a fun\u00e7\u00e3o recebe? Quais s\u00e3o seus valores? Question Traduza a fun\u00e7\u00e3o ex4 para C . Arquivo ex5 (desafio) \u00b6 Warning Este exerc\u00edcio \u00e9 avan\u00e7ado e necessita de pesquisa para ser realizado. Fa\u00e7a-o somente ap\u00f3s validar suas solu\u00e7\u00f5es dos anteriores com os professores. Neste exerc\u00edcio vamos nos aprofundar no uso de ponteiros. Vimos no ex3.o um exemplo de fun\u00e7\u00e3o que armazenava um valor calculado em um ponteiro. Agora veremos um exemplo completo que inclui a chamada de uma fun\u00e7\u00e3o recebendo um endere\u00e7o. O trecho abaixo copia os argumentos para os registradores corretos e chama a fun\u00e7\u00e3o. 60b: 48 8d 4c 24 08 lea 0x8(%rsp),%rcx 610: 48 8d 54 24 0c lea 0xc(%rsp),%rdx 615: be 03 00 00 00 mov $0x3,%esi 61a: bf 0a 00 00 00 mov $0xa,%edi 61f: e8 d6 ff ff ff callq 5fa <ex5> Question Identifique a partir dos tipos de dados colocados nos registradores qual o tipo dos argumentos da fun\u00e7\u00e3o. Question Qual s\u00e3o os endere\u00e7os passados para a fun\u00e7\u00e3o ex5 ? Escreva-os em fun\u00e7\u00e3o do registrador %rsp . Question Os endere\u00e7os acima s\u00e3o passados em quais registradores? Vamos agora ao c\u00f3digo de ex5 : 00000000000005fa <ex5>: 5fa: 89 f8 mov %edi,%eax 5fc: 48 89 d7 mov %rdx,%rdi 5ff: 99 cltd 600: f7 fe idiv %esi 602: 89 07 mov %eax,(%rdi) 604: 89 11 mov %edx,(%rcx) 606: c3 retq Question Como a instru\u00e7\u00e3o idiv funciona? Em quais registradores ela posiciona seu resultado? Em quais registradores ela espera a entrada? Question O qu\u00ea faz a instru\u00e7\u00e3o cltd ? Por qu\u00ea ela \u00e9 necess\u00e1ria? Question Fa\u00e7a a tradu\u00e7\u00e3o de ex5 para C .","title":"05 - Fun\u00e7\u00f5es"},{"location":"aulas/05-funcoes/#05-funcoes","text":"Neste handout vamos trabalhar pela primeira vez na tradu\u00e7\u00e3o reversa de programas em Assembly para C . Nas \u00faltimas aulas vimos as instru\u00e7\u00f5es mov e add e na aula de hoje vimos uma tabela grande com as instru\u00e7\u00f5es aritm\u00e9ticas ( add , sub , mul , imul , div , etc). Como em todas as aulas, veremos hoje um detalhe a mais sobre arquitetura x64 : chamadas de fun\u00e7\u00f5es e argumentos.","title":"05 - Fun\u00e7\u00f5es"},{"location":"aulas/05-funcoes/#funcoes-e-seus-argumentos","text":"Em x64 os argumentos das fun\u00e7\u00f5es s\u00e3o passados nos registradores e o valor de retorno \u00e9 colocado tamb\u00e9m em um registrador. Argumentos inteiros ou ponteiros s\u00e3o passados nos registradores %rdi , %rsi , %rdx , %rcx , %r8 e %r9 ( nesta ordem ). Argumentos ponto flutuante s\u00e3o passados nos registradores %xmm0 at\u00e9 %xmm7 . Valores de retorno inteiros ou ponteiros s\u00e3o colocados no registrador %rax . Valores de retorno ponto flutuante s\u00e3o colocados no registrador %xmm0 . Para chamar fun\u00e7\u00f5es usamos a instru\u00e7\u00e3o call seguido do endere\u00e7o de mem\u00f3ria da fun\u00e7\u00e3o. O gdb cria um \"apelido\" para estes endere\u00e7os de mem\u00f3ria usando o nome original da fun\u00e7\u00e3o no arquivo .c . Assim, estas instru\u00e7\u00f5es s\u00e3o mostradas, normalmente, como call func1 , por exemplo. Note que antes de cada call devemos preencher os argumentos nos registradores corretos. Para retornar usamos a instru\u00e7\u00e3o ret . Ela \u00e9 equivalente ao comando return de C e devolver\u00e1 o valor armazenado no %rax (ou %xmm0 para ponto flutuante). N\u00e3o se esque\u00e7a da equival\u00eancia entre o tamanhos dos registradores e os tipos inteiros em C . Um resumo gr\u00e1fico pode ser visto nas figuras acima. 64 bits ( %rax , %rdi e outros que come\u00e7am com r ): ( unsigned ) long ou ponteiro; 32 bits ( %eax , %edi e outros que come\u00e7a com e e os que terminam em d como r10d ): int ou unsigned int ; 16 bits ( %ax , %di e outros com duas letras somente terminando em x ): short ou unsigned short 8 bits ( %al , %ah e outros com duas letras terminando em h ou l ): char ou unsigned char . Vamos agora praticar fazendo a tradu\u00e7\u00e3o de fun\u00e7\u00f5es que fazem aritm\u00e9tica simples entre inteiros (usando ou n\u00e3o ponteiros). O exemplo abaixo mostra todas as etapas que precisamos seguir para fazer a tradu\u00e7\u00e3o Assembly -> C.","title":"Fun\u00e7\u00f5es e seus argumentos"},{"location":"aulas/05-funcoes/#exemplo-guiado","text":"Dado o c\u00f3digo Assembly abaixo, fa\u00e7a sua tradu\u00e7\u00e3o para C 0000000000000000 <misterio1>: 0: 48 01 f7 add %rsi,%rdi 3: 48 8d 04 57 lea (%rdi,%rdx,2),%rax 7: c3 retq","title":"Exemplo guiado"},{"location":"aulas/05-funcoes/#assinatura-da-funcao","text":"Vamos come\u00e7ar pela assinatura da fun\u00e7\u00e3o. \u00c9 sempre \u00fatil identificar quais registradores s\u00e3o lidos antes de serem escritos. Isso nos ajuda a entender se um registrador \u00e9 um argumento da fun\u00e7\u00e3o ou se ele \u00e9 apenas usado como vari\u00e1vel local. Faremos isso escrevendo todos os registradores que podem ser argumentos em ordem e vendo se s\u00e3o lidos ou escritos primeiro: %rdi - lido primeiro ( add faz a opera\u00e7\u00e3o += ) %rsi - lido primeiro (no lado esquerdo do add ) %rdx - lido primeiro (no lado esquerdo do lea ) %rcx - n\u00e3o usado %r8 - n\u00e3o usado %r9 - n\u00e3o usado Logo, os registradores %rdi , %rsi e %rdx s\u00e3o argumentos da fun\u00e7\u00e3o. Consultando o box de arquitetura de computadores, vemos que a fun\u00e7\u00e3o recebe tr\u00eas argumentos do tipo long (pois usa os registradores de 64 bits). Note que o resultado das computa\u00e7\u00f5es \u00e9 guardado em %rax , que guarda sempre o retorno da fun\u00e7\u00e3o. Por usar a por\u00e7\u00e3o de 64 bits do registrador, o tipo de retorno tamb\u00e9m \u00e9 long . A assinatura da fun\u00e7\u00e3o \u00e9, portanto long misterio1(long a, long b, long c); Tip Ponteiros tamb\u00e9m usam os registradores de 64 bits. Por\u00e9m, olhando rapidamente o c\u00f3digo notamos que n\u00e3o h\u00e1 nenhum acesso a mem\u00f3ria. Logo, se trata realmente de long .","title":"Assinatura da fun\u00e7\u00e3o"},{"location":"aulas/05-funcoes/#o-codigo","text":"Vamos agora para o c\u00f3digo. Nossa primeira estrat\u00e9gia \u00e9 atribuir um nome para cada registrador. Os tr\u00eas registradores de argumentos j\u00e1 receberam os nomes a , b e c . Para deixar expl\u00edcito o papel do %rax vamos nome\u00e1-lo de retval . A primeira instru\u00e7\u00e3o add %rsi, %rdi realiza a adi\u00e7\u00e3o dos dois registradores e armazena em %rdi . Logo, sua tradu\u00e7\u00e3o direta seria: a += b ; A instru\u00e7\u00e3o lea (%rdi, %rdx, 2), %rax \u00e9 usada tanto para calcular endere\u00e7os de mem\u00f3ria quanto para aritm\u00e9tica simples. Vemos que \u00e9 o segundo caso pois, no c\u00f3digo seguinte, n\u00e3o acessamos a mem\u00f3ria com o valor calculado. Logo, podemos traduzir este trecho como retval = a + 2 * c ; Logo ap\u00f3s temos o ret , que \u00e9 traduzido como return retval ; Logo, nossa fun\u00e7\u00e3o \u00e9 traduzida como long misterio1 ( long a , long b , long c ){ long retval ; a += b ; retval = a + 2 * c ; return retval ; } Finalmente, podemos deixar nosso c\u00f3digo leg\u00edvel e escrev\u00ea-lo como long misterio1 ( long a , long b , long c ){ return a + b + 2 * c ; } Voc\u00ea pode verificar o c\u00f3digo original no arquivo exemplo1.c . O processo acima pode ser formalizado no seguinte algoritmo: Identifique quantos argumentos a fun\u00e7\u00e3o recebe Identifique os tipos de cada argumento (pode ser necess\u00e1rio olhar o c\u00f3digo assembly da fun\u00e7\u00e3o) D\u00ea um nome para cada registrador. Se um mesmo registrador \u00e9 usado com tamanhos diferentes ( %rdi e %edi s\u00e3o usados no c\u00f3digo), d\u00ea um nome diferente para cada tamanho. Fa\u00e7a a tradu\u00e7\u00e3o de cada instru\u00e7\u00e3o separadamente. Fique atento aos valores colocados em %rax e %eax perto do fim do c\u00f3digo. Esses valores ser\u00e3o retornados pela fun\u00e7\u00e3o. O c\u00f3digo gerado costuma ser ileg\u00edvel. Refatore-o para melhorar sua legibilidade. Tip A instru\u00e7\u00e3o lea pode ser usada tanto para aritm\u00e9tica quanto para c\u00e1lculo de endere\u00e7os. Para tirar a d\u00favida basta olhar se as pr\u00f3ximas instru\u00e7\u00f5es fazem acesso \u00e0 mem\u00f3ria com o endere\u00e7o calculado ou apenas usam o valor diretamente (aritm\u00e9tica). Os registradores de tamanhos menores s\u00e3o virtuais. Quanto escrevo em %ax estou escrevendo nos 16 bits menos significativos de %rax e de %eax tamb\u00e9m. Muitas instru\u00e7\u00f5es com operadores de 32bits zeram os 32bits superiores. Assim, vemos por exemplo a instru\u00e7\u00e3o mov $0, %eax sendo usada para zerar um long . Nesses casos \u00e9 necess\u00e1rio verificar se a fun\u00e7\u00e3o continua usando %eax (\u00e9 int mesmo) ou se ela magicamente passa a usar %rax (o tipo era long ).","title":"O c\u00f3digo"},{"location":"aulas/05-funcoes/#pratica","text":"Vamos agora exercitar. Cada exerc\u00edcio faz um c\u00e1lculo diferente. Se houver alguma instru\u00e7\u00e3o desconhecida, pesquise-a no google para encontrar seu significado. Normalmente algo como \"asm x64 instruction\" + a instru\u00e7\u00e3o desconhecida d\u00e1 respostas corretas. Warning Usaremos o gdb para abrir os arquivos .o nesta aula. Este tipo de arquivo cont\u00e9m fun\u00e7\u00f5es compiladas, mas n\u00e3o \u00e9 um execut\u00e1vel completo por n\u00e3o ter uma fun\u00e7\u00e3o main .","title":"Pr\u00e1tica"},{"location":"aulas/05-funcoes/#arquivo-ex1o","text":"Question O c\u00f3digo abaixo foi retirado do arquivo ex1.o . Fa\u00e7a sua tradu\u00e7\u00e3o para C . 0000000000000000 <ex1>: 0: 89 f8 mov %edi,%eax 2: 29 f0 sub %esi,%eax 4: c3 retq","title":"Arquivo ex1.o"},{"location":"aulas/05-funcoes/#arquivo-ex2o","text":"Question Use o gdb para listar as fun\u00e7\u00f5es definidas em ex2.o e escreva-as abaixo. Question Fa\u00e7a a tradu\u00e7\u00e3o das fun\u00e7\u00f5es acima para C","title":"Arquivo ex2.o"},{"location":"aulas/05-funcoes/#arquivo-ex3o","text":"A fun\u00e7\u00e3o abaixo foi obtida de ex3.o . 0000000000000000 <ex3>: 0: 8b 06 mov (%rsi),%eax 2: 0f af c0 imul %eax,%eax 5: 89 07 mov %eax,(%rdi) 7: c3 retq Question O qu\u00ea faz a instru\u00e7\u00e3o imul ? Question Traduza esta fun\u00e7\u00e3o para C . Fique atento ao tamanho dos registradores usados para identificar o tamanho dos vari\u00e1veis inteiras. Antes de prosseguir, valide suas solu\u00e7\u00f5es da se\u00e7\u00e3o anterior com o professor. Vamos agora trabalhar com execut\u00e1veis \"completos\". Vamos analisar n\u00e3o somente o c\u00f3digo das fun\u00e7\u00f5es mas tamb\u00e9m sua chamada.","title":"Arquivo ex3.o"},{"location":"aulas/05-funcoes/#arquivo-ex4","text":"Example Use o gdb para obter o conte\u00fado das fun\u00e7\u00f5es main e ex4 . Dica : lembre-se do comando disas Localize a chamada da fun\u00e7\u00e3o ex4 no main. As intru\u00e7\u00f5es acima do call colocam os argumentos nos lugares corretos para ex4 rodar. Question Quantos argumentos a fun\u00e7\u00e3o recebe? Quais s\u00e3o seus valores? Question Traduza a fun\u00e7\u00e3o ex4 para C .","title":"Arquivo ex4"},{"location":"aulas/05-funcoes/#arquivo-ex5-desafio","text":"Warning Este exerc\u00edcio \u00e9 avan\u00e7ado e necessita de pesquisa para ser realizado. Fa\u00e7a-o somente ap\u00f3s validar suas solu\u00e7\u00f5es dos anteriores com os professores. Neste exerc\u00edcio vamos nos aprofundar no uso de ponteiros. Vimos no ex3.o um exemplo de fun\u00e7\u00e3o que armazenava um valor calculado em um ponteiro. Agora veremos um exemplo completo que inclui a chamada de uma fun\u00e7\u00e3o recebendo um endere\u00e7o. O trecho abaixo copia os argumentos para os registradores corretos e chama a fun\u00e7\u00e3o. 60b: 48 8d 4c 24 08 lea 0x8(%rsp),%rcx 610: 48 8d 54 24 0c lea 0xc(%rsp),%rdx 615: be 03 00 00 00 mov $0x3,%esi 61a: bf 0a 00 00 00 mov $0xa,%edi 61f: e8 d6 ff ff ff callq 5fa <ex5> Question Identifique a partir dos tipos de dados colocados nos registradores qual o tipo dos argumentos da fun\u00e7\u00e3o. Question Qual s\u00e3o os endere\u00e7os passados para a fun\u00e7\u00e3o ex5 ? Escreva-os em fun\u00e7\u00e3o do registrador %rsp . Question Os endere\u00e7os acima s\u00e3o passados em quais registradores? Vamos agora ao c\u00f3digo de ex5 : 00000000000005fa <ex5>: 5fa: 89 f8 mov %edi,%eax 5fc: 48 89 d7 mov %rdx,%rdi 5ff: 99 cltd 600: f7 fe idiv %esi 602: 89 07 mov %eax,(%rdi) 604: 89 11 mov %edx,(%rcx) 606: c3 retq Question Como a instru\u00e7\u00e3o idiv funciona? Em quais registradores ela posiciona seu resultado? Em quais registradores ela espera a entrada? Question O qu\u00ea faz a instru\u00e7\u00e3o cltd ? Por qu\u00ea ela \u00e9 necess\u00e1ria? Question Fa\u00e7a a tradu\u00e7\u00e3o de ex5 para C .","title":"Arquivo ex5 (desafio)"},{"location":"aulas/06-condicionais/","text":"06 - Condicionais \u00b6 Express\u00f5es booleanas \u00b6 Vimos na expositiva que toda opera\u00e7\u00e3o aritm\u00e9tica preenche as flags CF , ZF , SF e OF e que podemos usar estas flags para montar express\u00f5es booleanas com as instru\u00e7\u00f5es set* . A tabela abaixo mostra as instru\u00e7\u00f5es respons\u00e1veis cada tipo de express\u00e3o booleana. Tamb\u00e9m vimos que podemos preencher estas flags usando as instru\u00e7\u00f5es cmp e test , que executam opera\u00e7\u00f5es aritm\u00e9ticas (subtra\u00e7\u00e3o e E bit a bit) mas n\u00e3o guardam o resultado. Vamos analisar o c\u00f3digo assembly da seguinte fun\u00e7\u00e3o: int igual ( int a , int b ) { return a == b ; } 0000000000000000 < igual > : 0: 39 f7 cmp %esi , %edi 2: 0 f 94 c0 sete %al 5: 0 f b6 c0 movzbl %al , %eax 8: c3 retq A compara\u00e7\u00e3o a == b \u00e9 feita primeiro executando cmp entre os argumentos %edi e %esi e depois usando sete ( set equal ) para atribuir 1 %al se %edi == %esi e 0 caso contr\u00e1rio. Por fim, temos a instru\u00e7\u00e3o movzbl , que faz o cast de char ( %al ) para int ( %eax ). Lembre-se que as instru\u00e7\u00f5es set* s\u00f3 modificam os primeiros 8 bits de %eax . O restante continua com o valor antigo. Usamos movzbl para extender o n\u00famero em %al para ocupar todo %eax . Tip As instru\u00e7\u00f5es de convers\u00e3o de tipos s\u00e3o bastante frequentes em Assembly, principalmente para expandir valores colocados em registradores menores para registradores maiores. Elas seguem a seguinte regra: MOVtsd t pode ser z para tipos unsigned (completando com **z**eros) e s para tipos signed (completando com o bit de **s**inal). s \u00e9 o tamanho do registrador fonte seguindo a nota\u00e7\u00e3o b para 1 byte, w para 2 bytes, l para 4 bytes e q para 8 bytes. d \u00e9 o tamanho do registrador destino, seguinto a mesma nota\u00e7\u00e3o acima. Por exemplo, a instru\u00e7\u00e3o MOVZWQ converte um unsigned short para um unsigned long . Convers\u00f5es de 4 para 8 bytes muitas vezes s\u00e3o feitas com a instru\u00e7\u00e3o cltq , que extende (com sinal) %eax para %rax . Uma boa refer\u00eancia \u00e9 este site da Oracle . Vamos agora praticar. Nos 3 exerc\u00edcios abaixo temos fun\u00e7\u00f5es que avaliam uma (ou mais) express\u00f5es booleanas entre seus argumentos e retornam o resultado. Arquivo ex1 \u00b6 Reconstrua a fun\u00e7\u00e3o ex1 a partir do c\u00f3digo assembly abaixo. 0000000000000000 < ex1 > : 0: 83 ff 0 a cmp $0xa , %edi 3: 0 f 9 f c0 setg %al 6: 0 f b6 c0 movzbl %al , %eax 9: c3 retq Question Qual \u00e9 o tamanho do argumento de ex1 ? Ele \u00e9 signed ou unsigned ? Example Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o com o professor ou com algum colega que j\u00e1 validou sua solu\u00e7\u00e3o. Arquivo ex2 \u00b6 Reconstrua a fun\u00e7\u00e3o ex2 a partir do c\u00f3digo assembly abaixo 0000000000000000 < ex2 > : 0: 48 39 f7 cmp %rsi , %rdi 3: 0 f 96 c0 setbe %al 6: 0 f b6 c0 movzbl %al , %eax 9: c3 retq Question Qual \u00e9 o tamanho dos argumentos de ex2 ? Ele \u00e9 signed ou unsigned ? Example Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o com o professor ou com algum colega que j\u00e1 validou sua solu\u00e7\u00e3o. Arquivo ex3 \u00b6 Reconstrua a fun\u00e7\u00e3o ex3 a partir do c\u00f3digo assembly abaixo. 0000000000000000 < ex3 > : 0: 48 39 f7 cmp %rsi , %rdi 3: 0 f 9 f c0 setg %al 6: 48 85 f6 test %rsi , %rsi 9: 0 f 9 f c2 setg %dl c: 21 d0 and %edx , %eax e: 0 f b6 c0 movzbl %al , %eax 11: c3 retq Question Qual \u00e9 o tamanho dos argumentos de ex3 ? Ele \u00e9 signed ou unsigned ? Example Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o com o professor ou com algum colega. Condicionais \u00b6 Vimos na segunda parte expositiva que Assembly possui apenas instru\u00e7\u00f5es de pulos condicionais ( j* onde * representa uma compara\u00e7\u00e3o usando as mesmas abrevia\u00e7\u00f5es de set* ) e n\u00e3o condicionais ( jmp ). Vimos tamb\u00e9m que a combina\u00e7\u00e3o destas instru\u00e7\u00f5es com cmp e test \u00e9 equivalente \u00e0 dupla de comandos if ( cond - booleana ) { goto label ; } A tabela abaixo mostra as opera\u00e7\u00f5es de saltos condicionais. {width=400px} Exemplo guiado \u00b6 Vamos agora fazer um exemplo guiado. Analisaremos o seguinte c\u00f3digo: 0000000000000000 < eh_par >: 0 : 40 f6 c7 01 test $ 0x1 , % dil 4 : 74 06 je c < eh_par + 0xc > 6 : b8 00 00 00 00 mov $ 0x0 , % eax b : c3 retq c : b8 01 00 00 00 mov $ 0x1 , % eax 11 : c3 retq Pares de instru\u00e7\u00f5es test-j* ou cmp-j* s\u00e3o comumente usadas para representar a constru\u00e7\u00e3o if-goto . O nome da fun\u00e7\u00e3o d\u00e1 uma dica de seu valor de retorno. Voc\u00ea consegue entender o porqu\u00ea test $1, %dil faz isto? \\vspace{5em} Vamos agora traduzir a fun\u00e7\u00e3o eh_par para gotoC . As linhas 0-4 s\u00e3o transformadas em um par if-goto . O restante s\u00e3o instru\u00e7\u00f5es que j\u00e1 conhecemos. int eh_par ( long a ) { if ( a & 1 == 0 ) goto if1 ; return 0 ; if1 : return 1 ; } Tiramos ent\u00e3o o goto e levando em conta sua resposta no item anterior, ficamos com o seguinte c\u00f3digo. Note que precisamos negar a compara\u00e7\u00e3o feita no c\u00f3digo anterior! int eh_par ( long a ) { if ( a % 2 != 0 ) { return 0 ; } return 1 ; } Podemos observar duas coisas no c\u00f3digo assembly gerado: O c\u00f3digo que estava dentro do if foi colocado ap\u00f3s o c\u00f3digo que estava fora do if! O compilador pode mudar a ordem dos nossos blocos de c\u00f3digo se for conveniente (para ele, n\u00e3o para n\u00f3s). A constru\u00e7\u00e3o test-j* e cmp-j* pode ser mapeada diretamente para if-goto . Por\u00e9m, reconstruir um c\u00f3digo leg\u00edvel requer, muitas vezes, mudar c\u00f3digo de lugar. Vamos agora praticar com alguns exerc\u00edcios simples: Arquivo ex4 \u00b6 Veja o c\u00f3digo abaixo 0000000000000000 < fun4 > : 0: 48 85 ff test %rdi , %rdi 3: 7 e 0 a jle f < fun4 + 0xf > 5: b8 02 00 00 00 mov $0x2 , %eax a: 48 0 f af c6 imul %rsi , %rax e: c3 retq f: b8 01 00 00 00 mov $0x1 , %eax 14: eb f4 jmp a < fun4 + 0xa > Question Qual express\u00e3o booleana \u00e9 testada? Example Fa\u00e7a a tradu\u00e7\u00e3o desta fun\u00e7\u00e3o para gotoC . Example Transforme o c\u00f3digo acima em C leg\u00edvel. Arquivo ex5 \u00b6 Veja o c\u00f3digo da fun\u00e7\u00e3o abaixo. 0000000000000000 < ex5 > : 0: 48 85 ff test %rdi , %rdi 3: 0 f 9 f c2 setg %dl 6: 48 85 f6 test %rsi , %rsi 9: 0 f 9 e c0 setle %al c: 84 c2 test %al , %dl e: 75 05 jne 15 < ex5 + 0x15 > 10: 48 8 d 46 fe lea - 0x2 ( %rsi ), %rax 14: c3 retq 15: 48 8 d 47 05 lea 0x5 ( %rdi ), %rax 19: c3 retq Question Qual s\u00e3o as express\u00f5es booleanas testadas? (Dica: s\u00e3o 3, assim como no exerc\u00edcio 3). Example Fa\u00e7a uma tradu\u00e7\u00e3o para gotoC . Example Transforme seu c\u00f3digo acima para C leg\u00edvel. Exemplo guiado II \u00b6 Veremos agora um exemplo if/else : int exemplo2 ( long a , long b ) { long c ; if ( a >= 5 && b <= 0 ) { c = a + b ; } else { c = a - b ; } return c ; } Seu assembly correspondente, quando compilado com gcc -Og -c \u00e9 0000000000000000 < exemplo2 > : 0: 48 83 ff 04 cmp $0x4 , %rdi 4: 0 f 9 f c2 setg %dl 7: 48 85 f6 test %rsi , %rsi a: 0 f 9 e c0 setle %al d: 84 c2 test %al , %dl f: 75 07 jne 18 < exemplo2 + 0x18 > 11: 48 89 f8 mov %rdi , %rax 14: 48 29 f0 sub %rsi , %rax 17: c3 retq 18: 48 8 d 04 37 lea ( %rdi , %rsi , 1 ), %rax 1 c: c3 retq Primeiramente, notamos que a fun\u00e7\u00e3o recebe dois argumentos (pois s\u00f3 utiliza %rdi e %rsi ) e que ambos s\u00e3o tratados como long . Vamos ent\u00e3o \u00e0s express\u00f5es booleanas. Existem tr\u00eas express\u00f5es boolenas: cmp - setg (linhas 0-4 ) compara %rdi com 4 e seta %dl=1 se %rdi>4 (**g**reater) test-setle (linhas 7-a ) compara %rsi com 0 e seta %al=1 se %rsi<=0 (**l**ess or **e**qual). test (linha d ) entre %dl e %al . O resultado n\u00e3o \u00e9 armazenado. Logo abaixo do \u00faltimo test temos um jne (linha f ), acr\u00f4nimo para **j**ump if **n**ot **e**qual. Ou seja, fazemos o jump se %dl && %al for verdadeiro. Logo em seguida temos instru\u00e7\u00f5es aritm\u00e9ticas, que j\u00e1 estudamos nos \u00faltimos handouts. Assim como vimos nos slides, vamos converter este c\u00f3digo para gotoC primeiro. Assim como fizemos nos exerc\u00edcios de 1 a 3, criaremos uma vari\u00e1vel para as express\u00f5es booleanas 1 e 2 e substituiremos as instru\u00e7\u00f5es test-jne (linhas d-f ) por um par if-goto . Veja abaixo: int exemplo2 ( long a , long b ) { long retval ; int expr1 = a > 4 ; int expr2 = b <= 0 ; if ( expr1 && expr2 ) goto if1 ; retval = a ; retval -= b ; return retval ; if1 : retval = a + b ; return retval ; } \\pagebreak Podemos ent\u00e3o melhorar tornar este c\u00f3digo mais leg\u00edvel, resultando no seguinte: int exemplo2 ( long a , long b ) { if ( a > 4 && b <= 0 ) { return a + b ; } else { return a - b ; } } Duas coisas importantes podem ser vistas neste c\u00f3digo As compara\u00e7\u00f5es n\u00e3o s\u00e3o exatamente iguais ( a>4 e a>=5 ), mas s\u00e3o equivalentes. O compilador pode trocar a ordem do if/else e colocar o else primeiro no Assembly gerado. Isto n\u00e3o altera o resultado da fun\u00e7\u00e3o, mas pode ser confuso de in\u00edcio. Arquivo ex6 \u00b6 O exerc\u00edcio abaixo usa if-else . 0000000000000000 < ex6 > : 0: 48 39 f7 cmp %rsi , %rdi 3: 7 e 03 jle 8 < ex6 + 0x8 > 5: 48 89 fe mov %rdi , %rsi 8: 48 85 ff test %rdi , %rdi b: 7 e 03 jle 10 < ex6 + 0x10 > d: 48 f7 de neg %rsi 10: 89 f0 mov %esi , %eax 12: c3 retq Example Traduza o c\u00f3digo acima para gotoC . Example Fa\u00e7a uma vers\u00e3o leg\u00edvel do c\u00f3digo acima.","title":"06 - Condicionais"},{"location":"aulas/06-condicionais/#06-condicionais","text":"","title":"06 - Condicionais"},{"location":"aulas/06-condicionais/#expressoes-booleanas","text":"Vimos na expositiva que toda opera\u00e7\u00e3o aritm\u00e9tica preenche as flags CF , ZF , SF e OF e que podemos usar estas flags para montar express\u00f5es booleanas com as instru\u00e7\u00f5es set* . A tabela abaixo mostra as instru\u00e7\u00f5es respons\u00e1veis cada tipo de express\u00e3o booleana. Tamb\u00e9m vimos que podemos preencher estas flags usando as instru\u00e7\u00f5es cmp e test , que executam opera\u00e7\u00f5es aritm\u00e9ticas (subtra\u00e7\u00e3o e E bit a bit) mas n\u00e3o guardam o resultado. Vamos analisar o c\u00f3digo assembly da seguinte fun\u00e7\u00e3o: int igual ( int a , int b ) { return a == b ; } 0000000000000000 < igual > : 0: 39 f7 cmp %esi , %edi 2: 0 f 94 c0 sete %al 5: 0 f b6 c0 movzbl %al , %eax 8: c3 retq A compara\u00e7\u00e3o a == b \u00e9 feita primeiro executando cmp entre os argumentos %edi e %esi e depois usando sete ( set equal ) para atribuir 1 %al se %edi == %esi e 0 caso contr\u00e1rio. Por fim, temos a instru\u00e7\u00e3o movzbl , que faz o cast de char ( %al ) para int ( %eax ). Lembre-se que as instru\u00e7\u00f5es set* s\u00f3 modificam os primeiros 8 bits de %eax . O restante continua com o valor antigo. Usamos movzbl para extender o n\u00famero em %al para ocupar todo %eax . Tip As instru\u00e7\u00f5es de convers\u00e3o de tipos s\u00e3o bastante frequentes em Assembly, principalmente para expandir valores colocados em registradores menores para registradores maiores. Elas seguem a seguinte regra: MOVtsd t pode ser z para tipos unsigned (completando com **z**eros) e s para tipos signed (completando com o bit de **s**inal). s \u00e9 o tamanho do registrador fonte seguindo a nota\u00e7\u00e3o b para 1 byte, w para 2 bytes, l para 4 bytes e q para 8 bytes. d \u00e9 o tamanho do registrador destino, seguinto a mesma nota\u00e7\u00e3o acima. Por exemplo, a instru\u00e7\u00e3o MOVZWQ converte um unsigned short para um unsigned long . Convers\u00f5es de 4 para 8 bytes muitas vezes s\u00e3o feitas com a instru\u00e7\u00e3o cltq , que extende (com sinal) %eax para %rax . Uma boa refer\u00eancia \u00e9 este site da Oracle . Vamos agora praticar. Nos 3 exerc\u00edcios abaixo temos fun\u00e7\u00f5es que avaliam uma (ou mais) express\u00f5es booleanas entre seus argumentos e retornam o resultado.","title":"Express\u00f5es booleanas"},{"location":"aulas/06-condicionais/#arquivo-ex1","text":"Reconstrua a fun\u00e7\u00e3o ex1 a partir do c\u00f3digo assembly abaixo. 0000000000000000 < ex1 > : 0: 83 ff 0 a cmp $0xa , %edi 3: 0 f 9 f c0 setg %al 6: 0 f b6 c0 movzbl %al , %eax 9: c3 retq Question Qual \u00e9 o tamanho do argumento de ex1 ? Ele \u00e9 signed ou unsigned ? Example Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o com o professor ou com algum colega que j\u00e1 validou sua solu\u00e7\u00e3o.","title":"Arquivo ex1"},{"location":"aulas/06-condicionais/#arquivo-ex2","text":"Reconstrua a fun\u00e7\u00e3o ex2 a partir do c\u00f3digo assembly abaixo 0000000000000000 < ex2 > : 0: 48 39 f7 cmp %rsi , %rdi 3: 0 f 96 c0 setbe %al 6: 0 f b6 c0 movzbl %al , %eax 9: c3 retq Question Qual \u00e9 o tamanho dos argumentos de ex2 ? Ele \u00e9 signed ou unsigned ? Example Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o com o professor ou com algum colega que j\u00e1 validou sua solu\u00e7\u00e3o.","title":"Arquivo ex2"},{"location":"aulas/06-condicionais/#arquivo-ex3","text":"Reconstrua a fun\u00e7\u00e3o ex3 a partir do c\u00f3digo assembly abaixo. 0000000000000000 < ex3 > : 0: 48 39 f7 cmp %rsi , %rdi 3: 0 f 9 f c0 setg %al 6: 48 85 f6 test %rsi , %rsi 9: 0 f 9 f c2 setg %dl c: 21 d0 and %edx , %eax e: 0 f b6 c0 movzbl %al , %eax 11: c3 retq Question Qual \u00e9 o tamanho dos argumentos de ex3 ? Ele \u00e9 signed ou unsigned ? Example Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o com o professor ou com algum colega.","title":"Arquivo ex3"},{"location":"aulas/06-condicionais/#condicionais","text":"Vimos na segunda parte expositiva que Assembly possui apenas instru\u00e7\u00f5es de pulos condicionais ( j* onde * representa uma compara\u00e7\u00e3o usando as mesmas abrevia\u00e7\u00f5es de set* ) e n\u00e3o condicionais ( jmp ). Vimos tamb\u00e9m que a combina\u00e7\u00e3o destas instru\u00e7\u00f5es com cmp e test \u00e9 equivalente \u00e0 dupla de comandos if ( cond - booleana ) { goto label ; } A tabela abaixo mostra as opera\u00e7\u00f5es de saltos condicionais. {width=400px}","title":"Condicionais"},{"location":"aulas/06-condicionais/#exemplo-guiado","text":"Vamos agora fazer um exemplo guiado. Analisaremos o seguinte c\u00f3digo: 0000000000000000 < eh_par >: 0 : 40 f6 c7 01 test $ 0x1 , % dil 4 : 74 06 je c < eh_par + 0xc > 6 : b8 00 00 00 00 mov $ 0x0 , % eax b : c3 retq c : b8 01 00 00 00 mov $ 0x1 , % eax 11 : c3 retq Pares de instru\u00e7\u00f5es test-j* ou cmp-j* s\u00e3o comumente usadas para representar a constru\u00e7\u00e3o if-goto . O nome da fun\u00e7\u00e3o d\u00e1 uma dica de seu valor de retorno. Voc\u00ea consegue entender o porqu\u00ea test $1, %dil faz isto? \\vspace{5em} Vamos agora traduzir a fun\u00e7\u00e3o eh_par para gotoC . As linhas 0-4 s\u00e3o transformadas em um par if-goto . O restante s\u00e3o instru\u00e7\u00f5es que j\u00e1 conhecemos. int eh_par ( long a ) { if ( a & 1 == 0 ) goto if1 ; return 0 ; if1 : return 1 ; } Tiramos ent\u00e3o o goto e levando em conta sua resposta no item anterior, ficamos com o seguinte c\u00f3digo. Note que precisamos negar a compara\u00e7\u00e3o feita no c\u00f3digo anterior! int eh_par ( long a ) { if ( a % 2 != 0 ) { return 0 ; } return 1 ; } Podemos observar duas coisas no c\u00f3digo assembly gerado: O c\u00f3digo que estava dentro do if foi colocado ap\u00f3s o c\u00f3digo que estava fora do if! O compilador pode mudar a ordem dos nossos blocos de c\u00f3digo se for conveniente (para ele, n\u00e3o para n\u00f3s). A constru\u00e7\u00e3o test-j* e cmp-j* pode ser mapeada diretamente para if-goto . Por\u00e9m, reconstruir um c\u00f3digo leg\u00edvel requer, muitas vezes, mudar c\u00f3digo de lugar. Vamos agora praticar com alguns exerc\u00edcios simples:","title":"Exemplo guiado"},{"location":"aulas/06-condicionais/#arquivo-ex4","text":"Veja o c\u00f3digo abaixo 0000000000000000 < fun4 > : 0: 48 85 ff test %rdi , %rdi 3: 7 e 0 a jle f < fun4 + 0xf > 5: b8 02 00 00 00 mov $0x2 , %eax a: 48 0 f af c6 imul %rsi , %rax e: c3 retq f: b8 01 00 00 00 mov $0x1 , %eax 14: eb f4 jmp a < fun4 + 0xa > Question Qual express\u00e3o booleana \u00e9 testada? Example Fa\u00e7a a tradu\u00e7\u00e3o desta fun\u00e7\u00e3o para gotoC . Example Transforme o c\u00f3digo acima em C leg\u00edvel.","title":"Arquivo ex4"},{"location":"aulas/06-condicionais/#arquivo-ex5","text":"Veja o c\u00f3digo da fun\u00e7\u00e3o abaixo. 0000000000000000 < ex5 > : 0: 48 85 ff test %rdi , %rdi 3: 0 f 9 f c2 setg %dl 6: 48 85 f6 test %rsi , %rsi 9: 0 f 9 e c0 setle %al c: 84 c2 test %al , %dl e: 75 05 jne 15 < ex5 + 0x15 > 10: 48 8 d 46 fe lea - 0x2 ( %rsi ), %rax 14: c3 retq 15: 48 8 d 47 05 lea 0x5 ( %rdi ), %rax 19: c3 retq Question Qual s\u00e3o as express\u00f5es booleanas testadas? (Dica: s\u00e3o 3, assim como no exerc\u00edcio 3). Example Fa\u00e7a uma tradu\u00e7\u00e3o para gotoC . Example Transforme seu c\u00f3digo acima para C leg\u00edvel.","title":"Arquivo ex5"},{"location":"aulas/06-condicionais/#exemplo-guiado-ii","text":"Veremos agora um exemplo if/else : int exemplo2 ( long a , long b ) { long c ; if ( a >= 5 && b <= 0 ) { c = a + b ; } else { c = a - b ; } return c ; } Seu assembly correspondente, quando compilado com gcc -Og -c \u00e9 0000000000000000 < exemplo2 > : 0: 48 83 ff 04 cmp $0x4 , %rdi 4: 0 f 9 f c2 setg %dl 7: 48 85 f6 test %rsi , %rsi a: 0 f 9 e c0 setle %al d: 84 c2 test %al , %dl f: 75 07 jne 18 < exemplo2 + 0x18 > 11: 48 89 f8 mov %rdi , %rax 14: 48 29 f0 sub %rsi , %rax 17: c3 retq 18: 48 8 d 04 37 lea ( %rdi , %rsi , 1 ), %rax 1 c: c3 retq Primeiramente, notamos que a fun\u00e7\u00e3o recebe dois argumentos (pois s\u00f3 utiliza %rdi e %rsi ) e que ambos s\u00e3o tratados como long . Vamos ent\u00e3o \u00e0s express\u00f5es booleanas. Existem tr\u00eas express\u00f5es boolenas: cmp - setg (linhas 0-4 ) compara %rdi com 4 e seta %dl=1 se %rdi>4 (**g**reater) test-setle (linhas 7-a ) compara %rsi com 0 e seta %al=1 se %rsi<=0 (**l**ess or **e**qual). test (linha d ) entre %dl e %al . O resultado n\u00e3o \u00e9 armazenado. Logo abaixo do \u00faltimo test temos um jne (linha f ), acr\u00f4nimo para **j**ump if **n**ot **e**qual. Ou seja, fazemos o jump se %dl && %al for verdadeiro. Logo em seguida temos instru\u00e7\u00f5es aritm\u00e9ticas, que j\u00e1 estudamos nos \u00faltimos handouts. Assim como vimos nos slides, vamos converter este c\u00f3digo para gotoC primeiro. Assim como fizemos nos exerc\u00edcios de 1 a 3, criaremos uma vari\u00e1vel para as express\u00f5es booleanas 1 e 2 e substituiremos as instru\u00e7\u00f5es test-jne (linhas d-f ) por um par if-goto . Veja abaixo: int exemplo2 ( long a , long b ) { long retval ; int expr1 = a > 4 ; int expr2 = b <= 0 ; if ( expr1 && expr2 ) goto if1 ; retval = a ; retval -= b ; return retval ; if1 : retval = a + b ; return retval ; } \\pagebreak Podemos ent\u00e3o melhorar tornar este c\u00f3digo mais leg\u00edvel, resultando no seguinte: int exemplo2 ( long a , long b ) { if ( a > 4 && b <= 0 ) { return a + b ; } else { return a - b ; } } Duas coisas importantes podem ser vistas neste c\u00f3digo As compara\u00e7\u00f5es n\u00e3o s\u00e3o exatamente iguais ( a>4 e a>=5 ), mas s\u00e3o equivalentes. O compilador pode trocar a ordem do if/else e colocar o else primeiro no Assembly gerado. Isto n\u00e3o altera o resultado da fun\u00e7\u00e3o, mas pode ser confuso de in\u00edcio.","title":"Exemplo guiado II"},{"location":"aulas/06-condicionais/#arquivo-ex6","text":"O exerc\u00edcio abaixo usa if-else . 0000000000000000 < ex6 > : 0: 48 39 f7 cmp %rsi , %rdi 3: 7 e 03 jle 8 < ex6 + 0x8 > 5: 48 89 fe mov %rdi , %rsi 8: 48 85 ff test %rdi , %rdi b: 7 e 03 jle 10 < ex6 + 0x10 > d: 48 f7 de neg %rsi 10: 89 f0 mov %esi , %eax 12: c3 retq Example Traduza o c\u00f3digo acima para gotoC . Example Fa\u00e7a uma vers\u00e3o leg\u00edvel do c\u00f3digo acima.","title":"Arquivo ex6"},{"location":"aulas/07-loops/","text":"07 - Loops \u00b6 Arquivo ex1.o \u00b6 Com base no c\u00f3digo assembly abaixo(arquivo ex1.o ) e responda os itens. Dump of assembler code for function soma_2n : 0 x066a <+ 0 > : mov $0x1 , %eax 0 x066f <+ 5 > : jmp 0x676 < soma_2n + 12 > 0 x0671 <+ 7 > : shr %edi 0 x0673 <+ 9 > : add $0x1 , %eax 0 x0676 <+ 12 > : cmp $0x1 , %edi 0 x0679 <+ 15 > : ja 0x671 < soma_2n + 7 > 0 x067b <+ 17 > : repz retq Question Localize no c\u00f3digo acima as instru\u00e7\u00f5es de saltos ( jmp ou condicionais j* ). Desenhe setas indicando para qual linha do c\u00f3digo elas pulam. Question Analise o fluxo de saltos do seu c\u00f3digo. Existe um loop? Entre quais linhas? Question Comece fazendo uma vers\u00e3o C usando somente if-goto Question Transforme a constru\u00e7\u00e3o que voc\u00ea fez acima em um c\u00f3digo usando while . Exerc\u00edcios para entrega \u00b6 Vamos agora exercitar o que vimos na aula expositiva. Os exerc\u00edcios abaixo est\u00e3o no reposit\u00f3rio de atividades e as perguntas no handout tem o objetivo de ajudar a compreender c\u00f3digo cada vez mais complexos. Arquivo ex2 \u00b6 Leia o c\u00f3digo assembly abaixo e responda. Dump of assembler code for function soma_n : 0 x066a <+ 0 > : mov $0x0 , %edx 0 x066f <+ 5 > : mov $0x0 , %eax 0 x0674 <+ 10 > : jmp 0x67f < soma_n + 21 > 0 x0676 <+ 12 > : movslq %edx , %rcx 0 x0679 <+ 15 > : add %rcx , %rax 0 x067c <+ 18 > : add $0x1 , %edx 0 x067f <+ 21 > : cmp %edi , %edx 0 x0681 <+ 23 > : jl 0x676 < soma_n + 12 > 0 x0683 <+ 25 > : repz retq Question Desenhe as flechas indicando o destino de cada instru\u00e7\u00e3o de pulo ( jmp ou j* ). Question Escreva abaixo o cabe\u00e7alho da fun\u00e7\u00e3o soma_n . Dica : procure por registradores que s\u00e3o lidos antes de serem escritos. Question Fa\u00e7a a tradu\u00e7\u00e3o do c\u00f3digo acima para C usando somente if-goto Question Converta o c\u00f3digo acima para uma vers\u00e3o leg\u00edvel em C . Arquivo ex3 \u00b6 Dump of assembler code for function ex5 : 0 x1139 <+ 0 > : mov $0x0 , %ecx 0 x113e <+ 5 > : mov $0x0 , %r8d 0 x1144 <+ 11 > : jmp 0x114a < ex4 + 17 > 0 x1146 <+ 13 > : add $0x1 , %rcx 0 x114a <+ 17 > : cmp %rdi , %rcx 0 x114d <+ 20 > : jge 0x1161 < ex4 + 40 > 0 x114f <+ 22 > : mov %rcx , %rax 0 x1152 <+ 25 > : cqto 0 x1154 <+ 27 > : idiv %rsi 0 x1157 <+ 30 > : test %rdx , %rdx 0 x115a <+ 33 > : jne 0x1146 < ex4 + 13 > 0 x115c <+ 35 > : add %rcx , %r8 0 x115f <+ 38 > : jmp 0x1146 < ex4 + 13 > 0 x1161 <+ 40 > : mov %r8 , %rax 0 x1164 <+ 43 > : retq Question Quantos argumentos a fun\u00e7\u00e3o acima recebe? Quais seus tipos? Dica : n\u00e3o se esque\u00e7a de buscar por registradores que s\u00e3o lidos antes de serem escritos. Question A fun\u00e7\u00e3o retorna algum valor? Se sim, qual seu tipo? Question A fun\u00e7\u00e3o acima combina loops e condicionais. Desenhe setas para onde as instru\u00e7\u00f5es de jmp apontam. Question Com base no exerc\u00edcio anterior, entre quais linhas o loop ocorre? E a condicional? Question O loop acima tem uma vari\u00e1vel contadora. Ela est\u00e1 em qual registrador? Qual seu tipo? Question Revise o funcionamento da instru\u00e7\u00e3o idiv . Em qual registrador \u00e9 armazenado o resultado da divis\u00e3o? E o resto? Question Qual a condi\u00e7\u00e3o testada na condicional? Question Escreva uma vers\u00e3o do c\u00f3digo acima usando somente if-goto . Question Escreva uma vers\u00e3o leg\u00edvel do c\u00f3digo acima.","title":"07 - Loops"},{"location":"aulas/07-loops/#07-loops","text":"","title":"07 - Loops"},{"location":"aulas/07-loops/#arquivo-ex1o","text":"Com base no c\u00f3digo assembly abaixo(arquivo ex1.o ) e responda os itens. Dump of assembler code for function soma_2n : 0 x066a <+ 0 > : mov $0x1 , %eax 0 x066f <+ 5 > : jmp 0x676 < soma_2n + 12 > 0 x0671 <+ 7 > : shr %edi 0 x0673 <+ 9 > : add $0x1 , %eax 0 x0676 <+ 12 > : cmp $0x1 , %edi 0 x0679 <+ 15 > : ja 0x671 < soma_2n + 7 > 0 x067b <+ 17 > : repz retq Question Localize no c\u00f3digo acima as instru\u00e7\u00f5es de saltos ( jmp ou condicionais j* ). Desenhe setas indicando para qual linha do c\u00f3digo elas pulam. Question Analise o fluxo de saltos do seu c\u00f3digo. Existe um loop? Entre quais linhas? Question Comece fazendo uma vers\u00e3o C usando somente if-goto Question Transforme a constru\u00e7\u00e3o que voc\u00ea fez acima em um c\u00f3digo usando while .","title":"Arquivo ex1.o"},{"location":"aulas/07-loops/#exercicios-para-entrega","text":"Vamos agora exercitar o que vimos na aula expositiva. Os exerc\u00edcios abaixo est\u00e3o no reposit\u00f3rio de atividades e as perguntas no handout tem o objetivo de ajudar a compreender c\u00f3digo cada vez mais complexos.","title":"Exerc\u00edcios para entrega"},{"location":"aulas/07-loops/#arquivo-ex2","text":"Leia o c\u00f3digo assembly abaixo e responda. Dump of assembler code for function soma_n : 0 x066a <+ 0 > : mov $0x0 , %edx 0 x066f <+ 5 > : mov $0x0 , %eax 0 x0674 <+ 10 > : jmp 0x67f < soma_n + 21 > 0 x0676 <+ 12 > : movslq %edx , %rcx 0 x0679 <+ 15 > : add %rcx , %rax 0 x067c <+ 18 > : add $0x1 , %edx 0 x067f <+ 21 > : cmp %edi , %edx 0 x0681 <+ 23 > : jl 0x676 < soma_n + 12 > 0 x0683 <+ 25 > : repz retq Question Desenhe as flechas indicando o destino de cada instru\u00e7\u00e3o de pulo ( jmp ou j* ). Question Escreva abaixo o cabe\u00e7alho da fun\u00e7\u00e3o soma_n . Dica : procure por registradores que s\u00e3o lidos antes de serem escritos. Question Fa\u00e7a a tradu\u00e7\u00e3o do c\u00f3digo acima para C usando somente if-goto Question Converta o c\u00f3digo acima para uma vers\u00e3o leg\u00edvel em C .","title":"Arquivo ex2"},{"location":"aulas/07-loops/#arquivo-ex3","text":"Dump of assembler code for function ex5 : 0 x1139 <+ 0 > : mov $0x0 , %ecx 0 x113e <+ 5 > : mov $0x0 , %r8d 0 x1144 <+ 11 > : jmp 0x114a < ex4 + 17 > 0 x1146 <+ 13 > : add $0x1 , %rcx 0 x114a <+ 17 > : cmp %rdi , %rcx 0 x114d <+ 20 > : jge 0x1161 < ex4 + 40 > 0 x114f <+ 22 > : mov %rcx , %rax 0 x1152 <+ 25 > : cqto 0 x1154 <+ 27 > : idiv %rsi 0 x1157 <+ 30 > : test %rdx , %rdx 0 x115a <+ 33 > : jne 0x1146 < ex4 + 13 > 0 x115c <+ 35 > : add %rcx , %r8 0 x115f <+ 38 > : jmp 0x1146 < ex4 + 13 > 0 x1161 <+ 40 > : mov %r8 , %rax 0 x1164 <+ 43 > : retq Question Quantos argumentos a fun\u00e7\u00e3o acima recebe? Quais seus tipos? Dica : n\u00e3o se esque\u00e7a de buscar por registradores que s\u00e3o lidos antes de serem escritos. Question A fun\u00e7\u00e3o retorna algum valor? Se sim, qual seu tipo? Question A fun\u00e7\u00e3o acima combina loops e condicionais. Desenhe setas para onde as instru\u00e7\u00f5es de jmp apontam. Question Com base no exerc\u00edcio anterior, entre quais linhas o loop ocorre? E a condicional? Question O loop acima tem uma vari\u00e1vel contadora. Ela est\u00e1 em qual registrador? Qual seu tipo? Question Revise o funcionamento da instru\u00e7\u00e3o idiv . Em qual registrador \u00e9 armazenado o resultado da divis\u00e3o? E o resto? Question Qual a condi\u00e7\u00e3o testada na condicional? Question Escreva uma vers\u00e3o do c\u00f3digo acima usando somente if-goto . Question Escreva uma vers\u00e3o leg\u00edvel do c\u00f3digo acima.","title":"Arquivo ex3"},{"location":"aulas/08-variaveis-locais/","text":"08 - Vari\u00e1veis locais \u00b6 Como visto na expositiva, vari\u00e1veis locais s\u00e3o armazenadas na pilha. O topo da pilha \u00e9 armazenado em %rsp e ela cresce para baixo, ou seja, ao empilhar um dado o valor de %rsp diminui e ao desempilhar seu valor aumenta. O compilador faz todo o poss\u00edvel para usar somente os registradores, por\u00e9m em alguns casos \u00e9 necess\u00e1rio guardar a vari\u00e1vel na mem\u00f3ria. Isso ocorre, em geral, quando usamos & para computar o endere\u00e7o de uma vari\u00e1vel. O exemplo mais comum nos c\u00f3digos que j\u00e1 escrevemos \u00e9 na leitura de valores usando scanf . Exemplo guiado \u00b6 Fun\u00e7\u00f5es que guardam vari\u00e1veis na pilha seguem um padr\u00e3o facilmente identific\u00e1vel. Primeiro elas subtraem um valor da pilha ( 0x10 no exemplo abaixo) correspondente ao tamanho total de todas as vari\u00e1veis usadas. Depois temos v\u00e1rias instru\u00e7\u00f5es usando endere\u00e7os relativos a %rsp e por fim devolvemos o espa\u00e7o usado somando 0x10 de volta a %rsp . sub $0x10, %rsp . . . // c\u00f3digo da fun\u00e7\u00e3o aqui! movl 0x8(%rsp),%eax mov %eax,%edx addl 0xc(%rsp),%edx . . . // fun\u00e7\u00e3o continua add $0x10, %rsp ret No exemplo acima, temos duas vari\u00e1veis locais: 0x8(%rsp) e 0xc(rsp) . Cada uma \u00e9 identificada no c\u00f3digo Assembly pelo endere\u00e7o em que est\u00e1 posicionada na pilha. Logo, todo deslocamento em rela\u00e7\u00e3o a %rsp indica um acesso a vari\u00e1vel local , sendo que pode ser um acesso de leitura e escrita (usando MOV , por exemplo) ou da opera\u00e7\u00e3o endere\u00e7o de & (usando LEA ). Conseguimos identificar que seus tamanhos s\u00e3o int por duas raz\u00f5es: elas aparecem em instru\u00e7\u00f5es junto com registradores de 4 bytes ( %eax e %edx ) as instru\u00e7\u00f5es movl e addl tem o sufixo l , que indica que os dados tratados tem tamanho 4 bytes. Os sufixos suportados s\u00e3o: b - 1 byte w - 2 bytes l - 4 bytes q - 8 bytes Qualquer raz\u00e3o acima \u00e9 suficiente para identificar os tipos das vari\u00e1veis locais. Importante Novamente, nem toda instru\u00e7\u00e3o em Assembly pode ser representada em C . As instru\u00e7\u00f5es sub 0x10, %rsp e add 0x10, %rsp representam a cria\u00e7\u00e3o de vari\u00e1veis locais na pilha e n\u00e3o tem equivalente em C . Simplesmente ignoramos elas e usamos as vari\u00e1veis locais no c\u00f3digo. Revis\u00e3o de vari\u00e1veis globais e strings constantes \u00b6 Antes de iniciar o pr\u00f3ximo exerc\u00edcio vamos revisar como vari\u00e1veis locais, globais e strings constantes s\u00e3o acessadas em c\u00f3digo assembly. A imagem abaixo exemplifica os tr\u00eas casos: Vari\u00e1veis locais : s\u00e3o acessadas com lea (para & - endere\u00e7o de) ou mov (para leituras e escritas) relativos a %rsp Globais e strings constantes : s\u00e3o acessadas usando a nota\u00e7\u00e3o 0xYY(%rip) , sendo que o valor 0xYY muda a cada acesso. No caso das strings, o acesso a estes endere\u00e7os \u00e9 somente leitura. O endere\u00e7amento relativo a %rip leva em conta a posi\u00e7\u00e3o relativa entre a instru\u00e7\u00e3o atual e o endere\u00e7o de mem\u00f3ria do dado. Na imagem acima est\u00e3o destacadas duas instru\u00e7\u00f5es lea que acessam o mesmo dado. Como o %rip (ponteiro para a pr\u00f3xima instru\u00e7\u00e3o) \u00e9 diferente precisamos de deslocamentos diferentes para acessar o mesmo dado. Dica : o gdb coloca o endere\u00e7o calculado ao lado das instru\u00e7\u00f5es deste tipo. Question \u00c9 poss\u00edvel que o lea abaixo seja aritm\u00e9tico? Por que? lea 0x8 ( %rsp ), %rdx Arquivo ex2 \u00b6 O c\u00f3digo abaixo ( ex2 ) utiliza vari\u00e1veis locais. Dump of assembler code for function func1 : 0 x05fe <+ 0 > : sub $0x10 , %rsp 0 x0602 <+ 4 > : movl $0xa , 0xc ( %rsp ) 0 x060a <+ 12 > : movl $0xb , 0x8 ( %rsp ) 0 x0612 <+ 20 > : lea 0xc ( %rsp ), %rdi 0 x0617 <+ 25 > : callq 0x5fa < func2 > 0 x061c <+ 30 > : addl $0x1 , 0x8 ( %rsp ) 0 x0621 <+ 35 > : lea 0x8 ( %rsp ), %rdi 0 x0626 <+ 40 > : callq 0x5fa < func2 > 0 x062b <+ 45 > : add $0x10 , %rsp 0 x062f <+ 49 > : retq Vamos come\u00e7ar analisando as tr\u00eas primeiras linhas do programa. Question Quanto espa\u00e7o \u00e9 reservado na pilha? Quantas vari\u00e1veis s\u00e3o inicializadas e quais seus tamanhos e conte\u00fados? D\u00ea um nome para cada uma delas. Question Identifique onde as vari\u00e1veis locais encontradas s\u00e3o usadas. Question Os lea das linhas +20 e +35 podem ser aritm\u00e9ticos? Que opera\u00e7\u00e3o eles representam? Question Com base em sua resposta acima, traduza as chamadas de fun\u00e7\u00e3o que ocorrem nas linhas +25 e +40 . Question Traduza o programa acima para C Arquivo ex3 \u00b6 No exerc\u00edcio anterior vimos como passar vari\u00e1veis por refer\u00eancia para outras fun\u00e7\u00f5es. Agora veremos como trabalhar com scanf . Veja abaixo a fun\u00e7\u00e3o main do execut\u00e1vel ex3 . Abra este arquivo usando o gdb e siga os exerc\u00edcios. Dump of assembler code for function main : 0 x1149 <+ 0 > : sub $0x18 , %rsp 0 x114d <+ 4 > : lea 0xc ( %rsp ), %rsi 0 x1152 <+ 9 > : lea 0xeab ( %rip ), %rdi # 0x2004 0 x1159 <+ 16 > : mov $0x0 , %eax 0 x115e <+ 21 > : callq 0x1040 < __isoc99_scanf@plt > 0 x1163 <+ 26 > : cmpl $0x0 , 0xc ( %rsp ) 0 x1168 <+ 31 > : js 0x1180 < main + 55 > 0 x116a <+ 33 > : lea 0xe9f ( %rip ), %rdi # 0x2010 0 x1171 <+ 40 > : callq 0x1030 < puts@plt > 0 x1176 <+ 45 > : mov $0x0 , %eax 0 x117b <+ 50 > : add $0x18 , %rsp 0 x117f <+ 54 > : retq 0 x1180 <+ 55 > : lea 0xe80 ( %rip ), %rdi # 0x2007 0 x1187 <+ 62 > : callq 0x1030 < puts@plt > 0 x118c <+ 67 > : jmp 0x1176 < main + 45 > Question Vamos come\u00e7ar procurando por vari\u00e1veis locais que estejam na pilha. Quanto espa\u00e7o \u00e9 reservado para elas? Liste abaixo as que voc\u00ea encontrou e d\u00ea um nome para cada uma. Dica : todo acesso relativo a %rsp representa um acesso a vari\u00e1vel local. Question A instru\u00e7\u00e3o call em main+21 \u00e9 um scanf . O primeiro argumento \u00e9 a string de formata\u00e7\u00e3o. Use o comando x do gdb para encontrar ela na mem\u00f3ria. Question O segundo argumento do scanf \u00e9 o endere\u00e7o da vari\u00e1vel a ser preenchida. O endere\u00e7o que qual vari\u00e1vel local \u00e9 passado? Question Reconstrua a chamada do scanf acima. Com a chamada do scanf pronta, vamos analisar o restante do c\u00f3digo. Question Agora examinaremos as chamadas em main+40 e main+62 . Elas s\u00e3o para a fun\u00e7\u00e3o puts . Veja sua documenta\u00e7\u00e3o (procure por C puts .) e explique abaixo o qu\u00ea ela faz e quais s\u00e3o seus argumentos. Question Com base na explica\u00e7\u00e3o acima, escreva abaixo os argumentos passados para cada chamada. Question Traduza o c\u00f3digo acima para um vers\u00e3o em C . Exerc\u00edcios para entrega \u00b6 Os exerc\u00edcios 4 e 5 est\u00e3o dispon\u00edveis no reposit\u00f3rio de atividades.","title":"08 - Vari\u00e1veis locais"},{"location":"aulas/08-variaveis-locais/#08-variaveis-locais","text":"Como visto na expositiva, vari\u00e1veis locais s\u00e3o armazenadas na pilha. O topo da pilha \u00e9 armazenado em %rsp e ela cresce para baixo, ou seja, ao empilhar um dado o valor de %rsp diminui e ao desempilhar seu valor aumenta. O compilador faz todo o poss\u00edvel para usar somente os registradores, por\u00e9m em alguns casos \u00e9 necess\u00e1rio guardar a vari\u00e1vel na mem\u00f3ria. Isso ocorre, em geral, quando usamos & para computar o endere\u00e7o de uma vari\u00e1vel. O exemplo mais comum nos c\u00f3digos que j\u00e1 escrevemos \u00e9 na leitura de valores usando scanf .","title":"08 - Vari\u00e1veis locais"},{"location":"aulas/08-variaveis-locais/#exemplo-guiado","text":"Fun\u00e7\u00f5es que guardam vari\u00e1veis na pilha seguem um padr\u00e3o facilmente identific\u00e1vel. Primeiro elas subtraem um valor da pilha ( 0x10 no exemplo abaixo) correspondente ao tamanho total de todas as vari\u00e1veis usadas. Depois temos v\u00e1rias instru\u00e7\u00f5es usando endere\u00e7os relativos a %rsp e por fim devolvemos o espa\u00e7o usado somando 0x10 de volta a %rsp . sub $0x10, %rsp . . . // c\u00f3digo da fun\u00e7\u00e3o aqui! movl 0x8(%rsp),%eax mov %eax,%edx addl 0xc(%rsp),%edx . . . // fun\u00e7\u00e3o continua add $0x10, %rsp ret No exemplo acima, temos duas vari\u00e1veis locais: 0x8(%rsp) e 0xc(rsp) . Cada uma \u00e9 identificada no c\u00f3digo Assembly pelo endere\u00e7o em que est\u00e1 posicionada na pilha. Logo, todo deslocamento em rela\u00e7\u00e3o a %rsp indica um acesso a vari\u00e1vel local , sendo que pode ser um acesso de leitura e escrita (usando MOV , por exemplo) ou da opera\u00e7\u00e3o endere\u00e7o de & (usando LEA ). Conseguimos identificar que seus tamanhos s\u00e3o int por duas raz\u00f5es: elas aparecem em instru\u00e7\u00f5es junto com registradores de 4 bytes ( %eax e %edx ) as instru\u00e7\u00f5es movl e addl tem o sufixo l , que indica que os dados tratados tem tamanho 4 bytes. Os sufixos suportados s\u00e3o: b - 1 byte w - 2 bytes l - 4 bytes q - 8 bytes Qualquer raz\u00e3o acima \u00e9 suficiente para identificar os tipos das vari\u00e1veis locais. Importante Novamente, nem toda instru\u00e7\u00e3o em Assembly pode ser representada em C . As instru\u00e7\u00f5es sub 0x10, %rsp e add 0x10, %rsp representam a cria\u00e7\u00e3o de vari\u00e1veis locais na pilha e n\u00e3o tem equivalente em C . Simplesmente ignoramos elas e usamos as vari\u00e1veis locais no c\u00f3digo.","title":"Exemplo guiado"},{"location":"aulas/08-variaveis-locais/#revisao-de-variaveis-globais-e-strings-constantes","text":"Antes de iniciar o pr\u00f3ximo exerc\u00edcio vamos revisar como vari\u00e1veis locais, globais e strings constantes s\u00e3o acessadas em c\u00f3digo assembly. A imagem abaixo exemplifica os tr\u00eas casos: Vari\u00e1veis locais : s\u00e3o acessadas com lea (para & - endere\u00e7o de) ou mov (para leituras e escritas) relativos a %rsp Globais e strings constantes : s\u00e3o acessadas usando a nota\u00e7\u00e3o 0xYY(%rip) , sendo que o valor 0xYY muda a cada acesso. No caso das strings, o acesso a estes endere\u00e7os \u00e9 somente leitura. O endere\u00e7amento relativo a %rip leva em conta a posi\u00e7\u00e3o relativa entre a instru\u00e7\u00e3o atual e o endere\u00e7o de mem\u00f3ria do dado. Na imagem acima est\u00e3o destacadas duas instru\u00e7\u00f5es lea que acessam o mesmo dado. Como o %rip (ponteiro para a pr\u00f3xima instru\u00e7\u00e3o) \u00e9 diferente precisamos de deslocamentos diferentes para acessar o mesmo dado. Dica : o gdb coloca o endere\u00e7o calculado ao lado das instru\u00e7\u00f5es deste tipo. Question \u00c9 poss\u00edvel que o lea abaixo seja aritm\u00e9tico? Por que? lea 0x8 ( %rsp ), %rdx","title":"Revis\u00e3o de vari\u00e1veis globais e strings constantes"},{"location":"aulas/08-variaveis-locais/#arquivo-ex2","text":"O c\u00f3digo abaixo ( ex2 ) utiliza vari\u00e1veis locais. Dump of assembler code for function func1 : 0 x05fe <+ 0 > : sub $0x10 , %rsp 0 x0602 <+ 4 > : movl $0xa , 0xc ( %rsp ) 0 x060a <+ 12 > : movl $0xb , 0x8 ( %rsp ) 0 x0612 <+ 20 > : lea 0xc ( %rsp ), %rdi 0 x0617 <+ 25 > : callq 0x5fa < func2 > 0 x061c <+ 30 > : addl $0x1 , 0x8 ( %rsp ) 0 x0621 <+ 35 > : lea 0x8 ( %rsp ), %rdi 0 x0626 <+ 40 > : callq 0x5fa < func2 > 0 x062b <+ 45 > : add $0x10 , %rsp 0 x062f <+ 49 > : retq Vamos come\u00e7ar analisando as tr\u00eas primeiras linhas do programa. Question Quanto espa\u00e7o \u00e9 reservado na pilha? Quantas vari\u00e1veis s\u00e3o inicializadas e quais seus tamanhos e conte\u00fados? D\u00ea um nome para cada uma delas. Question Identifique onde as vari\u00e1veis locais encontradas s\u00e3o usadas. Question Os lea das linhas +20 e +35 podem ser aritm\u00e9ticos? Que opera\u00e7\u00e3o eles representam? Question Com base em sua resposta acima, traduza as chamadas de fun\u00e7\u00e3o que ocorrem nas linhas +25 e +40 . Question Traduza o programa acima para C","title":"Arquivo ex2"},{"location":"aulas/08-variaveis-locais/#arquivo-ex3","text":"No exerc\u00edcio anterior vimos como passar vari\u00e1veis por refer\u00eancia para outras fun\u00e7\u00f5es. Agora veremos como trabalhar com scanf . Veja abaixo a fun\u00e7\u00e3o main do execut\u00e1vel ex3 . Abra este arquivo usando o gdb e siga os exerc\u00edcios. Dump of assembler code for function main : 0 x1149 <+ 0 > : sub $0x18 , %rsp 0 x114d <+ 4 > : lea 0xc ( %rsp ), %rsi 0 x1152 <+ 9 > : lea 0xeab ( %rip ), %rdi # 0x2004 0 x1159 <+ 16 > : mov $0x0 , %eax 0 x115e <+ 21 > : callq 0x1040 < __isoc99_scanf@plt > 0 x1163 <+ 26 > : cmpl $0x0 , 0xc ( %rsp ) 0 x1168 <+ 31 > : js 0x1180 < main + 55 > 0 x116a <+ 33 > : lea 0xe9f ( %rip ), %rdi # 0x2010 0 x1171 <+ 40 > : callq 0x1030 < puts@plt > 0 x1176 <+ 45 > : mov $0x0 , %eax 0 x117b <+ 50 > : add $0x18 , %rsp 0 x117f <+ 54 > : retq 0 x1180 <+ 55 > : lea 0xe80 ( %rip ), %rdi # 0x2007 0 x1187 <+ 62 > : callq 0x1030 < puts@plt > 0 x118c <+ 67 > : jmp 0x1176 < main + 45 > Question Vamos come\u00e7ar procurando por vari\u00e1veis locais que estejam na pilha. Quanto espa\u00e7o \u00e9 reservado para elas? Liste abaixo as que voc\u00ea encontrou e d\u00ea um nome para cada uma. Dica : todo acesso relativo a %rsp representa um acesso a vari\u00e1vel local. Question A instru\u00e7\u00e3o call em main+21 \u00e9 um scanf . O primeiro argumento \u00e9 a string de formata\u00e7\u00e3o. Use o comando x do gdb para encontrar ela na mem\u00f3ria. Question O segundo argumento do scanf \u00e9 o endere\u00e7o da vari\u00e1vel a ser preenchida. O endere\u00e7o que qual vari\u00e1vel local \u00e9 passado? Question Reconstrua a chamada do scanf acima. Com a chamada do scanf pronta, vamos analisar o restante do c\u00f3digo. Question Agora examinaremos as chamadas em main+40 e main+62 . Elas s\u00e3o para a fun\u00e7\u00e3o puts . Veja sua documenta\u00e7\u00e3o (procure por C puts .) e explique abaixo o qu\u00ea ela faz e quais s\u00e3o seus argumentos. Question Com base na explica\u00e7\u00e3o acima, escreva abaixo os argumentos passados para cada chamada. Question Traduza o c\u00f3digo acima para um vers\u00e3o em C .","title":"Arquivo ex3"},{"location":"aulas/08-variaveis-locais/#exercicios-para-entrega","text":"Os exerc\u00edcios 4 e 5 est\u00e3o dispon\u00edveis no reposit\u00f3rio de atividades.","title":"Exerc\u00edcios para entrega"},{"location":"aulas/09-arrays/","text":"09 - Array em Assembly \u00b6 A parte final de nossas atividades com Assembly \u00e9 entender Arrays . J\u00e1 estudamos todo o necess\u00e1rio para lidar com eles: um array \u00e9 representado por um apontador para seu primeiro elemento. J\u00e1 estudamos ponteiros e a escrita em mem\u00f3ria com MOV . ao acessar o elemento i de long *vec estamos acessando o endere\u00e7o &vec[0] + sizeof(long) * i . A nota\u00e7\u00e3o de c\u00e1lculos de endere\u00e7o de mem\u00f3ria faz exatamente isso. Para iniciar vamos revisar a nota\u00e7\u00e3o de c\u00e1lculo de endere\u00e7os de mem\u00f3ria: D(%reg1, %reg2, S) , onde D \u00e9 um n\u00famero inteiro que representa um deslocamento constante a partir do endere\u00e7o guardado em %reg1 %reg1 cont\u00e9m o endere\u00e7o do primeiro elemento do vetor %reg2 cont\u00e9m o \u00edndice do elemento a ser acessado S cont\u00e9m o tamanho de cada elemento do vetor e pode ser 1, 2, 4 ou 8 . O acesso \u00e9 feito ao endere\u00e7o D + %reg1 + S * %reg2 . Ou seja, primeiro computamos o endere\u00e7o e depois acessamos a mem\u00f3ria no endere\u00e7o computado . Exemplo guiado \u00b6 Dado o array int *vec (guardado em %rdx ). A atribui\u00e7\u00e3o de 5 ao elemento i (guardado em %ecx ) seria traduzida como MOVL $0x5 , ( %rdx , %rcx , 4 ) Importante Lembre-se de que apontadores s\u00e3o tipos de dados com tamanho 8 bytes . Considerando um vetor short *vec e que o endere\u00e7o do primeiro elemento de vec esteja em %rdi , Question Qual a instru\u00e7\u00e3o usada para mover o conte\u00fado de vec[i] para o registrador %eax ?(supondo que o valor de i esteja em %esi ) Question Qual a instru\u00e7\u00e3o usada para mover &vec[i] para o registrador %eax ? Dica : como voc\u00ea implementava o operador & com vari\u00e1veis locais? Exerc\u00edcio 1 - fun\u00e7\u00e3o soma \u00b6 Veja o c\u00f3digo abaixo e responda as perguntas. 0000000000000000 < soma > : 0: ba 00 00 00 00 mov $0x0 , %edx 5: b8 00 00 00 00 mov $0x0 , %eax a: eb 09 jmp 15 < soma + 0x15 > c: 48 63 ca movslq %edx , %rcx f: 03 04 8 f add ( %rdi , %rcx , 4 ), %eax 12: 83 c2 01 add $0x1 , %edx 15: 39 f2 cmp %esi , %edx 17: 7 c f3 jl c < soma + 0xc > 19: f3 c3 repz retq Question A fun\u00e7\u00e3o acima usa v\u00e1rios registradores. Para facilitar a descoberta de quais s\u00e3o par\u00e2metros da fun\u00e7\u00e3o anote abaixo cada registrador usado e, ao lado, a linha do primeiro uso e se esse uso foi leitura ou escrita. Question Se o primeiro acesso a registrador \u00e9 de escrita ent\u00e3o ele provavelmente n\u00e3o \u00e9 um par\u00e2metro. Com base nisto, escreva abaixo a declara\u00e7\u00e3o da fun\u00e7\u00e3o acima. Question Sempre que escrevemos a nota\u00e7\u00e3o de acesso \u00e0 mem\u00f3ria D(%reg1, %reg2, S) precisamos usar registradores de 64 bits nos lugares de reg1 e reg2 . Com base nisto, explique qual o uso feito do registrador %edx e porqu\u00ea usamos a instru\u00e7\u00e3o movslq na linha c . Question Fa\u00e7a uma vers\u00e3o em C do c\u00f3digo acima usando somente if-goto . Escreva, ent\u00e3o, ao lado desta vers\u00e3o um c\u00f3digo leg\u00edvel em C . Acesso a elementos constantes \u00b6 O acesso a elementos \"constantes\", como long v[10]; v[5] = 0; , n\u00e3o \u00e9 feito usando a nota\u00e7\u00e3o acima, pois o compilador j\u00e1 sabe em tempo de compila\u00e7\u00e3o , qual \u00e9 o deslocamento necess\u00e1rio para encontrar a posi\u00e7\u00e3o 6 de v . Considerando o exemplo acima, responda. Question Supondo que v=0x100 , qual o \u00e9 o endere\u00e7o de v[5] ? Question Escreva a instru\u00e7\u00e3o usada para mover o valor 0 para v[5] (supondo que o endere\u00e7o do primeiro elemento esteja em %rdi ). Exerc\u00edcio 2 - fun\u00e7\u00e3o func_que_recebe_array \u00b6 0000000000000000 <func_que_recebe_array>: 0: 8b 47 04 mov 0x4(%rdi),%eax 3: 03 07 add (%rdi),%eax 5: 3b 47 08 cmp 0x8(%rdi),%eax 8: 0f 9c c0 setl %al b: 0f b6 c0 movzbl %al,%eax e: c3 retq Question Temos acessos \u00e0 mem\u00f3ria relativos ao endere\u00e7o passado em %rdi nas linhas 0, 3 e 5 . Isto significa que %rdi \u00e9 um ponteiro. Pelos tipos de acessos feitos, voc\u00ea consegue identificar para qual tipo de vari\u00e1vel ele aponta? Question Traduza os acessos de mem\u00f3ria feitos nas linhas citadas acima para a nota\u00e7\u00e3o de acesso a arrays em C . Question Com base no respondido acima, fa\u00e7a uma vers\u00e3o em C leg\u00edvel do c\u00f3digo asembly acima. Se ajudar, fa\u00e7a uma tradu\u00e7\u00e3o linha a linha do Assembly e depois torne-a leg\u00edvel. Exerc\u00edcio 3 - fun\u00e7\u00e3o first_neg \u00b6 Veja agora o c\u00f3digo abaixo e responda. 0000000000000000 < first_neg > : 0: b8 00 00 00 00 mov $0x0 , %eax 5: 39 f0 cmp %esi , %eax 7: 7 d 0 e jge 17 < first_neg + 0x17 > 9: 48 63 d0 movslq %eax , %rdx c: 83 3 c 97 00 cmpl $0x0 ,( %rdi , %rdx , 4 ) 10: 78 05 js 17 < first_neg + 0x17 > 12: 83 c0 01 add $0x1 , %eax 15: eb ee jmp 5 < first_neg + 0x5 > 17: f3 c3 repz retq Question A fun\u00e7\u00e3o acima usa v\u00e1rios registradores. Para facilitar a descoberta de quais s\u00e3o par\u00e2metros da fun\u00e7\u00e3o anote abaixo cada registrador usado e, ao lado, a linha do primeiro uso e se esse uso foi leitura ou escrita. Question Desenhe setas indicando o destino dos pulos no c\u00f3digo acima. Voc\u00ea consegue idenfiticar quais estruturas de controle? Entre quais linhas? Question Fa\u00e7a uma vers\u00e3o em C usando if-goto do c\u00f3digo acima. Question Transforme seu c\u00f3digo em uma vers\u00e3o leg\u00edvel.","title":"09 - Array em Assembly"},{"location":"aulas/09-arrays/#09-array-em-assembly","text":"A parte final de nossas atividades com Assembly \u00e9 entender Arrays . J\u00e1 estudamos todo o necess\u00e1rio para lidar com eles: um array \u00e9 representado por um apontador para seu primeiro elemento. J\u00e1 estudamos ponteiros e a escrita em mem\u00f3ria com MOV . ao acessar o elemento i de long *vec estamos acessando o endere\u00e7o &vec[0] + sizeof(long) * i . A nota\u00e7\u00e3o de c\u00e1lculos de endere\u00e7o de mem\u00f3ria faz exatamente isso. Para iniciar vamos revisar a nota\u00e7\u00e3o de c\u00e1lculo de endere\u00e7os de mem\u00f3ria: D(%reg1, %reg2, S) , onde D \u00e9 um n\u00famero inteiro que representa um deslocamento constante a partir do endere\u00e7o guardado em %reg1 %reg1 cont\u00e9m o endere\u00e7o do primeiro elemento do vetor %reg2 cont\u00e9m o \u00edndice do elemento a ser acessado S cont\u00e9m o tamanho de cada elemento do vetor e pode ser 1, 2, 4 ou 8 . O acesso \u00e9 feito ao endere\u00e7o D + %reg1 + S * %reg2 . Ou seja, primeiro computamos o endere\u00e7o e depois acessamos a mem\u00f3ria no endere\u00e7o computado .","title":"09 - Array em Assembly"},{"location":"aulas/09-arrays/#exemplo-guiado","text":"Dado o array int *vec (guardado em %rdx ). A atribui\u00e7\u00e3o de 5 ao elemento i (guardado em %ecx ) seria traduzida como MOVL $0x5 , ( %rdx , %rcx , 4 ) Importante Lembre-se de que apontadores s\u00e3o tipos de dados com tamanho 8 bytes . Considerando um vetor short *vec e que o endere\u00e7o do primeiro elemento de vec esteja em %rdi , Question Qual a instru\u00e7\u00e3o usada para mover o conte\u00fado de vec[i] para o registrador %eax ?(supondo que o valor de i esteja em %esi ) Question Qual a instru\u00e7\u00e3o usada para mover &vec[i] para o registrador %eax ? Dica : como voc\u00ea implementava o operador & com vari\u00e1veis locais?","title":"Exemplo guiado"},{"location":"aulas/09-arrays/#exercicio-1-funcao-soma","text":"Veja o c\u00f3digo abaixo e responda as perguntas. 0000000000000000 < soma > : 0: ba 00 00 00 00 mov $0x0 , %edx 5: b8 00 00 00 00 mov $0x0 , %eax a: eb 09 jmp 15 < soma + 0x15 > c: 48 63 ca movslq %edx , %rcx f: 03 04 8 f add ( %rdi , %rcx , 4 ), %eax 12: 83 c2 01 add $0x1 , %edx 15: 39 f2 cmp %esi , %edx 17: 7 c f3 jl c < soma + 0xc > 19: f3 c3 repz retq Question A fun\u00e7\u00e3o acima usa v\u00e1rios registradores. Para facilitar a descoberta de quais s\u00e3o par\u00e2metros da fun\u00e7\u00e3o anote abaixo cada registrador usado e, ao lado, a linha do primeiro uso e se esse uso foi leitura ou escrita. Question Se o primeiro acesso a registrador \u00e9 de escrita ent\u00e3o ele provavelmente n\u00e3o \u00e9 um par\u00e2metro. Com base nisto, escreva abaixo a declara\u00e7\u00e3o da fun\u00e7\u00e3o acima. Question Sempre que escrevemos a nota\u00e7\u00e3o de acesso \u00e0 mem\u00f3ria D(%reg1, %reg2, S) precisamos usar registradores de 64 bits nos lugares de reg1 e reg2 . Com base nisto, explique qual o uso feito do registrador %edx e porqu\u00ea usamos a instru\u00e7\u00e3o movslq na linha c . Question Fa\u00e7a uma vers\u00e3o em C do c\u00f3digo acima usando somente if-goto . Escreva, ent\u00e3o, ao lado desta vers\u00e3o um c\u00f3digo leg\u00edvel em C .","title":"Exerc\u00edcio 1 - fun\u00e7\u00e3o soma"},{"location":"aulas/09-arrays/#acesso-a-elementos-constantes","text":"O acesso a elementos \"constantes\", como long v[10]; v[5] = 0; , n\u00e3o \u00e9 feito usando a nota\u00e7\u00e3o acima, pois o compilador j\u00e1 sabe em tempo de compila\u00e7\u00e3o , qual \u00e9 o deslocamento necess\u00e1rio para encontrar a posi\u00e7\u00e3o 6 de v . Considerando o exemplo acima, responda. Question Supondo que v=0x100 , qual o \u00e9 o endere\u00e7o de v[5] ? Question Escreva a instru\u00e7\u00e3o usada para mover o valor 0 para v[5] (supondo que o endere\u00e7o do primeiro elemento esteja em %rdi ).","title":"Acesso a elementos constantes"},{"location":"aulas/09-arrays/#exercicio-2-funcao-func_que_recebe_array","text":"0000000000000000 <func_que_recebe_array>: 0: 8b 47 04 mov 0x4(%rdi),%eax 3: 03 07 add (%rdi),%eax 5: 3b 47 08 cmp 0x8(%rdi),%eax 8: 0f 9c c0 setl %al b: 0f b6 c0 movzbl %al,%eax e: c3 retq Question Temos acessos \u00e0 mem\u00f3ria relativos ao endere\u00e7o passado em %rdi nas linhas 0, 3 e 5 . Isto significa que %rdi \u00e9 um ponteiro. Pelos tipos de acessos feitos, voc\u00ea consegue identificar para qual tipo de vari\u00e1vel ele aponta? Question Traduza os acessos de mem\u00f3ria feitos nas linhas citadas acima para a nota\u00e7\u00e3o de acesso a arrays em C . Question Com base no respondido acima, fa\u00e7a uma vers\u00e3o em C leg\u00edvel do c\u00f3digo asembly acima. Se ajudar, fa\u00e7a uma tradu\u00e7\u00e3o linha a linha do Assembly e depois torne-a leg\u00edvel.","title":"Exerc\u00edcio 2 - fun\u00e7\u00e3o func_que_recebe_array"},{"location":"aulas/09-arrays/#exercicio-3-funcao-first_neg","text":"Veja agora o c\u00f3digo abaixo e responda. 0000000000000000 < first_neg > : 0: b8 00 00 00 00 mov $0x0 , %eax 5: 39 f0 cmp %esi , %eax 7: 7 d 0 e jge 17 < first_neg + 0x17 > 9: 48 63 d0 movslq %eax , %rdx c: 83 3 c 97 00 cmpl $0x0 ,( %rdi , %rdx , 4 ) 10: 78 05 js 17 < first_neg + 0x17 > 12: 83 c0 01 add $0x1 , %eax 15: eb ee jmp 5 < first_neg + 0x5 > 17: f3 c3 repz retq Question A fun\u00e7\u00e3o acima usa v\u00e1rios registradores. Para facilitar a descoberta de quais s\u00e3o par\u00e2metros da fun\u00e7\u00e3o anote abaixo cada registrador usado e, ao lado, a linha do primeiro uso e se esse uso foi leitura ou escrita. Question Desenhe setas indicando o destino dos pulos no c\u00f3digo acima. Voc\u00ea consegue idenfiticar quais estruturas de controle? Entre quais linhas? Question Fa\u00e7a uma vers\u00e3o em C usando if-goto do c\u00f3digo acima. Question Transforme seu c\u00f3digo em uma vers\u00e3o leg\u00edvel.","title":"Exerc\u00edcio 3 - fun\u00e7\u00e3o first_neg"},{"location":"aulas/10-malloc/","text":"10 - Aloca\u00e7\u00e3o Din\u00e2mica de Mem\u00f3ria \u00b6 Exerc\u00edcios b\u00e1sicos \u00b6 Example Abra o arquivo ex1.c em um editor e compile-o usando as flags da disciplina ( -Og -Wall -std=c99 ). Sem rodar o programa , responda as quest\u00f5es abaixo. Question Analisando seu c\u00f3digo-fonte, o que este programa faz? Question Na execu\u00e7\u00e3o deste programa, existe alguma possibilidade da aloca\u00e7\u00e3o din\u00e2mica com malloc falhar? Caso sim, indique as situa\u00e7\u00f5es onde isto poderia acontecer. Question O seu programa libera toda mem\u00f3ria que aloca? Se n\u00e3o, aponte onde ele deveria fazer isto. Agora execute o programa acima e responda as quest\u00f5es abaixo. Question Ocorreu algum problema durante a execu\u00e7\u00e3o? Question O comportamento de seu programa muda conforme N? V\u00e1 incrementando de um em um e veja o que acontece. Voc\u00ea consegue explicar por que? Discuta com seu grupo e valide sua resposta com o professor. Question Existem tr\u00eas problemas no c\u00f3digo. O primeiro ( vetor n\u00e3o \u00e9 desalocado) j\u00e1 indetificamos no exerc\u00edco anterior. Voc\u00ea consegue identificar os outros dois? Corrija-os e salve o programa em um arquivo ex1-certo.c . Ferramentas de verifica\u00e7\u00e3o de mem\u00f3ria \u00b6 Para poder identificar mais facilmente problemas relativos a mem\u00f3ria, iremos utilizar uma ferramenta chamada Valgrind. O Valgrind \u00e9 um detector de m\u00e1 gest\u00e3o de mem\u00f3ria. Ele roda seu programa em cima de um ambiente modificado e aponta os seguintes erros: mem\u00f3ria alocada e n\u00e3o liberada acessos (leituras e escritas) a posi\u00e7\u00f5es de mem\u00f3ria n\u00e3o alocada ou inv\u00e1lidas O valgrind est\u00e1 dispon\u00edvel na maioria das distribui\u00e7\u00f5es Linux modernas sudo apt-get install valgrind Para que os problemas encontrados pelo Valgrind sejam mais facilmente identificados, iremos passar a compilar utilizando a flag -g . Example Compile os programas ex1 e ex1-certo criados na parte anterior com a flag -g . Question Rode o Valgrind com valgrind --leak-check=yes ./ex1 . Quais foram os problemas encontrados e em quais linhas do c\u00f3digo? Question O qu\u00ea significa o primeiro erro? Como corrig\u00ed-lo? Question O qu\u00ea significa o segundo erro? Como corrig\u00ed-lo? Question A se\u00e7\u00e3o HEAP SUMMARY faz um resumo dos dados alocados/desalocados no seu programa. Ela mostra algum problema? Se sim, qual linha de c\u00f3digo \u00e9 apontada? Qual \u00e9 o problema diagnosticado por este aviso? Example Verifique que seu programa corrigido ex1-certo.c roda sem erros no valgrind. Se n\u00e3o, corrija os problema e rode novamente at\u00e9 que rode sem erros. Implementa\u00e7\u00f5es de fun\u00e7\u00f5es ( Entrega ) \u00b6 Os exerc\u00edcios abaixo est\u00e3o dispon\u00edveis no reposit\u00f3rio de entregas (pasta 08-malloc ). Example Abra o arquivo ex4.c e implemente a fun\u00e7\u00e3o mystrcpy . Esta fun\u00e7\u00e3o recebe uma string, e devolve uma c\u00f3pia da string original, alocando apenas o espa\u00e7o realmente necess\u00e1rio. Example Abra o arquivo ex5.c e implemente a fun\u00e7\u00e3o mystrcat . Esta fun\u00e7\u00e3o recebe duas string, e devolve uma terceira que \u00e9 a concatena\u00e7\u00e3o das duas primeiras, alocando apenas o espa\u00e7o realmente necess\u00e1rio. Warning N\u00e3o se esque\u00e7a de checar se sua implementa\u00e7\u00e3o tem erros usando o valgrind.","title":"10 - Aloca\u00e7\u00e3o Din\u00e2mica de Mem\u00f3ria"},{"location":"aulas/10-malloc/#10-alocacao-dinamica-de-memoria","text":"","title":"10 - Aloca\u00e7\u00e3o Din\u00e2mica de Mem\u00f3ria"},{"location":"aulas/10-malloc/#exercicios-basicos","text":"Example Abra o arquivo ex1.c em um editor e compile-o usando as flags da disciplina ( -Og -Wall -std=c99 ). Sem rodar o programa , responda as quest\u00f5es abaixo. Question Analisando seu c\u00f3digo-fonte, o que este programa faz? Question Na execu\u00e7\u00e3o deste programa, existe alguma possibilidade da aloca\u00e7\u00e3o din\u00e2mica com malloc falhar? Caso sim, indique as situa\u00e7\u00f5es onde isto poderia acontecer. Question O seu programa libera toda mem\u00f3ria que aloca? Se n\u00e3o, aponte onde ele deveria fazer isto. Agora execute o programa acima e responda as quest\u00f5es abaixo. Question Ocorreu algum problema durante a execu\u00e7\u00e3o? Question O comportamento de seu programa muda conforme N? V\u00e1 incrementando de um em um e veja o que acontece. Voc\u00ea consegue explicar por que? Discuta com seu grupo e valide sua resposta com o professor. Question Existem tr\u00eas problemas no c\u00f3digo. O primeiro ( vetor n\u00e3o \u00e9 desalocado) j\u00e1 indetificamos no exerc\u00edco anterior. Voc\u00ea consegue identificar os outros dois? Corrija-os e salve o programa em um arquivo ex1-certo.c .","title":"Exerc\u00edcios b\u00e1sicos"},{"location":"aulas/10-malloc/#ferramentas-de-verificacao-de-memoria","text":"Para poder identificar mais facilmente problemas relativos a mem\u00f3ria, iremos utilizar uma ferramenta chamada Valgrind. O Valgrind \u00e9 um detector de m\u00e1 gest\u00e3o de mem\u00f3ria. Ele roda seu programa em cima de um ambiente modificado e aponta os seguintes erros: mem\u00f3ria alocada e n\u00e3o liberada acessos (leituras e escritas) a posi\u00e7\u00f5es de mem\u00f3ria n\u00e3o alocada ou inv\u00e1lidas O valgrind est\u00e1 dispon\u00edvel na maioria das distribui\u00e7\u00f5es Linux modernas sudo apt-get install valgrind Para que os problemas encontrados pelo Valgrind sejam mais facilmente identificados, iremos passar a compilar utilizando a flag -g . Example Compile os programas ex1 e ex1-certo criados na parte anterior com a flag -g . Question Rode o Valgrind com valgrind --leak-check=yes ./ex1 . Quais foram os problemas encontrados e em quais linhas do c\u00f3digo? Question O qu\u00ea significa o primeiro erro? Como corrig\u00ed-lo? Question O qu\u00ea significa o segundo erro? Como corrig\u00ed-lo? Question A se\u00e7\u00e3o HEAP SUMMARY faz um resumo dos dados alocados/desalocados no seu programa. Ela mostra algum problema? Se sim, qual linha de c\u00f3digo \u00e9 apontada? Qual \u00e9 o problema diagnosticado por este aviso? Example Verifique que seu programa corrigido ex1-certo.c roda sem erros no valgrind. Se n\u00e3o, corrija os problema e rode novamente at\u00e9 que rode sem erros.","title":"Ferramentas de verifica\u00e7\u00e3o de mem\u00f3ria"},{"location":"aulas/10-malloc/#implementacoes-de-funcoes-entrega","text":"Os exerc\u00edcios abaixo est\u00e3o dispon\u00edveis no reposit\u00f3rio de entregas (pasta 08-malloc ). Example Abra o arquivo ex4.c e implemente a fun\u00e7\u00e3o mystrcpy . Esta fun\u00e7\u00e3o recebe uma string, e devolve uma c\u00f3pia da string original, alocando apenas o espa\u00e7o realmente necess\u00e1rio. Example Abra o arquivo ex5.c e implemente a fun\u00e7\u00e3o mystrcat . Esta fun\u00e7\u00e3o recebe duas string, e devolve uma terceira que \u00e9 a concatena\u00e7\u00e3o das duas primeiras, alocando apenas o espa\u00e7o realmente necess\u00e1rio. Warning N\u00e3o se esque\u00e7a de checar se sua implementa\u00e7\u00e3o tem erros usando o valgrind.","title":"Implementa\u00e7\u00f5es de fun\u00e7\u00f5es (Entrega)"},{"location":"aulas/11-tipos-de-dados/","text":"11 - Tipos abstratos de dados \u00b6 A estrutura Point2D \u00b6 Vamos considerar primeiro uma estrutura usada para guardar um ponto 2D. Este tipo de estrutura seria \u00fatil ao trabalhar com algoritmos de Geometria Computacional ou mesmo em aplica\u00e7\u00f5es de f\u00edsica. typedef struct { double x , y ; } Point2D ; Vamos listar algumas opera\u00e7\u00f5es que podem ser feitas com um ponto: Inicializa\u00e7\u00e3o e finaliza\u00e7\u00e3o - todo ponto deve ser inicializado com algum valor para x e y. Somar dois pontos (e obter um terceiro); Calcular o coeficiente angular de uma reta que passe pelos dois pontos; Multiplicar ambas as coordenadas de um ponto (recebendo um novo em troca) - esta opera\u00e7\u00e3o equivale a mudan\u00e7as de escala Retornar os valores das componentes x e y do ponto; A ideia de um Tipo Abstrato de Dados \u00e9 formalizar um \"contrato\" que lista quais opera\u00e7\u00f5es podem ser feitas com este dado. Estas opera\u00e7\u00f5es n\u00e3o dependem de nenhuma implementa\u00e7\u00e3o em particular do tipo. Por exemplo, declarar o ponto com contendo um double coords[2] n\u00e3o muda os resultados de nenhuma das opera\u00e7\u00f5es acima mas mudaria o c\u00f3digo de acesso a coordenada x ( p.x vs p.coords[0] ). Veja um exemplo concreto de como fazer isto abaixo (arquivo point2d.h ). #ifndef __POINT2D__ #define __POINT2D__ struct _p ; typedef struct _p Point2D ; Point2D * point2D_new ( double x , double y ); void point2D_destroy ( Point2D * p ); double point2D_get_x ( Point2D * p ); double point2D_get_y ( Point2D * p ); Point2D * point2D_add ( Point2D * p1 , Point2D * p2 ); double point2D_theta ( Point2D * p1 , Point2D * p2 ); Point2D * point2D_scale ( Point2D * p , double s ); #endif Ponteiros opacos \u00b6 Note que no exemplo acima a defini\u00e7\u00e3o do struct Point2D n\u00e3o est\u00e1 inclusa no arquivo point2d.h ! Por conta de ponteiro se um tipo de dado em C , podemos declarar ponteiros para Point2D e pass\u00e1-los para as fun\u00e7\u00f5es de nosso TAD mesmo sem saber a defini\u00e7\u00e3o exata de onde eles apontam! . S\u00f3 n\u00e3o podemos tentar acessar a vari\u00e1vel apontada por este ponteiros (usando * ou -> ). Por isso, aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria \u00e9 essencial em TAD*s: ela permite que todos os detalhes da implementa\u00e7\u00e3o interna estejam **encapsulados* e que s\u00f3 possamos interagir com o tipo via as fun\u00e7\u00f5es definidas para isso. Example Abra o arquivo teste_point2d.c . Voc\u00ea consegue entender seu conte\u00fado? Examine o c\u00f3digo e entenda como Point2D deve ser usado. Question Compile o arquivo teste_point2d.c usando a seguinte linha de comando. Rode-o logo em seguida. O que significa sua sa\u00edda? $ gcc -Og -Wall -g teste_point2d.c point2d.c -o teste_ponto Example Abra o arquivo point2d.c e complete as partes faltantes. Verifique se tudo funciona corretamente usando teste_point2d.c . Voc\u00ea deve aproveitar ao m\u00e1ximo as fun\u00e7\u00f5es j\u00e1 criadas (ou seja, pode usar point2d_new nas outras fun\u00e7\u00f5es). Example Agora que sua implementa\u00e7\u00e3o do TAD Point2D est\u00e1 completa, compile o arquivo teste_point2d.c e execute-o usando o Valgrind . Seu programa dever\u00e1 rodar sem erros. Vetores din\u00e2micos \u00b6 Agora que j\u00e1 vimos vetores din\u00e2micos em aula, vamos implement\u00e1-los. Nosso vetor tem a seguinte interface: #ifndef __VECINT_H__ #define __VECINT_H__ struct _vec_int ; typedef struct _vec_int vec_int ; vec_int * vec_int_create (); void vec_int_destroy ( vec_int ** v ); int vec_int_size ( vec_int * v ); /* As seguinte opera\u00e7\u00f5es devolvem * 1 se pos \u00e9 uma posi\u00e7\u00e3o v\u00e1lida e a opera\u00e7\u00e3o foi bem sucedida * 0 caso contr\u00e1rio * * No caso de at, o valor \u00e9 retornado na vari\u00e1vel apontada por vi. */ int vec_int_at ( vec_int * v , int pos , int * vi ); int vec_int_insert ( vec_int * v , int pos , int val ); int vec_int_remove ( vec_int * v , int pos ); #endif Example Entrega : implemente a estrutura vetor din\u00e2mico no arquivo vec_int.c e compile o programa de testes da mesma maneira que foi feito na parte anterior. Para sua entrega estar 100% seu programa de testes dever\u00e1 rodar sem erros no valgrind . Os arquivos est\u00e3o na pasta 09-tad do reposit\u00f3rio de entregas.","title":"11 - Tipos abstratos de dados"},{"location":"aulas/11-tipos-de-dados/#11-tipos-abstratos-de-dados","text":"","title":"11 - Tipos abstratos de dados"},{"location":"aulas/11-tipos-de-dados/#a-estrutura-point2d","text":"Vamos considerar primeiro uma estrutura usada para guardar um ponto 2D. Este tipo de estrutura seria \u00fatil ao trabalhar com algoritmos de Geometria Computacional ou mesmo em aplica\u00e7\u00f5es de f\u00edsica. typedef struct { double x , y ; } Point2D ; Vamos listar algumas opera\u00e7\u00f5es que podem ser feitas com um ponto: Inicializa\u00e7\u00e3o e finaliza\u00e7\u00e3o - todo ponto deve ser inicializado com algum valor para x e y. Somar dois pontos (e obter um terceiro); Calcular o coeficiente angular de uma reta que passe pelos dois pontos; Multiplicar ambas as coordenadas de um ponto (recebendo um novo em troca) - esta opera\u00e7\u00e3o equivale a mudan\u00e7as de escala Retornar os valores das componentes x e y do ponto; A ideia de um Tipo Abstrato de Dados \u00e9 formalizar um \"contrato\" que lista quais opera\u00e7\u00f5es podem ser feitas com este dado. Estas opera\u00e7\u00f5es n\u00e3o dependem de nenhuma implementa\u00e7\u00e3o em particular do tipo. Por exemplo, declarar o ponto com contendo um double coords[2] n\u00e3o muda os resultados de nenhuma das opera\u00e7\u00f5es acima mas mudaria o c\u00f3digo de acesso a coordenada x ( p.x vs p.coords[0] ). Veja um exemplo concreto de como fazer isto abaixo (arquivo point2d.h ). #ifndef __POINT2D__ #define __POINT2D__ struct _p ; typedef struct _p Point2D ; Point2D * point2D_new ( double x , double y ); void point2D_destroy ( Point2D * p ); double point2D_get_x ( Point2D * p ); double point2D_get_y ( Point2D * p ); Point2D * point2D_add ( Point2D * p1 , Point2D * p2 ); double point2D_theta ( Point2D * p1 , Point2D * p2 ); Point2D * point2D_scale ( Point2D * p , double s ); #endif","title":"A estrutura Point2D"},{"location":"aulas/11-tipos-de-dados/#ponteiros-opacos","text":"Note que no exemplo acima a defini\u00e7\u00e3o do struct Point2D n\u00e3o est\u00e1 inclusa no arquivo point2d.h ! Por conta de ponteiro se um tipo de dado em C , podemos declarar ponteiros para Point2D e pass\u00e1-los para as fun\u00e7\u00f5es de nosso TAD mesmo sem saber a defini\u00e7\u00e3o exata de onde eles apontam! . S\u00f3 n\u00e3o podemos tentar acessar a vari\u00e1vel apontada por este ponteiros (usando * ou -> ). Por isso, aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria \u00e9 essencial em TAD*s: ela permite que todos os detalhes da implementa\u00e7\u00e3o interna estejam **encapsulados* e que s\u00f3 possamos interagir com o tipo via as fun\u00e7\u00f5es definidas para isso. Example Abra o arquivo teste_point2d.c . Voc\u00ea consegue entender seu conte\u00fado? Examine o c\u00f3digo e entenda como Point2D deve ser usado. Question Compile o arquivo teste_point2d.c usando a seguinte linha de comando. Rode-o logo em seguida. O que significa sua sa\u00edda? $ gcc -Og -Wall -g teste_point2d.c point2d.c -o teste_ponto Example Abra o arquivo point2d.c e complete as partes faltantes. Verifique se tudo funciona corretamente usando teste_point2d.c . Voc\u00ea deve aproveitar ao m\u00e1ximo as fun\u00e7\u00f5es j\u00e1 criadas (ou seja, pode usar point2d_new nas outras fun\u00e7\u00f5es). Example Agora que sua implementa\u00e7\u00e3o do TAD Point2D est\u00e1 completa, compile o arquivo teste_point2d.c e execute-o usando o Valgrind . Seu programa dever\u00e1 rodar sem erros.","title":"Ponteiros opacos"},{"location":"aulas/11-tipos-de-dados/#vetores-dinamicos","text":"Agora que j\u00e1 vimos vetores din\u00e2micos em aula, vamos implement\u00e1-los. Nosso vetor tem a seguinte interface: #ifndef __VECINT_H__ #define __VECINT_H__ struct _vec_int ; typedef struct _vec_int vec_int ; vec_int * vec_int_create (); void vec_int_destroy ( vec_int ** v ); int vec_int_size ( vec_int * v ); /* As seguinte opera\u00e7\u00f5es devolvem * 1 se pos \u00e9 uma posi\u00e7\u00e3o v\u00e1lida e a opera\u00e7\u00e3o foi bem sucedida * 0 caso contr\u00e1rio * * No caso de at, o valor \u00e9 retornado na vari\u00e1vel apontada por vi. */ int vec_int_at ( vec_int * v , int pos , int * vi ); int vec_int_insert ( vec_int * v , int pos , int val ); int vec_int_remove ( vec_int * v , int pos ); #endif Example Entrega : implemente a estrutura vetor din\u00e2mico no arquivo vec_int.c e compile o programa de testes da mesma maneira que foi feito na parte anterior. Para sua entrega estar 100% seu programa de testes dever\u00e1 rodar sem erros no valgrind . Os arquivos est\u00e3o na pasta 09-tad do reposit\u00f3rio de entregas.","title":"Vetores din\u00e2micos"},{"location":"aulas/12-linux-do-zero/","text":"12 - Linux do Zero \u00b6 Tarefas preliminares \u00b6 Vamos precisar dos seguintes softwares instalados no sistema. Como o resto do curso, os pacotes abaixo s\u00e3o para o Ubuntu 20.04 LTS, build-essential flex bison qemu ncurses-dev libssl-dev libelf-dev qemu-system-x86 Example Instale os pacotes acima no seu sistema usando apt . Example Crie um programa que mostra a mensagem Hello world (seu nome) . Compile-o e chame-o hello-dyn . Example Execute o comando ldd ./hello-dyn e veja sua sa\u00edda. O comando ldd \u00e9 usado para listar todas as bibliotecas din\u00e2micas usadas por um execut\u00e1vel. Antes de rodar hello-dyn o Linux garante que todos os arquivos listados no exerc\u00edcio anterior est\u00e3o carregados na mem\u00f3ria tamb\u00e9m. Por esta raz\u00e3o, cada arquivo .so listado \u00e9 chamado de depend\u00eancia de hello-dyn . Example Vamos agora usar a flag -static do gcc para embutir todos os arquivos acima em um \u00fanico execut\u00e1vel. Crie um novo execut\u00e1vel hello-static . Example Execute ambos e veja que eles possuem o mesmo resultado. Example Execute ldd no arquivo hello-static e verifique que ele n\u00e3o tem nenhuma depend\u00eancia. Vamos usar ambos programas mais para a frente do roteiro. Compilando o kernel \u00b6 Vamos primeiro fazer o download do kernel do Linux no site oficial ( https://www.kernel.org/ ). Podem baixar a vers\u00e3o mais recente (atualmente 5.9 ) Example Decompacte o arquivo baixado e examine os arquivos na pasta criada. $> tar xvf linux-X.Y.Z.tar.xz Isto criar\u00e1 uma pasta linux-X.Y.Z que cont\u00e9m os fontes de todo o kernel. O kernel pode ser compilado com uma quantidade enorme de configura\u00e7\u00f5es diferentes, sendo que a configura\u00e7\u00e3o atual \u00e9 salva no arquivo .config dentro da pasta do c\u00f3digo fonte. Example Crie um kernel com as op\u00e7\u00f5es padr\u00e3o usando o comando. $> make defconfig Example Podemos customizar as configura\u00e7\u00f5es dispon\u00edveis usando o comando abaixo. Execute-o e explore um pouco as possibilidades. $> make menuconfig Example Habilite a op\u00e7\u00e3o Linux guest support dentro de Processor Type and Features . Example Execute make -j8 para compilar seu kernel. O exerc\u00edcio acima demora em torno de 10~20 minutos. Example Verifique que foi criado o arquivo bzImage na pasta linux-X.Y.Z/arch/x86_64/boot/ . Este \u00e9 o arquivo execut\u00e1vel contendo o kernel Linux que compilamos. A biblioteca padr\u00e3o - libc \u00b6 A biblioteca padr\u00e3o C \u00e9 cont\u00e9m uma fun\u00e7\u00e3o em C para cada chamada de sistema dispon\u00edvel e interpreta os c\u00f3digos de erro, deixando-os em um formato (um pouco) mais amig\u00e1vel. Como vimos em aula, realizar chamadas de sistema \u00e9 uma tarefa que depende do hardware e por isso \u00e9 diferente em cada arquitetura (ARM vs x86, por exemplo). Logo, a libc oferece uma camada de abstra\u00e7\u00e3o maior acima do sistema operacional, j\u00e1 que programas constru\u00eddos usando suas fun\u00e7\u00e3o s\u00e3o port\u00e1veis em n\u00edvel de c\u00f3digo fonte. Ou seja, necessitando somente a recompila\u00e7\u00e3o do execut\u00e1vel para funcionar em outras plataformas. Ela tamb\u00e9m oferece as funcionalidades necess\u00e1rias para carregar dinamicamente bibliotecas .so , como vimos na aula 11. Por outro lado, al\u00e9m do kernel precisamos portar a libc tamb\u00e9m cada vez que trabalhamos com arquiteturas novas. Neste exemplo iremos usar a glibc , implementa\u00e7\u00e3o feita pela GNU e usada na maioria das distribui\u00e7\u00f5es. Desta vez n\u00e3o precisamos compilar nada: ela j\u00e1 est\u00e1 instalada no nosso sistema e podemos simplesmente us\u00e1-la na pr\u00f3xima parte. Ferramentas de modo usu\u00e1rio - busybox \u00b6 Agora que j\u00e1 temos uma interface com o kernel via glibc precisamos de programas b\u00e1sicos para utilizar nosso sistema. Estamos falando de programas como cp , ls e at\u00e9 mesmo o nosso shell ( bash ). Assim como o kernel e a libc, o padr\u00e3o POSIX tamb\u00e9m diz como esses programas dever\u00e3o funcionar, fazendo com que sua utiliza\u00e7\u00e3o b\u00e1sica seja igual em qualquer sistema compat\u00edvel. Lembre-se que o kernel n\u00e3o faz nada, ele apenas intermedia o acesso ao hardware. Precisamos ent\u00e3o de programas que ir\u00e3o tornar esse hardware \u00fatil. O busybox ( https://busybox.net/about.html ) \u00e9 um conjunto de ferramentas modo usu\u00e1rio bastante compacto e r\u00e1pido. Ele cont\u00e9m implementa\u00e7\u00f5es leves dos execut\u00e1veis ash (shell leve alternativo ao bash ), ls , vi , pwd , etc. Sua vantagem \u00e9 o baixo consumo de mem\u00f3ria e seu tamanho pequeno ap\u00f3s compilado. \u00c9 muito usado em sistemas embarcados. Vamos come\u00e7ar baixando os fontes da vers\u00e3o 1.31.1 . A compila\u00e7\u00e3o \u00e9 feita no mesmo esquema do kernel: $> make defconfig $> make menuconfig Question O busy box disponibiliza um grande n\u00famero de ferramentas. Procure no menu acima o lugar onde s\u00e3o listados os editores de texto dispon\u00edveis no busybox . Desta vez iremos fazer uma modifica\u00e7\u00e3o nas configura\u00e7\u00f5es padr\u00e3o. Como queremos que esses execut\u00e1veis pequenos, muito r\u00e1pidos e que rodem sem qualquer outro tipo de servi\u00e7o carregado no sistema, iremos compil\u00e1-los estaticamente . Example Procure a op\u00e7\u00e3o para lincar o busybox estaticamente (Submenu Settings ), habilite-a e fa\u00e7a a compila\u00e7\u00e3o. $> make -j8 Isto demorar\u00e1 bem menos que a compila\u00e7\u00e3o do kernel e pode ser feito enquanto outras coisas acontecem. Ap\u00f3s a compila\u00e7\u00e3o um execut\u00e1vel busybox dever\u00e1 ter sido gerado na pasta busybox-1.31.1 . O busybox inclui, em um s\u00f3 execut\u00e1vel, todas ferramentas listadas acima. Para execut\u00e1-las basta passar o nome da ferramenta escolhida como argumento. Veja o exemplo abaixo. $> ./busybox ls Se tudo funcionou igual ao ls padr\u00e3o de seu sistema ent\u00e3o passe para o pr\u00f3ximo passo. Example Execute busybox ls --help . Compare a sa\u00edda com ls --help . Existe diferen\u00e7a? Procure na sa\u00edda do ls do seu sistema qual a implementa\u00e7\u00e3o utilizada. Example Voc\u00ea pode obter uma lista completa de todas as ferramentas que o busybox oferece executando busybox --list-full . Execute o comando e interprete sua sa\u00edda. Esses comandos est\u00e3o dispon\u00edveis no seu sistema atual? Criando o sistema de arquivos \u00b6 Agora que j\u00e1 temos um kernel, ferramentas de modo usu\u00e1rio e uma libc dispon\u00edvel para compilar programas iremos montar a hierarquia de diret\u00f3rios do Linux. Esta \u00e9 a \u00faltima etapa que precisamos cumprir antes de ter um sistema que faz boot . Example Leia a documenta\u00e7\u00e3o do Debian]( https://wiki.debian.org/FilesystemHierarchyStandard )( https://wiki.debian.org/FilesystemHierarchyStandard ) sobre um padr\u00e3o adotado pela grande maioria das distribui\u00e7\u00f5es. Note que este n\u00e3o \u00e9 um padr\u00e3o POSIX (o macOS faz tudo isso diferente e ainda assim segue a especifica\u00e7\u00e3o). Warning A hierarquia de diret\u00f3rios n\u00e3o representa (necessariamente) um disco f\u00edsico, mas sim uma organiza\u00e7\u00e3o das informa\u00e7\u00f5es dispon\u00edveis no sistema. Podemos \"pendurar\" o conte\u00fado de um disco em basicamente qualquer diret\u00f3rio. Agora que voc\u00ea j\u00e1 conhece um pouco melhor como tudo est\u00e1 organizado em um sistema baseado em Linux, vamos come\u00e7ar criando um arquivo vazio de 100Mb que ser\u00e1 usado como nosso diret\u00f3rio raiz / . Example Crie um arquivo vazio usando dd $> dd if=/dev/zero of=raiz.img bs=1M count=100 Antes de continuar, precisamos expor o arquivo acima como um dispositivo de armazenamento para o restante do sistema. Podemos fazer isto usando um loopback device . Este tipo de dispositivo se comporta igual a um disco f\u00edsico, mas modifica os bytes de um arquivo ao inv\u00e9s de interagir com hardware. O comando losetup \u00e9 usado para fazer este servi\u00e7o. Warning Todo comando cujo prompt come\u00e7a com # dever\u00e1 ser executado como root . Voc\u00ea pode fazer isso colocando sudo na frente de todos esses comandos. #> losetup -P -f --show raiz.img Tip O comando acima mostra o n\u00famero do dispositivo criado. Agora podemos criar uma tabela de parti\u00e7\u00f5es . Esta estrutura, gravada no come\u00e7o de um disco, cont\u00e9m informa\u00e7\u00f5es que permitem identificar quais parti\u00e7\u00f5es est\u00e3o presentes, seus tamanhos e tipo. Em sua ess\u00eancia, uma parti\u00e7\u00e3o \u00e9 somente uma subdivis\u00e3o de um disco f\u00edsico. Isto ajuda, por exemplo, a instalar v\u00e1rios SOs no mesmo disco sem precisar ter um disco separado para cada sistema. Fazemos tudo isto usando o comando fdisk : #> fdisk /dev/loop0 O fdisk trabalha como um prompt de comandos. Digite m para conhecer as op\u00e7\u00f5es. Example Crie uma parti\u00e7\u00e3o (comando n ) neste disco ocupando todo o espa\u00e7o dispon\u00edvel. As op\u00e7\u00f5es padr\u00e3o do comando de criar parti\u00e7\u00f5es s\u00e3o adequadas para nosso uso. Example Use o comando p para mostrar o estado atual do disco. Certifique-se de que h\u00e1 uma parti\u00e7\u00e3o do tipo Linux que ocupe o disco todo. Anote o valor do campo Disk Identifier abaixo. Warning N\u00e3o se esque\u00e7a de usar o comando w para salvar as parti\u00e7\u00f5es criadas. Warning Em Linux um arquivo \u00e9 simplesmente uma sequ\u00eancia de bytes. Se eu pedir para o sistema interpretar esta sequ\u00eancia como um disco formatado no padr\u00e3o ext4 isto ter\u00e1 o mesmo efeito que se essa sequ\u00eancia de bytes estivesse armazenada diretamente em um disco f\u00edsico. A partir de agora, o dispositivo /dev/loop0 (ou algo similar que tenha sido retornado pelo comando acima) \u00e9 equivalente a um disco f\u00edsico. Assim como localizamos a primeira parti\u00e7\u00e3o de um disco usando /dev/sda1 , localizamos a primeira parti\u00e7\u00e3o do nosso loop device usando /dev/loop0p1 . Warning Se voc\u00ea s\u00f3 tem /dev/loop0/ e n\u00e3o possui /dev/loop0p1 ent\u00e3o houve algo errado com a cria\u00e7\u00e3o das parti\u00e7\u00f5es de seu disco. Refa\u00e7a tudo a partir do comando dd . Example Vamos agora formatar essa parti\u00e7\u00e3o e mont\u00e1-la no diret\u00f3rio raiz_linux . #> mkfs.ext4 /dev/loop0p1 #> mkdir raiz_linux #> mount -t ext4 /dev/loop0p1 raiz_linux Tudo o que for escrito na pasta raiz_linux ser\u00e1 escrito diretamente no nosso arquivo raiz.img da mesma maneira que seria escrito em um disco f\u00edsico. No nosso caso, tudo o que for colocado nesta pasta estar\u00e1 presente no diret\u00f3rio / do nosso sistema Linux. Ou seja, a pasta raiz_linux/bin no nosso sistema ser\u00e1 somente /bin . Vamos agora copiar para raiz_linux o m\u00ednimo necess\u00e1rio para conseguirmos ligar nosso sistema em um prompt de comando bash como root . V\u00e1rias coisas estar\u00e3o faltando, mas j\u00e1 conseguiremos O primeiro passo \u00e9 montar a hierarquia de arquivos descrita no primeiro exerc\u00edcio desta se\u00e7\u00e3o. A lista completa pode ser vista neste link]( https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard ). Example Crie as pastas descritas no documento acima. Verifique que todas foram criadas rodando ls -l em raiz_linux . As pastas que voc\u00ea criou dever\u00e3o ser as seguintes: drwxr-xr-x 2 root root 1024 abr 30 09:46 bin drwxr-xr-x 2 root root 1024 abr 30 09:46 boot drwxr-xr-x 2 root root 1024 abr 30 09:46 dev drwxr-xr-x 2 root root 1024 abr 30 09:46 etc drwxr-xr-x 2 root root 1024 abr 30 09:46 home drwxr-xr-x 2 root root 1024 abr 30 09:46 lib drwx------ 2 root root 12288 abr 30 09:39 lost+found drwxr-xr-x 2 root root 1024 abr 30 09:46 proc drwxr-xr-x 2 root root 1024 abr 30 09:46 root drwxr-xr-x 2 root root 1024 abr 30 09:46 run drwxr-xr-x 2 root root 1024 abr 30 09:46 sbin drwxr-xr-x 2 root root 1024 abr 30 09:46 sys drwxr-xr-x 2 root root 1024 abr 30 09:46 tmp drwxr-xr-x 7 root root 1024 abr 30 09:46 usr drwxr-xr-x 2 root root 1024 abr 30 09:46 var Example D\u00ea permiss\u00f5es totais para a pasta tmp e somente para o usu\u00e1rio dono na pasta root . #> chmod 777 tmp #> chmod 600 root Example Copie seu kernel para a pasta boot e o execut\u00e1vel do busybox para a pasta usr/bin . Como vimos anteriormente, o busybox cont\u00e9m todas as ferramentas de usu\u00e1rio em um \u00fanico execut\u00e1vel. Por\u00e9m, n\u00e3o \u00e9 nada pr\u00e1tico digitar busybox antes de todo comando . Por isso criaremos uma s\u00e9rie de links simb\u00f3licos que ligam o nome de cada ferramenta oferecida pelo busybox ao seu nome \"tradicional\". Example Execute o comando abaixo na dentro de raiz_linux . for util in $(./usr/bin/busybox --list-full); do ln -s /usr/bin/busybox $util done Example Liste os arquivos em raiz_linux/bin , raiz_linux/usr/bin e raiz_linux/sbin e veja quais programas estar\u00e3o dispon\u00edveis no nosso sistema. Example Copie hello-static e hello-dyn para a pasta raiz_linux/root . Seu primeiro boot \u00b6 Com isto j\u00e1 temos o m\u00ednimo necess\u00e1rio para dar boot no sistema, mas n\u00e3o teremos um sistema completamente funcional nem bem montado. A ideia aqui \u00e9 testar nosso progresso e entender o que falta para esse sistema, que j\u00e1 tem kernel e ferramentas de modo usu\u00e1rio , funcionar de maneira plena. Faremos todas as melhorias no sistema na parte 6. Question Pesquise o que \u00e9 um boot loader e cite a op\u00e7\u00e3o mais comum usada em sistemas linux. A instala\u00e7\u00e3o de um boot loader \u00e9 trabalhosa e cheia de possibilidades de erros. Podemos aproveitar o fato do pr\u00f3prio QEmu servir de boot loader para facilitar o desenvolvimento deste roteiro. Warning Sempre que for usar o qemu n\u00e3o se esque\u00e7a de desvincular /dev/loop0p1 de raiz_linux usando umount . Nosso comando de boot ter\u00e1 o formato abaixo: #> qemu-system-x86_64 \\ -kernel linux-X.Y.Z/arch/x86_64/boot/bzImage \\ -append \"quiet init=/bin/sh root=PARTUUID=XXXXXXXX-01\" \\ /dev/loop0 Vamos destrinchar essa chamada: -enable-kvm : habilita a virtualiza\u00e7\u00e3o por hardware, fazendo com que o sistema guest possa executar em velocidade quase real. Pode ser omitido, mas ficar\u00e1 mais lento. -kernel linux-X.Y.Z/arch/x86_64/boot/bzImage : instrui o QEmu a carregar o kernel presente no caminho passado. -append \"quiet init=/bin/sh root=PARTUUID=XXXXXXXX-01\" : estas op\u00e7\u00f5es s\u00e3o passadas para o kernel e configuram sua execu\u00e7\u00e3o quiet : minimiza mensagens de debug init=/bin/sh : aqui configuramos o processo de pid=1 . Ele \u00e9 o cara que d\u00e1 fork+exec em todos os outros processos do sistema e que d\u00e1 wait nos orf\u00e3os. Inicialmente usamos o shell, mas isso n\u00e3o \u00e9 bom. Na pr\u00f3xima parte veremos por que. root=PARTUUID=XXXXXXXX-01 : sistema de arquivos raiz est\u00e1 na parti\u00e7\u00e3o 01 do disco identificado pelo UUID que voc\u00eas obtiveram no fdisk /dev/loop0 : disco a ser colocado na m\u00e1quina virtual. O Disk Identifier dele (anotado anteriormente) est\u00e1 listado no item acima. Example Adapte o comando acima para usar o disco criado por voc\u00ea e execute-o. Se tudo der certo voc\u00ea estar\u00e1, em poucos segundos, em um prompt rodando como root . Done Voc\u00ea conseguiu seu primeiro boot! Example Tente realizar algumas tarefas nesse sistema. Voc\u00ea pode editar um arquivo ou criar pastas. Done N\u00e3o funcionou? Perfeito! Na pr\u00f3xima aula transformaremos nosso sistema capenga em um sistema m\u00ednimo e totalmente funcional. Inicializa\u00e7\u00e3o do sistema - init \u00b6 Se voc\u00ea explorou um pouco o sistema criado na parte anterior j\u00e1 deve ter notado que v\u00e1rias coisas n\u00e3o funcionam. N\u00e3o conseguimos, por exemplo, escrever em nenhum arquivo. Vamos explorar dois casos mais interessantes: Example O comando df ( disk free ) \u00e9 usado para listar o espa\u00e7o livre em todos os discos presentes no sistema. Tente execut\u00e1-lo no seu sistema. O qu\u00ea acontece? Example O comando lspci ( list pci devices ) mostra todos os perif\u00e9ricos ligados diretamente na placa m\u00e3e do seu PC. Tente execut\u00e1-lo no seu sistema. O qu\u00ea acontece? Question Consulte as pastas apontadas nos itens anteriores. Elas tem conte\u00fado? Elas deveriam ter conte\u00fado? Para conseguirmos testar logo, adicionamos ao kernel o par\u00e2metro init=/bin/sh . Este par\u00e2metro diz para o kernel abrir um shell assim que iniciar. Isto tamb\u00e9m \u00e9 fonte de nossos problemas, j\u00e1 que nosso sistema n\u00e3o inicializa automaticamente nenhum servi\u00e7o essencial para seu funcionamento. Ou seja, nosso sistema est\u00e1 capenga pois ele n\u00e3o possui um processo init , que \u00e9 respons\u00e1vel por supervisionar a cria\u00e7\u00e3o de todos os sistemas de arquivos especiais ( /proc, /sys, /dev/ ) e por iniciar servi\u00e7os essenciais para o funcionamento do sistema. Da mesma maneira, ao finalizar ele \u00e9 respons\u00e1vel por desligar todos os recursos de hardware de maneira segura. Example Al\u00e9m de ser usado para m\u00eddias remov\u00edveis, o comando mount tamb\u00e9m \u00e9 usado para criar os diret\u00f3rios especiais /proc e /sys . Rode os seguintes comandos e verifique que agora df e lspci funcionam corretamente. #> mount -t proc proc /proc -o nosuid,noexec,nodev #> mount -t sysfs sys /sys -o nosuid,noexec,nodev Question Qual o papel das pastas especias /proc e /sys em um sistema Linux? Estes comandos fazem parte da inicializa\u00e7\u00e3o normal de um sistema e exp\u00f5e estruturas do kernel para o resto do sistema via arquivos. O busybox j\u00e1 nos fornece um sistema de inicializa\u00e7\u00e3o bastante simplificado que, entre outras coisas, rodaria estes comandos automaticamente a todo boot. Aproveitaremos ele para tr\u00eas prop\u00f3sitos: executar um script de inicializa\u00e7\u00e3o que configure todos os diret\u00f3rios especiais e servi\u00e7os. adicionar servi\u00e7os que proveem uma tela de login executar um script de finaliza\u00e7\u00e3o que desliga o hardware quando o PC for desligado. Primeiro vamos copiar vers\u00f5es padr\u00e3o de todos os arquivos de configura\u00e7\u00e3o necess\u00e1rios. Os seguintes arquivos est\u00e3o na pasta configs do reposit\u00f3rio da aula. passwd, shadow, groups : listam os usu\u00e1rios e grupos presentes. shadows cont\u00e9m hashes das senha. profile : \u00e9 executado logo ap\u00f3s um login correto. Pode ser usado para configurar o terminal. issue : cont\u00e9m o nome do seu sistema mostrado na tela de login. hosts : associa um nome com alguns IPs. \u00c9 aqui que associamos localhost a 127.0.0.1 hostname : configura o nome da nossa m\u00e1quina na rede. fstab : lista todos os discos que devem ser montados al\u00e9m do rootfs . Example Copie estes arquivos para o etc do seu sistema. O sistema de init disponibilizado pelo busybox l\u00ea o arquivo /etc/inittab e o interpreta de acordo com as regras mostradas no arquivo busybox-1.30.1/examples/inittab . Iremos usar o arquivo dispon\u00edvel em configs/inittab . Question Leia o arquivo config/inittab e tente interpretar seu conte\u00fado. A primeira coluna do arquivo mostra o momento em que ela deve rodar. Vemos, por exemplo, que o script /etc/init.d/startup rodar\u00e1 ao inicializar o sistema e que toda vez que o processo /sbin/getty (terminal com login) terminar ele \u00e9 reiniciado. Tamb\u00e9m existem scripts para serem rodados ao desligar o sistema. Em especial, este arquivo /etc/init.d/startup (presente no reposit\u00f3rio como configs/init.d/startup ) cont\u00e9m comandos para configurar o sistema, incluindo os diret\u00f3rios especiais que mostramos acima. Seu conte\u00fado \u00e9 mostrado abaixo por completude. # Monta os sistemas de arquivos especiais mount -t proc proc /proc -o nosuid,noexec,nodev mount -t sysfs sys /sys -o nosuid,noexec,nodev # Configura detector de dispositivos mkdir -p /dev/pts /dev/shm mount -t tmpfs shm /dev/shm -o mode = 1777 ,nosuid,nodev mdev -s echo /sbin/mdev > /proc/sys/kernel/hotplug # Configura terminais mount -t devpts devpts /dev/pts -o mode = 0620 ,gid = 5 ,nosuid,noexec # Configura /run, que guarda algumas informa\u00e7\u00f5es de execu\u00e7\u00e3o. mount -t tmpfs run /run -o mode = 0755 ,nosuid,nodev # Atribui nome ao PC cat /etc/hostname > /proc/sys/kernel/hostname # Monta todos os sistemas de arquivos contidos em /etc/fstab mount -a mount -o remount,rw / Example Este script requer a cria\u00e7\u00e3o de um diret\u00f3rio /run . Para que ele serve? Crie-o e copie ambos arquivos acima para seu sistema. Example Modifique sua linha de comando do QEmu e retire a por\u00e7\u00e3o init=/bin/sh . Por padr\u00e3o o kernel buscar\u00e1 o execut\u00e1vel /sbin/init , que usar\u00e1 os arquivos que criamos para inicializar o sistema. Tip Se tudo deu certo voc\u00ea dever\u00e1 ter um prompt de login. Logue como root e continue o roteiro. Warning N\u00e3o se esque\u00e7a de usar umount para desmontar a pasta raiz_linux . Example Crie um arquivo dentro de seu sistema. Voc\u00ea pode usar o editor vi ou o comando touch para criar um arquivo vazio. Se n\u00e3o deu certo revise se ocorreu tudo certo na execu\u00e7\u00e3o do seu script startup rolando a tela para cima com Shift+PageUp . Example Desligue seu sistema com poweroff . Ligue-o novamente e confira se o arquivo ainda est\u00e1 l\u00e1. Parte 7 - bibliotecas e carregamento din\u00e2mico \u00b6 Quando compilamos o busybox habilitamos uma op\u00e7\u00e3o que pedia execut\u00e1veis compilados estaticamente, fazendo que o execut\u00e1vel criado n\u00e3o tenha depend\u00eancias. Vamos agora aprender a configurar nosso sistema para rodar execut\u00e1veis com depend\u00eancias. Example Copie os execut\u00e1veis hello-static e hello-dyn para sua VM. N\u00e3o se esque\u00e7a de adicionar permiss\u00f5es de execu\u00e7\u00e3o para eles. Question Tente rodar ambos execut\u00e1veis. Ambos funcionam? Anote abaixo o resultado da execu\u00e7\u00e3o de cada um. Todos os execut\u00e1veis que conseguimos rodar at\u00e9 agora foram compilados estaticamente. Quando tentamos rodar hello-dyn tivemos um erro. Question Execute (em seu sistema) ldd em hello-dyn . Anote abaixo as depend\u00eancias encontradas. Example Os arquivos acima existem na sua VM? Ao montar nosso sistema do zero n\u00e3o incluimos nenhuma biblioteca! Logo, o nosso execut\u00e1vel n\u00e3o consegue carregar as partes faltantes e n\u00e3o ir\u00e1 rodar. Felizmente, nosso sistema Linux possui a mesma arquitetura do Ubuntu instalado em nossas m\u00e1quinas e podemos copiar os arquivos necess\u00e1rios para nosso sistema! Example Copie os arquivos acima para os locais indicados na sa\u00edda de ldd . Example Teste novamente hello-dyn . Agora ele funciona? Gerenciar depend\u00eancias \u00e9 a principal atribui\u00e7\u00e3o de gerenciadores de pacotes como apt , pacman e dnf . Eles estruturam todos os softwares instal\u00e1veis em um sistema de modo que ao instalar um programa todas as suas depend\u00eancias sejam instaladas tamb\u00e9m. Done Pronto! Agora temos um sistema m\u00ednimo e funcional. Ainda faltam v\u00e1rios peda\u00e7os que normalmente comp\u00f5em um sistema, como um bootloader instalado na imagem de disco e um gerenciador de pacotes. Mas ao menos agora ele \u00e9 plenamente funcional dentro do que propomos.","title":"12 - Linux do Zero"},{"location":"aulas/12-linux-do-zero/#12-linux-do-zero","text":"","title":"12 - Linux do Zero"},{"location":"aulas/12-linux-do-zero/#tarefas-preliminares","text":"Vamos precisar dos seguintes softwares instalados no sistema. Como o resto do curso, os pacotes abaixo s\u00e3o para o Ubuntu 20.04 LTS, build-essential flex bison qemu ncurses-dev libssl-dev libelf-dev qemu-system-x86 Example Instale os pacotes acima no seu sistema usando apt . Example Crie um programa que mostra a mensagem Hello world (seu nome) . Compile-o e chame-o hello-dyn . Example Execute o comando ldd ./hello-dyn e veja sua sa\u00edda. O comando ldd \u00e9 usado para listar todas as bibliotecas din\u00e2micas usadas por um execut\u00e1vel. Antes de rodar hello-dyn o Linux garante que todos os arquivos listados no exerc\u00edcio anterior est\u00e3o carregados na mem\u00f3ria tamb\u00e9m. Por esta raz\u00e3o, cada arquivo .so listado \u00e9 chamado de depend\u00eancia de hello-dyn . Example Vamos agora usar a flag -static do gcc para embutir todos os arquivos acima em um \u00fanico execut\u00e1vel. Crie um novo execut\u00e1vel hello-static . Example Execute ambos e veja que eles possuem o mesmo resultado. Example Execute ldd no arquivo hello-static e verifique que ele n\u00e3o tem nenhuma depend\u00eancia. Vamos usar ambos programas mais para a frente do roteiro.","title":"Tarefas preliminares"},{"location":"aulas/12-linux-do-zero/#compilando-o-kernel","text":"Vamos primeiro fazer o download do kernel do Linux no site oficial ( https://www.kernel.org/ ). Podem baixar a vers\u00e3o mais recente (atualmente 5.9 ) Example Decompacte o arquivo baixado e examine os arquivos na pasta criada. $> tar xvf linux-X.Y.Z.tar.xz Isto criar\u00e1 uma pasta linux-X.Y.Z que cont\u00e9m os fontes de todo o kernel. O kernel pode ser compilado com uma quantidade enorme de configura\u00e7\u00f5es diferentes, sendo que a configura\u00e7\u00e3o atual \u00e9 salva no arquivo .config dentro da pasta do c\u00f3digo fonte. Example Crie um kernel com as op\u00e7\u00f5es padr\u00e3o usando o comando. $> make defconfig Example Podemos customizar as configura\u00e7\u00f5es dispon\u00edveis usando o comando abaixo. Execute-o e explore um pouco as possibilidades. $> make menuconfig Example Habilite a op\u00e7\u00e3o Linux guest support dentro de Processor Type and Features . Example Execute make -j8 para compilar seu kernel. O exerc\u00edcio acima demora em torno de 10~20 minutos. Example Verifique que foi criado o arquivo bzImage na pasta linux-X.Y.Z/arch/x86_64/boot/ . Este \u00e9 o arquivo execut\u00e1vel contendo o kernel Linux que compilamos.","title":"Compilando o kernel"},{"location":"aulas/12-linux-do-zero/#a-biblioteca-padrao-libc","text":"A biblioteca padr\u00e3o C \u00e9 cont\u00e9m uma fun\u00e7\u00e3o em C para cada chamada de sistema dispon\u00edvel e interpreta os c\u00f3digos de erro, deixando-os em um formato (um pouco) mais amig\u00e1vel. Como vimos em aula, realizar chamadas de sistema \u00e9 uma tarefa que depende do hardware e por isso \u00e9 diferente em cada arquitetura (ARM vs x86, por exemplo). Logo, a libc oferece uma camada de abstra\u00e7\u00e3o maior acima do sistema operacional, j\u00e1 que programas constru\u00eddos usando suas fun\u00e7\u00e3o s\u00e3o port\u00e1veis em n\u00edvel de c\u00f3digo fonte. Ou seja, necessitando somente a recompila\u00e7\u00e3o do execut\u00e1vel para funcionar em outras plataformas. Ela tamb\u00e9m oferece as funcionalidades necess\u00e1rias para carregar dinamicamente bibliotecas .so , como vimos na aula 11. Por outro lado, al\u00e9m do kernel precisamos portar a libc tamb\u00e9m cada vez que trabalhamos com arquiteturas novas. Neste exemplo iremos usar a glibc , implementa\u00e7\u00e3o feita pela GNU e usada na maioria das distribui\u00e7\u00f5es. Desta vez n\u00e3o precisamos compilar nada: ela j\u00e1 est\u00e1 instalada no nosso sistema e podemos simplesmente us\u00e1-la na pr\u00f3xima parte.","title":"A biblioteca padr\u00e3o - libc"},{"location":"aulas/12-linux-do-zero/#ferramentas-de-modo-usuario-busybox","text":"Agora que j\u00e1 temos uma interface com o kernel via glibc precisamos de programas b\u00e1sicos para utilizar nosso sistema. Estamos falando de programas como cp , ls e at\u00e9 mesmo o nosso shell ( bash ). Assim como o kernel e a libc, o padr\u00e3o POSIX tamb\u00e9m diz como esses programas dever\u00e3o funcionar, fazendo com que sua utiliza\u00e7\u00e3o b\u00e1sica seja igual em qualquer sistema compat\u00edvel. Lembre-se que o kernel n\u00e3o faz nada, ele apenas intermedia o acesso ao hardware. Precisamos ent\u00e3o de programas que ir\u00e3o tornar esse hardware \u00fatil. O busybox ( https://busybox.net/about.html ) \u00e9 um conjunto de ferramentas modo usu\u00e1rio bastante compacto e r\u00e1pido. Ele cont\u00e9m implementa\u00e7\u00f5es leves dos execut\u00e1veis ash (shell leve alternativo ao bash ), ls , vi , pwd , etc. Sua vantagem \u00e9 o baixo consumo de mem\u00f3ria e seu tamanho pequeno ap\u00f3s compilado. \u00c9 muito usado em sistemas embarcados. Vamos come\u00e7ar baixando os fontes da vers\u00e3o 1.31.1 . A compila\u00e7\u00e3o \u00e9 feita no mesmo esquema do kernel: $> make defconfig $> make menuconfig Question O busy box disponibiliza um grande n\u00famero de ferramentas. Procure no menu acima o lugar onde s\u00e3o listados os editores de texto dispon\u00edveis no busybox . Desta vez iremos fazer uma modifica\u00e7\u00e3o nas configura\u00e7\u00f5es padr\u00e3o. Como queremos que esses execut\u00e1veis pequenos, muito r\u00e1pidos e que rodem sem qualquer outro tipo de servi\u00e7o carregado no sistema, iremos compil\u00e1-los estaticamente . Example Procure a op\u00e7\u00e3o para lincar o busybox estaticamente (Submenu Settings ), habilite-a e fa\u00e7a a compila\u00e7\u00e3o. $> make -j8 Isto demorar\u00e1 bem menos que a compila\u00e7\u00e3o do kernel e pode ser feito enquanto outras coisas acontecem. Ap\u00f3s a compila\u00e7\u00e3o um execut\u00e1vel busybox dever\u00e1 ter sido gerado na pasta busybox-1.31.1 . O busybox inclui, em um s\u00f3 execut\u00e1vel, todas ferramentas listadas acima. Para execut\u00e1-las basta passar o nome da ferramenta escolhida como argumento. Veja o exemplo abaixo. $> ./busybox ls Se tudo funcionou igual ao ls padr\u00e3o de seu sistema ent\u00e3o passe para o pr\u00f3ximo passo. Example Execute busybox ls --help . Compare a sa\u00edda com ls --help . Existe diferen\u00e7a? Procure na sa\u00edda do ls do seu sistema qual a implementa\u00e7\u00e3o utilizada. Example Voc\u00ea pode obter uma lista completa de todas as ferramentas que o busybox oferece executando busybox --list-full . Execute o comando e interprete sua sa\u00edda. Esses comandos est\u00e3o dispon\u00edveis no seu sistema atual?","title":"Ferramentas de modo usu\u00e1rio - busybox"},{"location":"aulas/12-linux-do-zero/#criando-o-sistema-de-arquivos","text":"Agora que j\u00e1 temos um kernel, ferramentas de modo usu\u00e1rio e uma libc dispon\u00edvel para compilar programas iremos montar a hierarquia de diret\u00f3rios do Linux. Esta \u00e9 a \u00faltima etapa que precisamos cumprir antes de ter um sistema que faz boot . Example Leia a documenta\u00e7\u00e3o do Debian]( https://wiki.debian.org/FilesystemHierarchyStandard )( https://wiki.debian.org/FilesystemHierarchyStandard ) sobre um padr\u00e3o adotado pela grande maioria das distribui\u00e7\u00f5es. Note que este n\u00e3o \u00e9 um padr\u00e3o POSIX (o macOS faz tudo isso diferente e ainda assim segue a especifica\u00e7\u00e3o). Warning A hierarquia de diret\u00f3rios n\u00e3o representa (necessariamente) um disco f\u00edsico, mas sim uma organiza\u00e7\u00e3o das informa\u00e7\u00f5es dispon\u00edveis no sistema. Podemos \"pendurar\" o conte\u00fado de um disco em basicamente qualquer diret\u00f3rio. Agora que voc\u00ea j\u00e1 conhece um pouco melhor como tudo est\u00e1 organizado em um sistema baseado em Linux, vamos come\u00e7ar criando um arquivo vazio de 100Mb que ser\u00e1 usado como nosso diret\u00f3rio raiz / . Example Crie um arquivo vazio usando dd $> dd if=/dev/zero of=raiz.img bs=1M count=100 Antes de continuar, precisamos expor o arquivo acima como um dispositivo de armazenamento para o restante do sistema. Podemos fazer isto usando um loopback device . Este tipo de dispositivo se comporta igual a um disco f\u00edsico, mas modifica os bytes de um arquivo ao inv\u00e9s de interagir com hardware. O comando losetup \u00e9 usado para fazer este servi\u00e7o. Warning Todo comando cujo prompt come\u00e7a com # dever\u00e1 ser executado como root . Voc\u00ea pode fazer isso colocando sudo na frente de todos esses comandos. #> losetup -P -f --show raiz.img Tip O comando acima mostra o n\u00famero do dispositivo criado. Agora podemos criar uma tabela de parti\u00e7\u00f5es . Esta estrutura, gravada no come\u00e7o de um disco, cont\u00e9m informa\u00e7\u00f5es que permitem identificar quais parti\u00e7\u00f5es est\u00e3o presentes, seus tamanhos e tipo. Em sua ess\u00eancia, uma parti\u00e7\u00e3o \u00e9 somente uma subdivis\u00e3o de um disco f\u00edsico. Isto ajuda, por exemplo, a instalar v\u00e1rios SOs no mesmo disco sem precisar ter um disco separado para cada sistema. Fazemos tudo isto usando o comando fdisk : #> fdisk /dev/loop0 O fdisk trabalha como um prompt de comandos. Digite m para conhecer as op\u00e7\u00f5es. Example Crie uma parti\u00e7\u00e3o (comando n ) neste disco ocupando todo o espa\u00e7o dispon\u00edvel. As op\u00e7\u00f5es padr\u00e3o do comando de criar parti\u00e7\u00f5es s\u00e3o adequadas para nosso uso. Example Use o comando p para mostrar o estado atual do disco. Certifique-se de que h\u00e1 uma parti\u00e7\u00e3o do tipo Linux que ocupe o disco todo. Anote o valor do campo Disk Identifier abaixo. Warning N\u00e3o se esque\u00e7a de usar o comando w para salvar as parti\u00e7\u00f5es criadas. Warning Em Linux um arquivo \u00e9 simplesmente uma sequ\u00eancia de bytes. Se eu pedir para o sistema interpretar esta sequ\u00eancia como um disco formatado no padr\u00e3o ext4 isto ter\u00e1 o mesmo efeito que se essa sequ\u00eancia de bytes estivesse armazenada diretamente em um disco f\u00edsico. A partir de agora, o dispositivo /dev/loop0 (ou algo similar que tenha sido retornado pelo comando acima) \u00e9 equivalente a um disco f\u00edsico. Assim como localizamos a primeira parti\u00e7\u00e3o de um disco usando /dev/sda1 , localizamos a primeira parti\u00e7\u00e3o do nosso loop device usando /dev/loop0p1 . Warning Se voc\u00ea s\u00f3 tem /dev/loop0/ e n\u00e3o possui /dev/loop0p1 ent\u00e3o houve algo errado com a cria\u00e7\u00e3o das parti\u00e7\u00f5es de seu disco. Refa\u00e7a tudo a partir do comando dd . Example Vamos agora formatar essa parti\u00e7\u00e3o e mont\u00e1-la no diret\u00f3rio raiz_linux . #> mkfs.ext4 /dev/loop0p1 #> mkdir raiz_linux #> mount -t ext4 /dev/loop0p1 raiz_linux Tudo o que for escrito na pasta raiz_linux ser\u00e1 escrito diretamente no nosso arquivo raiz.img da mesma maneira que seria escrito em um disco f\u00edsico. No nosso caso, tudo o que for colocado nesta pasta estar\u00e1 presente no diret\u00f3rio / do nosso sistema Linux. Ou seja, a pasta raiz_linux/bin no nosso sistema ser\u00e1 somente /bin . Vamos agora copiar para raiz_linux o m\u00ednimo necess\u00e1rio para conseguirmos ligar nosso sistema em um prompt de comando bash como root . V\u00e1rias coisas estar\u00e3o faltando, mas j\u00e1 conseguiremos O primeiro passo \u00e9 montar a hierarquia de arquivos descrita no primeiro exerc\u00edcio desta se\u00e7\u00e3o. A lista completa pode ser vista neste link]( https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard ). Example Crie as pastas descritas no documento acima. Verifique que todas foram criadas rodando ls -l em raiz_linux . As pastas que voc\u00ea criou dever\u00e3o ser as seguintes: drwxr-xr-x 2 root root 1024 abr 30 09:46 bin drwxr-xr-x 2 root root 1024 abr 30 09:46 boot drwxr-xr-x 2 root root 1024 abr 30 09:46 dev drwxr-xr-x 2 root root 1024 abr 30 09:46 etc drwxr-xr-x 2 root root 1024 abr 30 09:46 home drwxr-xr-x 2 root root 1024 abr 30 09:46 lib drwx------ 2 root root 12288 abr 30 09:39 lost+found drwxr-xr-x 2 root root 1024 abr 30 09:46 proc drwxr-xr-x 2 root root 1024 abr 30 09:46 root drwxr-xr-x 2 root root 1024 abr 30 09:46 run drwxr-xr-x 2 root root 1024 abr 30 09:46 sbin drwxr-xr-x 2 root root 1024 abr 30 09:46 sys drwxr-xr-x 2 root root 1024 abr 30 09:46 tmp drwxr-xr-x 7 root root 1024 abr 30 09:46 usr drwxr-xr-x 2 root root 1024 abr 30 09:46 var Example D\u00ea permiss\u00f5es totais para a pasta tmp e somente para o usu\u00e1rio dono na pasta root . #> chmod 777 tmp #> chmod 600 root Example Copie seu kernel para a pasta boot e o execut\u00e1vel do busybox para a pasta usr/bin . Como vimos anteriormente, o busybox cont\u00e9m todas as ferramentas de usu\u00e1rio em um \u00fanico execut\u00e1vel. Por\u00e9m, n\u00e3o \u00e9 nada pr\u00e1tico digitar busybox antes de todo comando . Por isso criaremos uma s\u00e9rie de links simb\u00f3licos que ligam o nome de cada ferramenta oferecida pelo busybox ao seu nome \"tradicional\". Example Execute o comando abaixo na dentro de raiz_linux . for util in $(./usr/bin/busybox --list-full); do ln -s /usr/bin/busybox $util done Example Liste os arquivos em raiz_linux/bin , raiz_linux/usr/bin e raiz_linux/sbin e veja quais programas estar\u00e3o dispon\u00edveis no nosso sistema. Example Copie hello-static e hello-dyn para a pasta raiz_linux/root .","title":"Criando o sistema de arquivos"},{"location":"aulas/12-linux-do-zero/#seu-primeiro-boot","text":"Com isto j\u00e1 temos o m\u00ednimo necess\u00e1rio para dar boot no sistema, mas n\u00e3o teremos um sistema completamente funcional nem bem montado. A ideia aqui \u00e9 testar nosso progresso e entender o que falta para esse sistema, que j\u00e1 tem kernel e ferramentas de modo usu\u00e1rio , funcionar de maneira plena. Faremos todas as melhorias no sistema na parte 6. Question Pesquise o que \u00e9 um boot loader e cite a op\u00e7\u00e3o mais comum usada em sistemas linux. A instala\u00e7\u00e3o de um boot loader \u00e9 trabalhosa e cheia de possibilidades de erros. Podemos aproveitar o fato do pr\u00f3prio QEmu servir de boot loader para facilitar o desenvolvimento deste roteiro. Warning Sempre que for usar o qemu n\u00e3o se esque\u00e7a de desvincular /dev/loop0p1 de raiz_linux usando umount . Nosso comando de boot ter\u00e1 o formato abaixo: #> qemu-system-x86_64 \\ -kernel linux-X.Y.Z/arch/x86_64/boot/bzImage \\ -append \"quiet init=/bin/sh root=PARTUUID=XXXXXXXX-01\" \\ /dev/loop0 Vamos destrinchar essa chamada: -enable-kvm : habilita a virtualiza\u00e7\u00e3o por hardware, fazendo com que o sistema guest possa executar em velocidade quase real. Pode ser omitido, mas ficar\u00e1 mais lento. -kernel linux-X.Y.Z/arch/x86_64/boot/bzImage : instrui o QEmu a carregar o kernel presente no caminho passado. -append \"quiet init=/bin/sh root=PARTUUID=XXXXXXXX-01\" : estas op\u00e7\u00f5es s\u00e3o passadas para o kernel e configuram sua execu\u00e7\u00e3o quiet : minimiza mensagens de debug init=/bin/sh : aqui configuramos o processo de pid=1 . Ele \u00e9 o cara que d\u00e1 fork+exec em todos os outros processos do sistema e que d\u00e1 wait nos orf\u00e3os. Inicialmente usamos o shell, mas isso n\u00e3o \u00e9 bom. Na pr\u00f3xima parte veremos por que. root=PARTUUID=XXXXXXXX-01 : sistema de arquivos raiz est\u00e1 na parti\u00e7\u00e3o 01 do disco identificado pelo UUID que voc\u00eas obtiveram no fdisk /dev/loop0 : disco a ser colocado na m\u00e1quina virtual. O Disk Identifier dele (anotado anteriormente) est\u00e1 listado no item acima. Example Adapte o comando acima para usar o disco criado por voc\u00ea e execute-o. Se tudo der certo voc\u00ea estar\u00e1, em poucos segundos, em um prompt rodando como root . Done Voc\u00ea conseguiu seu primeiro boot! Example Tente realizar algumas tarefas nesse sistema. Voc\u00ea pode editar um arquivo ou criar pastas. Done N\u00e3o funcionou? Perfeito! Na pr\u00f3xima aula transformaremos nosso sistema capenga em um sistema m\u00ednimo e totalmente funcional.","title":"Seu primeiro boot"},{"location":"aulas/12-linux-do-zero/#inicializacao-do-sistema-init","text":"Se voc\u00ea explorou um pouco o sistema criado na parte anterior j\u00e1 deve ter notado que v\u00e1rias coisas n\u00e3o funcionam. N\u00e3o conseguimos, por exemplo, escrever em nenhum arquivo. Vamos explorar dois casos mais interessantes: Example O comando df ( disk free ) \u00e9 usado para listar o espa\u00e7o livre em todos os discos presentes no sistema. Tente execut\u00e1-lo no seu sistema. O qu\u00ea acontece? Example O comando lspci ( list pci devices ) mostra todos os perif\u00e9ricos ligados diretamente na placa m\u00e3e do seu PC. Tente execut\u00e1-lo no seu sistema. O qu\u00ea acontece? Question Consulte as pastas apontadas nos itens anteriores. Elas tem conte\u00fado? Elas deveriam ter conte\u00fado? Para conseguirmos testar logo, adicionamos ao kernel o par\u00e2metro init=/bin/sh . Este par\u00e2metro diz para o kernel abrir um shell assim que iniciar. Isto tamb\u00e9m \u00e9 fonte de nossos problemas, j\u00e1 que nosso sistema n\u00e3o inicializa automaticamente nenhum servi\u00e7o essencial para seu funcionamento. Ou seja, nosso sistema est\u00e1 capenga pois ele n\u00e3o possui um processo init , que \u00e9 respons\u00e1vel por supervisionar a cria\u00e7\u00e3o de todos os sistemas de arquivos especiais ( /proc, /sys, /dev/ ) e por iniciar servi\u00e7os essenciais para o funcionamento do sistema. Da mesma maneira, ao finalizar ele \u00e9 respons\u00e1vel por desligar todos os recursos de hardware de maneira segura. Example Al\u00e9m de ser usado para m\u00eddias remov\u00edveis, o comando mount tamb\u00e9m \u00e9 usado para criar os diret\u00f3rios especiais /proc e /sys . Rode os seguintes comandos e verifique que agora df e lspci funcionam corretamente. #> mount -t proc proc /proc -o nosuid,noexec,nodev #> mount -t sysfs sys /sys -o nosuid,noexec,nodev Question Qual o papel das pastas especias /proc e /sys em um sistema Linux? Estes comandos fazem parte da inicializa\u00e7\u00e3o normal de um sistema e exp\u00f5e estruturas do kernel para o resto do sistema via arquivos. O busybox j\u00e1 nos fornece um sistema de inicializa\u00e7\u00e3o bastante simplificado que, entre outras coisas, rodaria estes comandos automaticamente a todo boot. Aproveitaremos ele para tr\u00eas prop\u00f3sitos: executar um script de inicializa\u00e7\u00e3o que configure todos os diret\u00f3rios especiais e servi\u00e7os. adicionar servi\u00e7os que proveem uma tela de login executar um script de finaliza\u00e7\u00e3o que desliga o hardware quando o PC for desligado. Primeiro vamos copiar vers\u00f5es padr\u00e3o de todos os arquivos de configura\u00e7\u00e3o necess\u00e1rios. Os seguintes arquivos est\u00e3o na pasta configs do reposit\u00f3rio da aula. passwd, shadow, groups : listam os usu\u00e1rios e grupos presentes. shadows cont\u00e9m hashes das senha. profile : \u00e9 executado logo ap\u00f3s um login correto. Pode ser usado para configurar o terminal. issue : cont\u00e9m o nome do seu sistema mostrado na tela de login. hosts : associa um nome com alguns IPs. \u00c9 aqui que associamos localhost a 127.0.0.1 hostname : configura o nome da nossa m\u00e1quina na rede. fstab : lista todos os discos que devem ser montados al\u00e9m do rootfs . Example Copie estes arquivos para o etc do seu sistema. O sistema de init disponibilizado pelo busybox l\u00ea o arquivo /etc/inittab e o interpreta de acordo com as regras mostradas no arquivo busybox-1.30.1/examples/inittab . Iremos usar o arquivo dispon\u00edvel em configs/inittab . Question Leia o arquivo config/inittab e tente interpretar seu conte\u00fado. A primeira coluna do arquivo mostra o momento em que ela deve rodar. Vemos, por exemplo, que o script /etc/init.d/startup rodar\u00e1 ao inicializar o sistema e que toda vez que o processo /sbin/getty (terminal com login) terminar ele \u00e9 reiniciado. Tamb\u00e9m existem scripts para serem rodados ao desligar o sistema. Em especial, este arquivo /etc/init.d/startup (presente no reposit\u00f3rio como configs/init.d/startup ) cont\u00e9m comandos para configurar o sistema, incluindo os diret\u00f3rios especiais que mostramos acima. Seu conte\u00fado \u00e9 mostrado abaixo por completude. # Monta os sistemas de arquivos especiais mount -t proc proc /proc -o nosuid,noexec,nodev mount -t sysfs sys /sys -o nosuid,noexec,nodev # Configura detector de dispositivos mkdir -p /dev/pts /dev/shm mount -t tmpfs shm /dev/shm -o mode = 1777 ,nosuid,nodev mdev -s echo /sbin/mdev > /proc/sys/kernel/hotplug # Configura terminais mount -t devpts devpts /dev/pts -o mode = 0620 ,gid = 5 ,nosuid,noexec # Configura /run, que guarda algumas informa\u00e7\u00f5es de execu\u00e7\u00e3o. mount -t tmpfs run /run -o mode = 0755 ,nosuid,nodev # Atribui nome ao PC cat /etc/hostname > /proc/sys/kernel/hostname # Monta todos os sistemas de arquivos contidos em /etc/fstab mount -a mount -o remount,rw / Example Este script requer a cria\u00e7\u00e3o de um diret\u00f3rio /run . Para que ele serve? Crie-o e copie ambos arquivos acima para seu sistema. Example Modifique sua linha de comando do QEmu e retire a por\u00e7\u00e3o init=/bin/sh . Por padr\u00e3o o kernel buscar\u00e1 o execut\u00e1vel /sbin/init , que usar\u00e1 os arquivos que criamos para inicializar o sistema. Tip Se tudo deu certo voc\u00ea dever\u00e1 ter um prompt de login. Logue como root e continue o roteiro. Warning N\u00e3o se esque\u00e7a de usar umount para desmontar a pasta raiz_linux . Example Crie um arquivo dentro de seu sistema. Voc\u00ea pode usar o editor vi ou o comando touch para criar um arquivo vazio. Se n\u00e3o deu certo revise se ocorreu tudo certo na execu\u00e7\u00e3o do seu script startup rolando a tela para cima com Shift+PageUp . Example Desligue seu sistema com poweroff . Ligue-o novamente e confira se o arquivo ainda est\u00e1 l\u00e1.","title":"Inicializa\u00e7\u00e3o do sistema - init"},{"location":"aulas/12-linux-do-zero/#parte-7-bibliotecas-e-carregamento-dinamico","text":"Quando compilamos o busybox habilitamos uma op\u00e7\u00e3o que pedia execut\u00e1veis compilados estaticamente, fazendo que o execut\u00e1vel criado n\u00e3o tenha depend\u00eancias. Vamos agora aprender a configurar nosso sistema para rodar execut\u00e1veis com depend\u00eancias. Example Copie os execut\u00e1veis hello-static e hello-dyn para sua VM. N\u00e3o se esque\u00e7a de adicionar permiss\u00f5es de execu\u00e7\u00e3o para eles. Question Tente rodar ambos execut\u00e1veis. Ambos funcionam? Anote abaixo o resultado da execu\u00e7\u00e3o de cada um. Todos os execut\u00e1veis que conseguimos rodar at\u00e9 agora foram compilados estaticamente. Quando tentamos rodar hello-dyn tivemos um erro. Question Execute (em seu sistema) ldd em hello-dyn . Anote abaixo as depend\u00eancias encontradas. Example Os arquivos acima existem na sua VM? Ao montar nosso sistema do zero n\u00e3o incluimos nenhuma biblioteca! Logo, o nosso execut\u00e1vel n\u00e3o consegue carregar as partes faltantes e n\u00e3o ir\u00e1 rodar. Felizmente, nosso sistema Linux possui a mesma arquitetura do Ubuntu instalado em nossas m\u00e1quinas e podemos copiar os arquivos necess\u00e1rios para nosso sistema! Example Copie os arquivos acima para os locais indicados na sa\u00edda de ldd . Example Teste novamente hello-dyn . Agora ele funciona? Gerenciar depend\u00eancias \u00e9 a principal atribui\u00e7\u00e3o de gerenciadores de pacotes como apt , pacman e dnf . Eles estruturam todos os softwares instal\u00e1veis em um sistema de modo que ao instalar um programa todas as suas depend\u00eancias sejam instaladas tamb\u00e9m. Done Pronto! Agora temos um sistema m\u00ednimo e funcional. Ainda faltam v\u00e1rios peda\u00e7os que normalmente comp\u00f5em um sistema, como um bootloader instalado na imagem de disco e um gerenciador de pacotes. Mas ao menos agora ele \u00e9 plenamente funcional dentro do que propomos.","title":"Parte 7 - bibliotecas e carregamento din\u00e2mico"},{"location":"aulas/13-entrada-saida/","text":"13 - Entrada/Sa\u00edda \u00b6 Trabalhando com arquivos \u00b6 Nesta se\u00e7\u00e3o trabalharemos com as chamadas open , close , read e write . Question Leia o c\u00f3digo do arquivo exemplo_io1.c . O qu\u00ea ele faz? Vamos agora usar o comando man para ver a documenta\u00e7\u00e3o das chamadas de sistema do Linux. Digite no terminal man read . A tela mostrada cont\u00e9m a documenta\u00e7\u00e3o da fun\u00e7\u00e3o read , incluindo sua assinatura e quais cabe\u00e7alhos devem ser inclu\u00eddos para que ela possa ser usada. Question Usando como apoio a documenta\u00e7\u00e3o aberta pelo comando man , como saber que um arquivo foi lido at\u00e9 o fim? Dica : a se\u00e7\u00e3o RETURN VALUE pode te ajudar. Tip Para acelerar suas buscas no man voc\u00ea pode ativar a busca pressinando / . A\u00ed basta digitar o termo procurado. Para avan\u00e7ar para as pr\u00f3ximas ocorr\u00eancias de um termo basta apertar / + Enter . Example Baseado em sua resposta acima, modifique exemplo_io1.c para que ele mostre o arquivo inteiro. Para ficar melhor de visualizar o resultado, fa\u00e7a o printf interno mostrar somente o caractere lido. Vamos agora trabalhar com a chamada write . Um exemplo de seu uso est\u00e1 mostrado no arquivo exemplo_io2.c . Question Abra o arquivo exemplo_io2.c e explique abaixo como usar write . Example Crie um programa copy_file que l\u00ea dois nomes de arquivos usando scanf e copia o conte\u00fado do primeiro para o segundo. Ou seja, voc\u00ea dever\u00e1 abrir ambos arquivos (cada um ter\u00e1 seu pr\u00f3prio file descriptor ), ler do primeiro para um buffer e escrever este buffer no segundo. Extra \u00b6 Estes exerc\u00edcios n\u00e3o ter\u00e3o corre\u00e7\u00e3o durante a aula e devem ser checados no atendimento. Fa\u00e7a-os se voc\u00ea j\u00e1 acabou os anteriores e a corre\u00e7\u00e3o/discuss\u00e3o ainda n\u00e3o come\u00e7ou. At\u00e9 agora trabalhamos com um buffer com somente um caractere. Isso facilita a programa\u00e7\u00e3o, mas deixa nosso c\u00f3digo muito lento. Example Modifique o copy_file para usar um buffer de 100 caracteres. Me\u00e7a o tempo de execu\u00e7\u00e3o para a c\u00f3pia de um arquivo grande (~100Mb) usando o comando time . N\u00e3o se esque\u00e7a de verificar que os resultados ficaram iguais com o comando diff . Warning N\u00e3o sabe como usar time ou diff ? Use o comando man visto acima. N\u00e3o sabe usar man ? Use o comando man para aprender a us\u00e1-lo com man man Question Use o manual para entender o significado dos tempos mostrados pelo comando time . Escreva abaixo seu entendimento. Question Voc\u00ea consegue explicar a diferen\u00e7a de desempenho entre as duas vers\u00f5es? Permiss\u00f5es e posse de arquivos \u00b6 No exemplo_io2.c passamos algumas op\u00e7\u00f5es extras para poder criar o arquivo: int fd1 = open ( arq1 , O_WRONLY | O_CREAT , 0700 ); A flag O_CREAT \u00e9 usada para indicar que o arquivo deve ser criado caso ele n\u00e3o exista. O n\u00famero 0700 representa os bits de acesso visto na expositiva. Cada d\u00edgito cont\u00e9m 3 d\u00edgitos que representam as seguintes permiss\u00f5es 4 - permiss\u00e3o de leitura 2 - permiss\u00e3o de escrita 1 - permiss\u00e3o de execu\u00e7\u00e3o O primeiro d\u00edgito cont\u00e9m as permiss\u00f5es do usu\u00e1rio dono do arquivo. O segundo d\u00edgito cont\u00e9m as permiss\u00f5es do grupo dono do arquivo. Usu\u00e1rios que pertencem a este grupo possuem estas permiss\u00f5es. O terceiro d\u00edgito lista as permiss\u00f5es para todos os outros usu\u00e1rios. Question Use ls -l na pasta do arquivo criado por copy_file (ou por exemplo_io2 ). Onde \u00e9 poss\u00edvel obter as informa\u00e7\u00f5es de permiss\u00f5es do arquivo? Qual o usu\u00e1rio e grupo donos do arquivo? As permiss\u00f5es passadas para o open foram corretamente colocadas no arquivo? Question Quais permiss\u00f5es s\u00e3o garantidas pela m\u00e1scara 640 ? \u00c9 uma boa ideia us\u00e1-la? \\vspace{5em} Question Qual m\u00e1scara usaria se quisesse que um arquivo possa ser modificado somente por seu dono, mas possa ser executado por qualquer usu\u00e1rio do sistema (incluindo o dono do arquivo)? Justifique. Question Rode o comando copy_file usando sudo . Use ls -l para listar as informa\u00e7\u00f5es do arquivo. Escreva abaixo quem \u00e9 seu dono e suas permiss\u00f5es de acesso. Example Use os comandos chown para mudar o dono do arquivo para seu usu\u00e1rio e chmod para deixar suas permiss\u00f5es como leitura e escrita para voc\u00ea e somente leitura para o restante. Dica : n\u00e3o sabe como usar os comandos acima? Use man . Extra \u00b6 Estes exerc\u00edcios trabalham com o conceito de posse de arquivos e de sobrescrita de arquivos j\u00e1 existentes. Question Tente usar copy_file usando como fonte algum arquivo que voc\u00ea n\u00e3o possui acesso de leitura (voc\u00ea pode cri\u00e1-lo e depois usar chmod para editar os acessos). O qu\u00ea ocorre? Voc\u00ea consegue explicar este comportamento? Example Conserte o erro ocorrido acima checando a sa\u00edda de open . Consulte o manual caso necess\u00e1rio. N\u00e3o se esque\u00e7a de faz\u00ea-lo para o arquivo fonte e destino. Question Vamos realizar um experimento neste exerc\u00edcio: Crie um arquivo com 100 caracteres a e chame-o de 100a ; Crie um arquivo com 3 caracteres b e chame-o de 3b ; Use copy_file para copiar 3b em cima de 100a ; Mostre o conte\u00fado do arquivo sobrescrito 100a . Voc\u00ea consegue explicar o que ocorreu? Se sim, busque no manual uma flag que, ao ser passada para o open , evita que isto ocorra. Example O copy_file sobrescreve arquivos sem d\u00f3. Use o manual para encontrar a flag que faz open falhar caso o arquivo de destino j\u00e1 exista e conserte seu programa para perguntar se o usu\u00e1rio deseja sobrescrever o arquivo. Note que isto conflita com seu exerc\u00edcio 6. Entenda como usar errno para que voc\u00ea consiga diferenciar os dois tipos de erros.","title":"13 - Entrada/Sa\u00edda"},{"location":"aulas/13-entrada-saida/#13-entradasaida","text":"","title":"13 - Entrada/Sa\u00edda"},{"location":"aulas/13-entrada-saida/#trabalhando-com-arquivos","text":"Nesta se\u00e7\u00e3o trabalharemos com as chamadas open , close , read e write . Question Leia o c\u00f3digo do arquivo exemplo_io1.c . O qu\u00ea ele faz? Vamos agora usar o comando man para ver a documenta\u00e7\u00e3o das chamadas de sistema do Linux. Digite no terminal man read . A tela mostrada cont\u00e9m a documenta\u00e7\u00e3o da fun\u00e7\u00e3o read , incluindo sua assinatura e quais cabe\u00e7alhos devem ser inclu\u00eddos para que ela possa ser usada. Question Usando como apoio a documenta\u00e7\u00e3o aberta pelo comando man , como saber que um arquivo foi lido at\u00e9 o fim? Dica : a se\u00e7\u00e3o RETURN VALUE pode te ajudar. Tip Para acelerar suas buscas no man voc\u00ea pode ativar a busca pressinando / . A\u00ed basta digitar o termo procurado. Para avan\u00e7ar para as pr\u00f3ximas ocorr\u00eancias de um termo basta apertar / + Enter . Example Baseado em sua resposta acima, modifique exemplo_io1.c para que ele mostre o arquivo inteiro. Para ficar melhor de visualizar o resultado, fa\u00e7a o printf interno mostrar somente o caractere lido. Vamos agora trabalhar com a chamada write . Um exemplo de seu uso est\u00e1 mostrado no arquivo exemplo_io2.c . Question Abra o arquivo exemplo_io2.c e explique abaixo como usar write . Example Crie um programa copy_file que l\u00ea dois nomes de arquivos usando scanf e copia o conte\u00fado do primeiro para o segundo. Ou seja, voc\u00ea dever\u00e1 abrir ambos arquivos (cada um ter\u00e1 seu pr\u00f3prio file descriptor ), ler do primeiro para um buffer e escrever este buffer no segundo.","title":"Trabalhando com arquivos"},{"location":"aulas/13-entrada-saida/#extra","text":"Estes exerc\u00edcios n\u00e3o ter\u00e3o corre\u00e7\u00e3o durante a aula e devem ser checados no atendimento. Fa\u00e7a-os se voc\u00ea j\u00e1 acabou os anteriores e a corre\u00e7\u00e3o/discuss\u00e3o ainda n\u00e3o come\u00e7ou. At\u00e9 agora trabalhamos com um buffer com somente um caractere. Isso facilita a programa\u00e7\u00e3o, mas deixa nosso c\u00f3digo muito lento. Example Modifique o copy_file para usar um buffer de 100 caracteres. Me\u00e7a o tempo de execu\u00e7\u00e3o para a c\u00f3pia de um arquivo grande (~100Mb) usando o comando time . N\u00e3o se esque\u00e7a de verificar que os resultados ficaram iguais com o comando diff . Warning N\u00e3o sabe como usar time ou diff ? Use o comando man visto acima. N\u00e3o sabe usar man ? Use o comando man para aprender a us\u00e1-lo com man man Question Use o manual para entender o significado dos tempos mostrados pelo comando time . Escreva abaixo seu entendimento. Question Voc\u00ea consegue explicar a diferen\u00e7a de desempenho entre as duas vers\u00f5es?","title":"Extra"},{"location":"aulas/13-entrada-saida/#permissoes-e-posse-de-arquivos","text":"No exemplo_io2.c passamos algumas op\u00e7\u00f5es extras para poder criar o arquivo: int fd1 = open ( arq1 , O_WRONLY | O_CREAT , 0700 ); A flag O_CREAT \u00e9 usada para indicar que o arquivo deve ser criado caso ele n\u00e3o exista. O n\u00famero 0700 representa os bits de acesso visto na expositiva. Cada d\u00edgito cont\u00e9m 3 d\u00edgitos que representam as seguintes permiss\u00f5es 4 - permiss\u00e3o de leitura 2 - permiss\u00e3o de escrita 1 - permiss\u00e3o de execu\u00e7\u00e3o O primeiro d\u00edgito cont\u00e9m as permiss\u00f5es do usu\u00e1rio dono do arquivo. O segundo d\u00edgito cont\u00e9m as permiss\u00f5es do grupo dono do arquivo. Usu\u00e1rios que pertencem a este grupo possuem estas permiss\u00f5es. O terceiro d\u00edgito lista as permiss\u00f5es para todos os outros usu\u00e1rios. Question Use ls -l na pasta do arquivo criado por copy_file (ou por exemplo_io2 ). Onde \u00e9 poss\u00edvel obter as informa\u00e7\u00f5es de permiss\u00f5es do arquivo? Qual o usu\u00e1rio e grupo donos do arquivo? As permiss\u00f5es passadas para o open foram corretamente colocadas no arquivo? Question Quais permiss\u00f5es s\u00e3o garantidas pela m\u00e1scara 640 ? \u00c9 uma boa ideia us\u00e1-la? \\vspace{5em} Question Qual m\u00e1scara usaria se quisesse que um arquivo possa ser modificado somente por seu dono, mas possa ser executado por qualquer usu\u00e1rio do sistema (incluindo o dono do arquivo)? Justifique. Question Rode o comando copy_file usando sudo . Use ls -l para listar as informa\u00e7\u00f5es do arquivo. Escreva abaixo quem \u00e9 seu dono e suas permiss\u00f5es de acesso. Example Use os comandos chown para mudar o dono do arquivo para seu usu\u00e1rio e chmod para deixar suas permiss\u00f5es como leitura e escrita para voc\u00ea e somente leitura para o restante. Dica : n\u00e3o sabe como usar os comandos acima? Use man .","title":"Permiss\u00f5es e posse de arquivos"},{"location":"aulas/13-entrada-saida/#extra_1","text":"Estes exerc\u00edcios trabalham com o conceito de posse de arquivos e de sobrescrita de arquivos j\u00e1 existentes. Question Tente usar copy_file usando como fonte algum arquivo que voc\u00ea n\u00e3o possui acesso de leitura (voc\u00ea pode cri\u00e1-lo e depois usar chmod para editar os acessos). O qu\u00ea ocorre? Voc\u00ea consegue explicar este comportamento? Example Conserte o erro ocorrido acima checando a sa\u00edda de open . Consulte o manual caso necess\u00e1rio. N\u00e3o se esque\u00e7a de faz\u00ea-lo para o arquivo fonte e destino. Question Vamos realizar um experimento neste exerc\u00edcio: Crie um arquivo com 100 caracteres a e chame-o de 100a ; Crie um arquivo com 3 caracteres b e chame-o de 3b ; Use copy_file para copiar 3b em cima de 100a ; Mostre o conte\u00fado do arquivo sobrescrito 100a . Voc\u00ea consegue explicar o que ocorreu? Se sim, busque no manual uma flag que, ao ser passada para o open , evita que isto ocorra. Example O copy_file sobrescreve arquivos sem d\u00f3. Use o manual para encontrar a flag que faz open falhar caso o arquivo de destino j\u00e1 exista e conserte seu programa para perguntar se o usu\u00e1rio deseja sobrescrever o arquivo. Note que isto conflita com seu exerc\u00edcio 6. Entenda como usar errno para que voc\u00ea consiga diferenciar os dois tipos de erros.","title":"Extra"},{"location":"aulas/14-processos/","text":"14 - Processos \u00b6 A chamada fork \u00b6 A chamada fork cria um clone do processo atual e retorna duas vezes: uma vez no processo original (pai) e uma vez no processo novo (filho). Cada processo segue executando o programa linha a linha, por\u00e9m cada um possui \u00e1reas de mem\u00f3ria separadas. Ou seja, mudar uma vari\u00e1vel no processo pai n\u00e3o muda seu valor no filho (e vice-versa). Todo processo \u00e9 identificado por um n\u00famero chamado de pid . Considerando o c\u00f3digo abaixo (arquivo exemplo1-fork.c ), responda. pid_t pai , filho ; int variavel = 5 ; filho = fork (); if ( filho == 0 ) { // processo filho aqui pai = getppid (); filho = getpid (); variavel *= 2 ; printf ( \"eu sou o processo filho %d, meu pai \u00e9 %d \\n variavel %d \\n \" , filho , pai , variavel ); } else { // processo pai aqui! pai = getpid (); printf ( \"eu sou o processo pai %d, meu filho \u00e9 %d \\n variavel %d \\n \" , pai , filho , variavel ); } return 0 ; Question Responde sem rodar o programa. Qual seria o valor de variavel no print do pai? e do filho? Question Esse valor mudaria conforme o pai (ou o filho) executam primeiro? Example Compile e execute o programa acima. As suas respostas est\u00e3o corretas? Example Fa\u00e7a um programa que cria 8 processos filhos (numerados de 1 a 8) e faz cada um imprimir na tela seu seu identificador. O processo pai deve imprimir 0, enquanto o primeiro filho imprime 1, o segundo 2 e assim em diante. A sa\u00edda de seu programa dever\u00e1 seguir o modelo abaixo: Eu sou o processo pai, pid=%d, meu id do programa \u00e9 %d\\n Eu sou um processo filho, pid=%d, ppied=%d, meu id do programa \u00e9 %d\\n A primeira linha s\u00f3 deve ser mostrada uma vez pelo processo pai. Para verificar que seu programa funciona corretamente n\u00e3o se esque\u00e7a de contar quantos printf foram feitos. Se houver mais que 9 houve algum problema na sua solu\u00e7\u00e3o. Question O programa abaixo termina? Explique sua resposta. int rodando = 1 ; pid_t filho ; filho = fork (); if ( filho == 0 ) { printf ( \"Acabei filho \\n \" ); rodando = 0 ; } else { while ( rodando ) { printf ( \"Esperando o filho acabar! \\n \" ); sleep ( 1 ); } } return 0 ; As chamadas wait/waitpid \u00b6 Um processo pode esperar seus filhos acabarem usando uma das chamadas wait ou waitpid . Esta chamada retorna um c\u00f3digo num\u00e9rico que representa a sa\u00edda do programa (o que foi retornado pelo main ) e um conjunto de flags que indica se houve t\u00e9rmino anormal. O c\u00f3digo errado do \u00faltimo exerc\u00edcio tentava simular estas chamadas usando uma vari\u00e1vel rodando e checando seu valor. A maneira correta de esperar um processo filho terminar \u00e9 usando wait ou waitpid . Question Pesquise como usar wait no manual. Escreva abaixo a assinatura da fun\u00e7\u00e3o. Qual \u00e9 o valor retornado? O que \u00e9 retornado na var\u00edavel passada como ponteiro? Example Modifique o programa exemplo2-errado.c para usar wait para esperar o processo filho terminar. Ap\u00f3s o filho terminar o pai deve mostrar uma mensagem na tela indicando este fato. Salve este arquivo como exemplo2-certo.c Question \u00c9 poss\u00edvel obter o valor retornado pelo main de um processo usando wait . Pesquise no manual como faz\u00ea-lo. Dica : procure por exit status . Example Modifique o exemplo2-certo.c para que o filho retorne 2 e modifique o pai para que ele obtenha esta informa\u00e7\u00e3o a partir dos valores retornados pelo wait . Voc\u00ea precisar\u00e1 ler o manual de wait para fazer este exerc\u00edcio. Extra \u00b6 Nestes pr\u00f3ximos exerc\u00edcios vamos juntar processos e arquivos. Question Pesquise como usar a chamada nanosleep para suspender a execu\u00e7\u00e3o de um processo por um certo n\u00famero de tempo. Escreva abaixo os cabe\u00e7alhos a serem importados e como chamar a fun\u00e7\u00e3o para dormir por dois segundos. Question Modifique seu exemplo_io2.c da \u00faltima aula para dar nanosleep antes de cada write . Fa\u00e7a uma vers\u00e3o que dorme por 500ms e uma que dorme por 300ms. Abra dois terminais e rode ambos os programas. Escreva abaixo o que aconteceu. Este \u00e9 um exemplo de concorr\u00eancia por recursos . O mesmo recurso \u00e9 usado simultaneamente e os processos acabam interagindo de maneira descontrolada e estragando o arquivo. Uma solu\u00e7\u00e3o comum adotada por muitos programas \u00e9 criar um arquivo nome.lock quando iniciam o trabalho com um arquivo e delet\u00e1-lo ap\u00f3s finalizar os acessos. Assim, se outras inst\u00e2ncias do mesmo programa tentam acessar o arquivo elas podem detectar a exist\u00eancia do arquivo .lock e mostrar uma mensagem de erro. Example Modifique seu copy_file para que ele tenha este comportamento. Ou seja, antes de abrir arquivo para escrita ele checa se arquivo.lock existe e, caso isso seja verdade, mostre uma mensagem de erro. Quais flags devem ser usadas na abertura de arquivo.lock para que n\u00e3o existam problemas de concorr\u00eancia?","title":"14 - Processos"},{"location":"aulas/14-processos/#14-processos","text":"","title":"14 - Processos"},{"location":"aulas/14-processos/#a-chamada-fork","text":"A chamada fork cria um clone do processo atual e retorna duas vezes: uma vez no processo original (pai) e uma vez no processo novo (filho). Cada processo segue executando o programa linha a linha, por\u00e9m cada um possui \u00e1reas de mem\u00f3ria separadas. Ou seja, mudar uma vari\u00e1vel no processo pai n\u00e3o muda seu valor no filho (e vice-versa). Todo processo \u00e9 identificado por um n\u00famero chamado de pid . Considerando o c\u00f3digo abaixo (arquivo exemplo1-fork.c ), responda. pid_t pai , filho ; int variavel = 5 ; filho = fork (); if ( filho == 0 ) { // processo filho aqui pai = getppid (); filho = getpid (); variavel *= 2 ; printf ( \"eu sou o processo filho %d, meu pai \u00e9 %d \\n variavel %d \\n \" , filho , pai , variavel ); } else { // processo pai aqui! pai = getpid (); printf ( \"eu sou o processo pai %d, meu filho \u00e9 %d \\n variavel %d \\n \" , pai , filho , variavel ); } return 0 ; Question Responde sem rodar o programa. Qual seria o valor de variavel no print do pai? e do filho? Question Esse valor mudaria conforme o pai (ou o filho) executam primeiro? Example Compile e execute o programa acima. As suas respostas est\u00e3o corretas? Example Fa\u00e7a um programa que cria 8 processos filhos (numerados de 1 a 8) e faz cada um imprimir na tela seu seu identificador. O processo pai deve imprimir 0, enquanto o primeiro filho imprime 1, o segundo 2 e assim em diante. A sa\u00edda de seu programa dever\u00e1 seguir o modelo abaixo: Eu sou o processo pai, pid=%d, meu id do programa \u00e9 %d\\n Eu sou um processo filho, pid=%d, ppied=%d, meu id do programa \u00e9 %d\\n A primeira linha s\u00f3 deve ser mostrada uma vez pelo processo pai. Para verificar que seu programa funciona corretamente n\u00e3o se esque\u00e7a de contar quantos printf foram feitos. Se houver mais que 9 houve algum problema na sua solu\u00e7\u00e3o. Question O programa abaixo termina? Explique sua resposta. int rodando = 1 ; pid_t filho ; filho = fork (); if ( filho == 0 ) { printf ( \"Acabei filho \\n \" ); rodando = 0 ; } else { while ( rodando ) { printf ( \"Esperando o filho acabar! \\n \" ); sleep ( 1 ); } } return 0 ;","title":"A chamada fork"},{"location":"aulas/14-processos/#as-chamadas-waitwaitpid","text":"Um processo pode esperar seus filhos acabarem usando uma das chamadas wait ou waitpid . Esta chamada retorna um c\u00f3digo num\u00e9rico que representa a sa\u00edda do programa (o que foi retornado pelo main ) e um conjunto de flags que indica se houve t\u00e9rmino anormal. O c\u00f3digo errado do \u00faltimo exerc\u00edcio tentava simular estas chamadas usando uma vari\u00e1vel rodando e checando seu valor. A maneira correta de esperar um processo filho terminar \u00e9 usando wait ou waitpid . Question Pesquise como usar wait no manual. Escreva abaixo a assinatura da fun\u00e7\u00e3o. Qual \u00e9 o valor retornado? O que \u00e9 retornado na var\u00edavel passada como ponteiro? Example Modifique o programa exemplo2-errado.c para usar wait para esperar o processo filho terminar. Ap\u00f3s o filho terminar o pai deve mostrar uma mensagem na tela indicando este fato. Salve este arquivo como exemplo2-certo.c Question \u00c9 poss\u00edvel obter o valor retornado pelo main de um processo usando wait . Pesquise no manual como faz\u00ea-lo. Dica : procure por exit status . Example Modifique o exemplo2-certo.c para que o filho retorne 2 e modifique o pai para que ele obtenha esta informa\u00e7\u00e3o a partir dos valores retornados pelo wait . Voc\u00ea precisar\u00e1 ler o manual de wait para fazer este exerc\u00edcio.","title":"As chamadas wait/waitpid"},{"location":"aulas/14-processos/#extra","text":"Nestes pr\u00f3ximos exerc\u00edcios vamos juntar processos e arquivos. Question Pesquise como usar a chamada nanosleep para suspender a execu\u00e7\u00e3o de um processo por um certo n\u00famero de tempo. Escreva abaixo os cabe\u00e7alhos a serem importados e como chamar a fun\u00e7\u00e3o para dormir por dois segundos. Question Modifique seu exemplo_io2.c da \u00faltima aula para dar nanosleep antes de cada write . Fa\u00e7a uma vers\u00e3o que dorme por 500ms e uma que dorme por 300ms. Abra dois terminais e rode ambos os programas. Escreva abaixo o que aconteceu. Este \u00e9 um exemplo de concorr\u00eancia por recursos . O mesmo recurso \u00e9 usado simultaneamente e os processos acabam interagindo de maneira descontrolada e estragando o arquivo. Uma solu\u00e7\u00e3o comum adotada por muitos programas \u00e9 criar um arquivo nome.lock quando iniciam o trabalho com um arquivo e delet\u00e1-lo ap\u00f3s finalizar os acessos. Assim, se outras inst\u00e2ncias do mesmo programa tentam acessar o arquivo elas podem detectar a exist\u00eancia do arquivo .lock e mostrar uma mensagem de erro. Example Modifique seu copy_file para que ele tenha este comportamento. Ou seja, antes de abrir arquivo para escrita ele checa se arquivo.lock existe e, caso isso seja verdade, mostre uma mensagem de erro. Quais flags devem ser usadas na abertura de arquivo.lock para que n\u00e3o existam problemas de concorr\u00eancia?","title":"Extra"},{"location":"aulas/15-exec/","text":"15 - Carregamento de programas \u00b6 Argumentos de um programa \u00b6 Leia com aten\u00e7\u00e3o o c\u00f3digo antes de responder os pr\u00f3ximos exerc\u00edcios. int main ( int argc , char * argv []) { for ( int i = 0 ; i < argc ; i ++ ) { printf ( \"arg: %s \\n \" , argv [ i ]); } return 0 ; } Question Compile o c\u00f3digo acima (arquivo exemplo-args.cpp ) e rode-o. Qual sua sa\u00edda? Question Como visto em aula, um programa pode receber argumentos. Execute o programa acima com exemplo-args ag1 arg2 . Qual sua sa\u00edda? Question Qual o significado de argv[0] ? Agora vamos pensar antes de rodar o programa. Responda abaixo antes de rodar o programa . Question Qual seria o valor das vari\u00e1veis abaixo para a invoca\u00e7\u00e3o exemplo-args teste var bla foo ? argc = argv = Example Crie um programa soma que tem o seguinte comportamento: Se o programa for chamado com menos de 2 argumentos mostrar mensagem de erro e sair. Se o programa for chamado com 2 ou mais argumentos, mostrar no terminal a soma deles. Se um argumento n\u00e3o for um n\u00famero consider\u00e1-lo como 0. Dica : execute man atof ;) Carregando novos programas com exec \u00b6 A chamada exec \u00e9 usada para carregar programas na mem\u00f3ria e execut\u00e1-los. O novo programa \u00e9 carregado no contexto do processo atual, substituindo-o por completo. Veja um exemplo de uso correto do execvp abaixo. char prog [] = \"ls\" ; // a lista de argumentos sempre come\u00e7a com o nome do // programa e termina com NULL char * args [] = { \"ls\" , \"-l\" , \"-a\" , NULL }; execvp ( prog , args ); printf ( \"Fim do exec! \\n \" ); Question Por que o programa acima n\u00e3o d\u00e1 o printf abaixo do execvp terminar? Os argumentos passados no execvp s\u00e3o passados para o main do programa executado via argumentos do main . Ao fazer a chamada char prog [] = \"prog1\" ; char * args [] = { \"prog1\" , \"arg1\" , \"arg2\" , NULL }; execvp ( prog , args ); O main de prog1 ser\u00e1 chamado com argc=3 e argv={\"prog1\", \"arg1\", \"arg2\"} . O primeiro argumento \u00e9 sempre o nome do programa chamado. Como j\u00e1 vimos antes, os argumentos s\u00e3o sempre strings. Warning Fa\u00e7a os dois programas abaixo do zero. Adaptar exemplos anteriores, apesar de pr\u00e1tico, evita que repitamos os comandos e isto atrapalha a memoriza\u00e7\u00e3o dos comandos usados. Example Crie um programa eh_par que recebe um inteiro como argumento de linha de comando e cujo main retorne 1 se o n\u00famero for par, 0 caso contr\u00e1rio e -1 se ele for negativo. Dicas : pesquise para fun\u00e7\u00e3o atol para fazer a convers\u00e3o do argumento de linha de comando para long . voc\u00ea pode testar seu programa no terminal: basta rodar eh_par 10 para checar se o n\u00famero 10 \u00e9 par. para ver o valor de sa\u00edda do \u00faltimo programa rodado execute echo $? Vamos agora juntar fork , wait e exec em um \u00fanico exerc\u00edcio! Example Crie um programa que recebe n\u00fameros via scanf , executa eh_par em um processo filho e usa seu valor de retorno para decidir se o n\u00famero \u00e9 par ou n\u00e3o. Seu programa dever\u00e1 parar de receber n\u00fameros quando eh_par retornar -1. Dica : voc\u00ea pode usar sprintf para converter o inteiro lido para string. Se n\u00e3o souber como usar consulte o manual.","title":"15 - Carregamento de programas"},{"location":"aulas/15-exec/#15-carregamento-de-programas","text":"","title":"15 - Carregamento de programas"},{"location":"aulas/15-exec/#argumentos-de-um-programa","text":"Leia com aten\u00e7\u00e3o o c\u00f3digo antes de responder os pr\u00f3ximos exerc\u00edcios. int main ( int argc , char * argv []) { for ( int i = 0 ; i < argc ; i ++ ) { printf ( \"arg: %s \\n \" , argv [ i ]); } return 0 ; } Question Compile o c\u00f3digo acima (arquivo exemplo-args.cpp ) e rode-o. Qual sua sa\u00edda? Question Como visto em aula, um programa pode receber argumentos. Execute o programa acima com exemplo-args ag1 arg2 . Qual sua sa\u00edda? Question Qual o significado de argv[0] ? Agora vamos pensar antes de rodar o programa. Responda abaixo antes de rodar o programa . Question Qual seria o valor das vari\u00e1veis abaixo para a invoca\u00e7\u00e3o exemplo-args teste var bla foo ? argc = argv = Example Crie um programa soma que tem o seguinte comportamento: Se o programa for chamado com menos de 2 argumentos mostrar mensagem de erro e sair. Se o programa for chamado com 2 ou mais argumentos, mostrar no terminal a soma deles. Se um argumento n\u00e3o for um n\u00famero consider\u00e1-lo como 0. Dica : execute man atof ;)","title":"Argumentos de um programa"},{"location":"aulas/15-exec/#carregando-novos-programas-com-exec","text":"A chamada exec \u00e9 usada para carregar programas na mem\u00f3ria e execut\u00e1-los. O novo programa \u00e9 carregado no contexto do processo atual, substituindo-o por completo. Veja um exemplo de uso correto do execvp abaixo. char prog [] = \"ls\" ; // a lista de argumentos sempre come\u00e7a com o nome do // programa e termina com NULL char * args [] = { \"ls\" , \"-l\" , \"-a\" , NULL }; execvp ( prog , args ); printf ( \"Fim do exec! \\n \" ); Question Por que o programa acima n\u00e3o d\u00e1 o printf abaixo do execvp terminar? Os argumentos passados no execvp s\u00e3o passados para o main do programa executado via argumentos do main . Ao fazer a chamada char prog [] = \"prog1\" ; char * args [] = { \"prog1\" , \"arg1\" , \"arg2\" , NULL }; execvp ( prog , args ); O main de prog1 ser\u00e1 chamado com argc=3 e argv={\"prog1\", \"arg1\", \"arg2\"} . O primeiro argumento \u00e9 sempre o nome do programa chamado. Como j\u00e1 vimos antes, os argumentos s\u00e3o sempre strings. Warning Fa\u00e7a os dois programas abaixo do zero. Adaptar exemplos anteriores, apesar de pr\u00e1tico, evita que repitamos os comandos e isto atrapalha a memoriza\u00e7\u00e3o dos comandos usados. Example Crie um programa eh_par que recebe um inteiro como argumento de linha de comando e cujo main retorne 1 se o n\u00famero for par, 0 caso contr\u00e1rio e -1 se ele for negativo. Dicas : pesquise para fun\u00e7\u00e3o atol para fazer a convers\u00e3o do argumento de linha de comando para long . voc\u00ea pode testar seu programa no terminal: basta rodar eh_par 10 para checar se o n\u00famero 10 \u00e9 par. para ver o valor de sa\u00edda do \u00faltimo programa rodado execute echo $? Vamos agora juntar fork , wait e exec em um \u00fanico exerc\u00edcio! Example Crie um programa que recebe n\u00fameros via scanf , executa eh_par em um processo filho e usa seu valor de retorno para decidir se o n\u00famero \u00e9 par ou n\u00e3o. Seu programa dever\u00e1 parar de receber n\u00fameros quando eh_par retornar -1. Dica : voc\u00ea pode usar sprintf para converter o inteiro lido para string. Se n\u00e3o souber como usar consulte o manual.","title":"Carregando novos programas com exec"},{"location":"aulas/16-sinais-1/","text":"16 - Sinais 1 \u00b6 Na aula de hoje falamos sobre sinais e vimos que grande parte deles indica que algo excepcional aconteceu. Veremos neste handout as chamadas usadas para consultar o status de um processo quando ele acaba com erro e como enviar sinais para outros processos. Recuperando informa\u00e7\u00f5es de erros usando wait \u00b6 Anteriormente vimos que ao chamar wait(&status); guardamos informa\u00e7\u00f5es sobre o fim do processo filho na vari\u00e1vel status . Nos outros exerc\u00edcios olhamos para os casos em que WIFEXITED(status) == 1 . Todo t\u00e9rmino inesperado de um programa \u00e9 feito usando um sinal. Ao acessar informa\u00e7\u00f5es em um local de mem\u00f3ria n\u00e3o mapeado para o nosso processo ele recebe o sinal SIGSEGV . Ao executar uma divis\u00e3o por zero ele receber\u00e1 o sinal SIGFPE . Logo, nestes casos WIFSIGNALED(status) == 1 e podemos pegar o n\u00famero do sinal usando a macro WTERMSIG(status) . Question Leia o arquivo parte1.c . O que ele faz? Quantos processos s\u00e3o criados (conte o original)? Resposta O programa original cria um processo filho, que faz uma divis\u00e3o por zero. S\u00e3o dois processos, portanto. Example Fa\u00e7a o processo pai esperar o fim do filho e mostre uma mensagem com o pid do filho que acabou (pegue isto via wait ). Example No proceso pai, ap\u00f3s o wait mostre no terminal as seguintes express\u00f5es booleanas: WIFEXITED(status) WIFSIGNALED(status) WTERMSIG(status) ] Example Mostrar o n\u00famero do sinal n\u00e3o \u00e9 muito \u00fatil. Pesquise sobre a chamada strsignal e use-a para mostrar uma mensagem descritiva de qual sinal foi recebido no exerc\u00edcio acima. Envio de sinais via terminal \u00b6 Al\u00e9m de erros e exce\u00e7\u00f5es, sinais tamb\u00e9m s\u00e3o usados para avisar de mudan\u00e7as no sistema, sejam elas iniciadas pelo usu\u00e1rio ou por outros processos. A sequ\u00eancia de exerc\u00edcios abaixo \u00e9 um experimento de envio de sinais. Example Modifique seu arquivo parte1.c para que o processo filho mostre seu pid e entre em loop infinito. Salve como parte2.c . Claramente nem o pai nem o filho terminam no exemplo acima. Por\u00e9m, se o filho terminar o pai termina tamb\u00e9m! O sinal SIGKILL \u00e9 usado para terminar for\u00e7adamente um processo e ele pode ser enviado por qualquer outro processo do mesmo usu\u00e1rio (ou o root , que pode mandar sinais para qualquer processo do sistema). O envio de sinais \u00e9 feito usando a chamada kill . Assim como outras chamadas de sistema, kill possui tamb\u00e9m um programa de linha de comando. Example Abra dois terminais e coloque um ao lado do outro. No primeiro, execute o programa parte2.c . Example No segundo terminal, use a ferramenta de linha de comando kill para enviar o sinal SIGKILL para o processo filho. Se precisar, consulte a documenta\u00e7\u00e3o usando man 1 kill . Question Use man 7 signal para ver a lista de sinais dispon\u00edveis e seus n\u00fameros. Qual seria o n\u00famero para o sinal SIGINT ? Isto deve ter feito o pai finalizar e mostrar a informa\u00e7\u00e3o de que o processo filho foi finalizado. Note que o pai tem direito a saber o sinal usado para finalizar um filho: Example Envie o sinal SIGINT para seu processo filho e verifique que o processo pai mostra o n\u00famero correto. Envio de sinais em um programa \u00b6 O programa kill \u00e9 apenas um casquinha em volta de sua chamada de sistema. Example Veja a documenta\u00e7\u00e3o da chamada de sistema (em C) no manual man 2 kill Example Modifique seu exerc\u00edcio da parte anterior para que o processo pai espere 10 segundos e envie um SIGKILL para o filho. Salve como parte3.c Question Agora os dois processos acabam? As informa\u00e7\u00f5es de finaliza\u00e7\u00e3o no pai condizem com o sinal enviado? Extra \u00b6 At\u00e9 o momento usamos a chamada wait para esperar um processo filho acabar. Por\u00e9m, n\u00e3o sabemos ainda checar se um processo filho acabou! Podemos fazer isso com a fun\u00e7\u00e3o waitpid , que recebe o pid_t do processo filho, e permite esperar ou n\u00e3o pela finaliza\u00e7\u00e3o dele. Example Pesquise no manual pela flag WNOHANG da chamada waitpid . Example Modifique seu exerc\u00edcio acima para que o processo pai s\u00f3 envie o sinal se o processo filho ainda estiver executando.","title":"16 - Sinais 1"},{"location":"aulas/16-sinais-1/#16-sinais-1","text":"Na aula de hoje falamos sobre sinais e vimos que grande parte deles indica que algo excepcional aconteceu. Veremos neste handout as chamadas usadas para consultar o status de um processo quando ele acaba com erro e como enviar sinais para outros processos.","title":"16 - Sinais 1"},{"location":"aulas/16-sinais-1/#recuperando-informacoes-de-erros-usando-wait","text":"Anteriormente vimos que ao chamar wait(&status); guardamos informa\u00e7\u00f5es sobre o fim do processo filho na vari\u00e1vel status . Nos outros exerc\u00edcios olhamos para os casos em que WIFEXITED(status) == 1 . Todo t\u00e9rmino inesperado de um programa \u00e9 feito usando um sinal. Ao acessar informa\u00e7\u00f5es em um local de mem\u00f3ria n\u00e3o mapeado para o nosso processo ele recebe o sinal SIGSEGV . Ao executar uma divis\u00e3o por zero ele receber\u00e1 o sinal SIGFPE . Logo, nestes casos WIFSIGNALED(status) == 1 e podemos pegar o n\u00famero do sinal usando a macro WTERMSIG(status) . Question Leia o arquivo parte1.c . O que ele faz? Quantos processos s\u00e3o criados (conte o original)? Resposta O programa original cria um processo filho, que faz uma divis\u00e3o por zero. S\u00e3o dois processos, portanto. Example Fa\u00e7a o processo pai esperar o fim do filho e mostre uma mensagem com o pid do filho que acabou (pegue isto via wait ). Example No proceso pai, ap\u00f3s o wait mostre no terminal as seguintes express\u00f5es booleanas: WIFEXITED(status) WIFSIGNALED(status) WTERMSIG(status) ] Example Mostrar o n\u00famero do sinal n\u00e3o \u00e9 muito \u00fatil. Pesquise sobre a chamada strsignal e use-a para mostrar uma mensagem descritiva de qual sinal foi recebido no exerc\u00edcio acima.","title":"Recuperando informa\u00e7\u00f5es de erros usando wait"},{"location":"aulas/16-sinais-1/#envio-de-sinais-via-terminal","text":"Al\u00e9m de erros e exce\u00e7\u00f5es, sinais tamb\u00e9m s\u00e3o usados para avisar de mudan\u00e7as no sistema, sejam elas iniciadas pelo usu\u00e1rio ou por outros processos. A sequ\u00eancia de exerc\u00edcios abaixo \u00e9 um experimento de envio de sinais. Example Modifique seu arquivo parte1.c para que o processo filho mostre seu pid e entre em loop infinito. Salve como parte2.c . Claramente nem o pai nem o filho terminam no exemplo acima. Por\u00e9m, se o filho terminar o pai termina tamb\u00e9m! O sinal SIGKILL \u00e9 usado para terminar for\u00e7adamente um processo e ele pode ser enviado por qualquer outro processo do mesmo usu\u00e1rio (ou o root , que pode mandar sinais para qualquer processo do sistema). O envio de sinais \u00e9 feito usando a chamada kill . Assim como outras chamadas de sistema, kill possui tamb\u00e9m um programa de linha de comando. Example Abra dois terminais e coloque um ao lado do outro. No primeiro, execute o programa parte2.c . Example No segundo terminal, use a ferramenta de linha de comando kill para enviar o sinal SIGKILL para o processo filho. Se precisar, consulte a documenta\u00e7\u00e3o usando man 1 kill . Question Use man 7 signal para ver a lista de sinais dispon\u00edveis e seus n\u00fameros. Qual seria o n\u00famero para o sinal SIGINT ? Isto deve ter feito o pai finalizar e mostrar a informa\u00e7\u00e3o de que o processo filho foi finalizado. Note que o pai tem direito a saber o sinal usado para finalizar um filho: Example Envie o sinal SIGINT para seu processo filho e verifique que o processo pai mostra o n\u00famero correto.","title":"Envio de sinais via terminal"},{"location":"aulas/16-sinais-1/#envio-de-sinais-em-um-programa","text":"O programa kill \u00e9 apenas um casquinha em volta de sua chamada de sistema. Example Veja a documenta\u00e7\u00e3o da chamada de sistema (em C) no manual man 2 kill Example Modifique seu exerc\u00edcio da parte anterior para que o processo pai espere 10 segundos e envie um SIGKILL para o filho. Salve como parte3.c Question Agora os dois processos acabam? As informa\u00e7\u00f5es de finaliza\u00e7\u00e3o no pai condizem com o sinal enviado?","title":"Envio de sinais em um programa"},{"location":"aulas/16-sinais-1/#extra","text":"At\u00e9 o momento usamos a chamada wait para esperar um processo filho acabar. Por\u00e9m, n\u00e3o sabemos ainda checar se um processo filho acabou! Podemos fazer isso com a fun\u00e7\u00e3o waitpid , que recebe o pid_t do processo filho, e permite esperar ou n\u00e3o pela finaliza\u00e7\u00e3o dele. Example Pesquise no manual pela flag WNOHANG da chamada waitpid . Example Modifique seu exerc\u00edcio acima para que o processo pai s\u00f3 envie o sinal se o processo filho ainda estiver executando.","title":"Extra"},{"location":"aulas/17-sinais-2/","text":"17 - Capturando sinais \u00b6 Na aula de hoje iremos criar programas que reagem a sinais recebidos. J\u00e1 vimos que o sistema tem uma s\u00e9rie de comportamentos padr\u00e3o para cada sinal, ent\u00e3o hoje aprenderemos a customizar esse comportamento. Warning Apesar de muitos recursos mostrarem o uso da chamada signal para a captura de sinais, ela \u00e9 considerada obsoleta e o recomendado \u00e9 usar sigaction , que \u00e9 um pouco mais complicada de usar mas permite maior flexibilidade ao definir o comportamento do processo. Capturando sinais - a chamada sigaction \u00b6 O exemplo abaixo cria um struct sigaction e o seta para executar um handler quando o processo receber SIGINT (Ctrl+C). void sig_handler ( int num ) { // faz algo aqui } .... struct sigaction s ; s . sa_handler = sig_handler ; // aqui vai a fun\u00e7\u00e3o a ser executada sigemptyset ( & s . sa_mask ); s . sa_flags = 0 ; sigaction ( SIGINT , & s , NULL ); Example Usando como exemplo o c\u00f3digo acima, modifique o arquivo sinal1.c para que o programa s\u00f3 termine ap\u00f3s apertar Ctrl+C tr\u00eas vezes. Voc\u00ea pode usar exit para sair na terceira vez. N\u00e3o se esque\u00e7a de consultar man sigaction para verificar quais include s deve ser usados. O programa acima funciona, mas seu t\u00e9rmino n\u00e3o \u00e9 condizente com a a\u00e7\u00e3o do usu\u00e1rio. Ao sair com exit o processo pai (no caso o shell) n\u00e3o consegue saber que o programa foi interrompido pelo usu\u00e1rio e acha que ele terminou normalmente. Podemos resetar o comportamento padr\u00e3o de um sinal atribuindo a constante SIG_DFL ( signal default ) a sigaction.sa_handler . Example Restaure o comportamento original no segundo Ctrl+C , fazendo com que o processo realmente termine com o sinal. Question Podemos verificar o sinal que terminou um processo usando o comando kill -l \"$?\" . Execute-o e veja que realmente \u00e9 SIGINT . Sinais e concorr\u00eancia \u00b6 Nesta parte vamos trabalhar com o arquivo sinais-concorrentes.c . Example Leia o conte\u00fado do arquivo acima e complete as partes faltantes. Question Teste sua implementa\u00e7\u00e3o enviando sinais SIGINT e SIGTERM para seu processo. Os resultados foram os esperados? Vamos agora examinar o que acontece quando trabalhamos com v\u00e1rios sinais sendo recebidos ao mesmo tempo. Example Abra dois terminais. No primeiro execute sinais-concorrentes . Question No segundo terminal, realize a seguinte sequ\u00eancia de comandos. Para cada comando, anote o que \u00e9 mostrado no terminal. Envie o sinal SIGINT para o programa. Envie o sinal SIGTERM para o programa. Envie de novo SIGINT. Question Assumindo que cada fun\u00e7\u00e3o roda do come\u00e7o ao fim sem interrup\u00e7\u00e3om, os valores da vari\u00e1vel status foram os esperados? Se n\u00e3o, como voc\u00ea explica o ocorrido? Warning Valide sua resposta com o professor antes de prosseguir. Se quiser, poder\u00e1 esperar pela corre\u00e7\u00e3o do exerc\u00edcio. Bloqueio de sinais \u00b6 A principal vantagem de usarmos sigaction \u00e9 que esta chamada permite configurar sinais a serem bloqueados durante a execu\u00e7\u00e3o da fun\u00e7\u00e3o sa_handler . Ou seja, se um sinal bloqueado for recebido durante sua execu\u00e7\u00e3o ele \u00e9 colocado \"em espera\" at\u00e9 que sa_handler acabe de rodar! Question Bloquear sinais evita o problema detectado na parte anterior? Question Quais sinais dever\u00e3o ser bloqueados durante a execu\u00e7\u00e3o do handler SIGINT ? E durante a execu\u00e7\u00e3o do handler SIGTERM ? Question O campo sa_mask permite bloquear sinais enquanto os handlers executam. Consulte man sigsetops para ver como preench\u00ea-lo. Escreva abaixo os comandos para tal. Example Modifique sinais-concorrentes.c para que SIGTERM seja bloqueado enquanto o handler de SIGINT roda. Repita ent\u00e3o o experiemento acima e veja que n\u00e3o h\u00e1 mais conflito na vari\u00e1vel global compartilhada. !!! example O que fizemos n\u00e3o permite que SIGINT seja interrompido por um SIGTERM , mas permite que um SIGTERM seja interrompido por um SIGINT ! Corrija esta situa\u00e7\u00e3o.","title":"17 - Capturando sinais"},{"location":"aulas/17-sinais-2/#17-capturando-sinais","text":"Na aula de hoje iremos criar programas que reagem a sinais recebidos. J\u00e1 vimos que o sistema tem uma s\u00e9rie de comportamentos padr\u00e3o para cada sinal, ent\u00e3o hoje aprenderemos a customizar esse comportamento. Warning Apesar de muitos recursos mostrarem o uso da chamada signal para a captura de sinais, ela \u00e9 considerada obsoleta e o recomendado \u00e9 usar sigaction , que \u00e9 um pouco mais complicada de usar mas permite maior flexibilidade ao definir o comportamento do processo.","title":"17 - Capturando sinais"},{"location":"aulas/17-sinais-2/#capturando-sinais-a-chamada-sigaction","text":"O exemplo abaixo cria um struct sigaction e o seta para executar um handler quando o processo receber SIGINT (Ctrl+C). void sig_handler ( int num ) { // faz algo aqui } .... struct sigaction s ; s . sa_handler = sig_handler ; // aqui vai a fun\u00e7\u00e3o a ser executada sigemptyset ( & s . sa_mask ); s . sa_flags = 0 ; sigaction ( SIGINT , & s , NULL ); Example Usando como exemplo o c\u00f3digo acima, modifique o arquivo sinal1.c para que o programa s\u00f3 termine ap\u00f3s apertar Ctrl+C tr\u00eas vezes. Voc\u00ea pode usar exit para sair na terceira vez. N\u00e3o se esque\u00e7a de consultar man sigaction para verificar quais include s deve ser usados. O programa acima funciona, mas seu t\u00e9rmino n\u00e3o \u00e9 condizente com a a\u00e7\u00e3o do usu\u00e1rio. Ao sair com exit o processo pai (no caso o shell) n\u00e3o consegue saber que o programa foi interrompido pelo usu\u00e1rio e acha que ele terminou normalmente. Podemos resetar o comportamento padr\u00e3o de um sinal atribuindo a constante SIG_DFL ( signal default ) a sigaction.sa_handler . Example Restaure o comportamento original no segundo Ctrl+C , fazendo com que o processo realmente termine com o sinal. Question Podemos verificar o sinal que terminou um processo usando o comando kill -l \"$?\" . Execute-o e veja que realmente \u00e9 SIGINT .","title":"Capturando sinais - a chamada sigaction"},{"location":"aulas/17-sinais-2/#sinais-e-concorrencia","text":"Nesta parte vamos trabalhar com o arquivo sinais-concorrentes.c . Example Leia o conte\u00fado do arquivo acima e complete as partes faltantes. Question Teste sua implementa\u00e7\u00e3o enviando sinais SIGINT e SIGTERM para seu processo. Os resultados foram os esperados? Vamos agora examinar o que acontece quando trabalhamos com v\u00e1rios sinais sendo recebidos ao mesmo tempo. Example Abra dois terminais. No primeiro execute sinais-concorrentes . Question No segundo terminal, realize a seguinte sequ\u00eancia de comandos. Para cada comando, anote o que \u00e9 mostrado no terminal. Envie o sinal SIGINT para o programa. Envie o sinal SIGTERM para o programa. Envie de novo SIGINT. Question Assumindo que cada fun\u00e7\u00e3o roda do come\u00e7o ao fim sem interrup\u00e7\u00e3om, os valores da vari\u00e1vel status foram os esperados? Se n\u00e3o, como voc\u00ea explica o ocorrido? Warning Valide sua resposta com o professor antes de prosseguir. Se quiser, poder\u00e1 esperar pela corre\u00e7\u00e3o do exerc\u00edcio.","title":"Sinais e concorr\u00eancia"},{"location":"aulas/17-sinais-2/#bloqueio-de-sinais","text":"A principal vantagem de usarmos sigaction \u00e9 que esta chamada permite configurar sinais a serem bloqueados durante a execu\u00e7\u00e3o da fun\u00e7\u00e3o sa_handler . Ou seja, se um sinal bloqueado for recebido durante sua execu\u00e7\u00e3o ele \u00e9 colocado \"em espera\" at\u00e9 que sa_handler acabe de rodar! Question Bloquear sinais evita o problema detectado na parte anterior? Question Quais sinais dever\u00e3o ser bloqueados durante a execu\u00e7\u00e3o do handler SIGINT ? E durante a execu\u00e7\u00e3o do handler SIGTERM ? Question O campo sa_mask permite bloquear sinais enquanto os handlers executam. Consulte man sigsetops para ver como preench\u00ea-lo. Escreva abaixo os comandos para tal. Example Modifique sinais-concorrentes.c para que SIGTERM seja bloqueado enquanto o handler de SIGINT roda. Repita ent\u00e3o o experiemento acima e veja que n\u00e3o h\u00e1 mais conflito na vari\u00e1vel global compartilhada. !!! example O que fizemos n\u00e3o permite que SIGINT seja interrompido por um SIGTERM , mas permite que um SIGTERM seja interrompido por um SIGINT ! Corrija esta situa\u00e7\u00e3o.","title":"Bloqueio de sinais"},{"location":"aulas/18-threads/","text":"18 - Concorr\u00eancia e Threads \u00b6 Nossa aula de hoje envolver\u00e1 aprender a API pthreads para cria\u00e7\u00e3o de threads e sincroniza\u00e7\u00e3o simples. Criando tarefas e esperando elas acabarem \u00b6 O exemplo abaixo cria uma thread que roda a fun\u00e7\u00e3o primeira_thread , espera por seu fim e mostra a mensagem Fim do programa . // Fun\u00e7\u00f5es rodadas em thread sempre tem essa assinatura void * minha_thread ( void * arg ) { printf ( \"Hello thread! \\n \" ); return NULL ; } .... pthread_t tid ; int error = pthread_create ( & tid , NULL , minha_thread , NULL ); pthread_join ( tid , NULL ); // espera tid acabar. Example Compile o arquivo exemplo1.c com a flag especial -pthread e execute-o. gcc exemplo1.c -o exemplo1 -pthread Vamos dissecar a chamada da fun\u00e7\u00e3o pthread_create : int error = pthread_create ( & tid , // vari\u00e1vel para guardar ID da nova thread NULL , // op\u00e7\u00f5es de cria\u00e7\u00e3o. NULL = op\u00e7\u00f5es padr\u00e3o minha_thread , // fun\u00e7\u00e3o a ser executada NULL ); // par\u00e2metro passado para a fun\u00e7\u00e3o acima ); Toda thread que rodarmos ter\u00e1 a seguinte assinatura (mudando, \u00e9 claro, o nome da fun\u00e7\u00e3o). void * minha_thread ( void * arg ); Uma vari\u00e1vel do tipo void * representa um endere\u00e7o de mem\u00f3ria cujo conte\u00fado \u00e9 desconhecido. Ou seja, ele diz somente onde encontrar os dados, mas n\u00e3o diz o que est\u00e1 guardado na mem\u00f3ria naquele lugar. Este tipo de vari\u00e1vel \u00e9 usada quando queremos passar blocos de mem\u00f3ria entre fun\u00e7\u00f5es mas n\u00e3o queremos fixar um tipo de dados. Veremos com mais detalhes como isto funciona na parte 2. Example O manual cont\u00e9m entradas muito bem escritas de todas as chamadas de POSIX threads que usaremos. Abra as seguintes e se familiarize com seu conte\u00fado. man 7 pthreads man 3 pthread_create man 3 pthread_join Assim como processos, threads s\u00e3o escalonadas pelo kernel. Isto significa que n\u00e3o controlamos a ordem em que elas rodam no nosso programa. Ou seja, ao executar pthread_create n\u00e3o sabemos se a thread principal (aquela que roda o main ) continuar\u00e1 rodando ou se o controle passar\u00e1 instantaneamente para a nova thread. A primitiva de sincroniza\u00e7\u00e3o mais simples que dispomos \u00e9 pthread_join , que garante que uma thread s\u00f3 prossegue quando outra acabar. Question Retire o pthread_join do programa exemplo e o execute. Repita a execu\u00e7\u00e3o v\u00e1rias vezes. Todas as vezes o resultado \u00e9 o mesmo? O qu\u00ea acontece? Question \u00c9 poss\u00edvel que duas threads chamem pthread_join na mesma thread destino? Consulte o manual para saber esta resposta. A resposta acima indica que precisaremos de outras primitivas de sincroniza\u00e7\u00e3o mais sofisticadas no futuro. Veremos isso nas pr\u00f3ximas aulas. Example Crie quatro threads, cada uma executando uma fun\u00e7\u00e3o que faz um print diferente. Compile e execute seu programa v\u00e1rias vezes. A sa\u00edda muda? Passando argumentos para threads \u00b6 Nossas threads ainda s\u00e3o muito limitadas: elas n\u00e3o recebem nenhum argumento nem devolvem resultados. Vamos consertar isso nesta se\u00e7\u00e3o. Vimos na parte 1 que o \u00faltimo argumento de pthread_create \u00e9 um ponteiro para os dados que nossa fun\u00e7\u00e3o dever\u00e1 receber. Neste sequ\u00eancia de exerc\u00edcios iremos aprender a usar este argumento para passar dados para nossas threads. Nosso primeiro exerc\u00edcio ser\u00e1 feito passo a passo. Siga cada um dos passos a risca e depois responda as quest\u00f5es. Vamos trabalhar a partir de um arquivo vazio. Example Crie um programa simples com uma fun\u00e7\u00e3o main que aloca (usando malloc) um vetor vi com 4 int s e um vetor tids com 4 pthread_t s. Example Adicione ao seu programa um for que cria 4 threads (colocando seus ids no vetor tids ). Passe como \u00faltimo argumento o endere\u00e7o do elemento correspondente de vi . Example Espere pelo fim desta thread. Example Crie uma fun\u00e7\u00e3o void *tarefa_print_i(void *arg) que declara uma vari\u00e1vel int *i e d\u00e1 print em seu conte\u00fado. Inicialize a vari\u00e1vel i como mostrado abaixo: int *i = (int *) arg; Se seu programa estiver correto voc\u00ea dever\u00e1 ver no terminal 4 prints com n\u00fameros de 0 a 3, cada um vindo de um thread. Warning Se tiver problemas valide seu c\u00f3digo com algum colega que j\u00e1 tenha sido validado pelo professor. Se n\u00e3o tiver ningu\u00e9m por perto j\u00e1 validado me chame ;) Question Explique como \u00e9 feita a passagem do argumento para a thread. Question Passamos para a thread um valor alocado dinamicamente. Por que isso \u00e9 necess\u00e1rio? Vamos explorar a resposta da pergunta acima nos pr\u00f3ximos exerc\u00edcios. Para cada exerc\u00edcio, encontre seu problema, descreva-o usando suas pr\u00f3prias palavras e mostre um exemplo de sa\u00edda poss\u00edvel. Somente depois de escrever sua resposta rode o programa. Warning Cada exerc\u00edcio foca em um problema diferente. A resposta n\u00e3o \u00e9 a mesma para ambas. Question Identifique um problema de escopo de dados no c\u00f3digo abaixo (arquivo parte2-1.c ) void * minha_thread ( void * arg ) { int * i = ( int * ) arg ; printf ( \"Hello thread! %d \\n \" , * i ); } // dentro do main for ( int i = 0 ; i < 4 ; i ++ ) { pthread_create ( & tid [ i ], NULL , minha_thread , & i ); } Question Identifique um problema de escopo de dados no c\u00f3digo abaixo (arquivo parte2-2.c ) void * minha_thread ( void * arg ) { int * i = ( int * ) arg ; printf ( \"Hello thread! %d \\n \" , * i ); } pthread_t * criar_threads ( int n ) { pthread_t * tids = malloc ( sizeof ( pthread_t ) * n ); for ( int i = 0 ; i < n ; i ++ ) { pthread_create ( & tids [ i ], NULL , minha_thread , & i ); } return tids ; } // dentro do main pthread_t * tids = criar_threads ( 4 ); Warning Valide sua solu\u00e7\u00e3o com o professor. Agora que j\u00e1 entendemos como passar um argumento e que devemos sempre coloc\u00e1-lo no heap , passar v\u00e1rios \u00e9 muito simples: alocamos um struct com todos os dados que queremos enviar e passamos seu endere\u00e7o no \u00faltimo argumento. Ao receb\u00ea-lo, a fun\u00e7\u00e3o faz um cast de void * para um ponteiro para o struct . Example Modifique seu exerc\u00edcio do come\u00e7o desta parte para receber dois argumentos do tipo inteiro e imprimir ambos valores. Retornando valores \u00b6 Na pr\u00e1tica, ao passar struct s para threads como argumentos j\u00e1 sabemos como retornar valores: basta adicionar um campo que pr\u00f3pria thread deve preencher com o resultado de sua execu\u00e7\u00e3o. Isso \u00e9 equivalente a criar uma fun\u00e7\u00e3o que retorna valores em vari\u00e1veis passadas por refer\u00eancia (ou seja, escrevendo em vari\u00e1veis passadas como ponteiros). Example Modifique seu exerc\u00edcio da parte anterior para que as threads retornem a multiplica\u00e7\u00e3o dos dois inteiros passados. Fa\u00e7a o print deste valor no main .","title":"18 - Concorr\u00eancia e Threads"},{"location":"aulas/18-threads/#18-concorrencia-e-threads","text":"Nossa aula de hoje envolver\u00e1 aprender a API pthreads para cria\u00e7\u00e3o de threads e sincroniza\u00e7\u00e3o simples.","title":"18 - Concorr\u00eancia e Threads"},{"location":"aulas/18-threads/#criando-tarefas-e-esperando-elas-acabarem","text":"O exemplo abaixo cria uma thread que roda a fun\u00e7\u00e3o primeira_thread , espera por seu fim e mostra a mensagem Fim do programa . // Fun\u00e7\u00f5es rodadas em thread sempre tem essa assinatura void * minha_thread ( void * arg ) { printf ( \"Hello thread! \\n \" ); return NULL ; } .... pthread_t tid ; int error = pthread_create ( & tid , NULL , minha_thread , NULL ); pthread_join ( tid , NULL ); // espera tid acabar. Example Compile o arquivo exemplo1.c com a flag especial -pthread e execute-o. gcc exemplo1.c -o exemplo1 -pthread Vamos dissecar a chamada da fun\u00e7\u00e3o pthread_create : int error = pthread_create ( & tid , // vari\u00e1vel para guardar ID da nova thread NULL , // op\u00e7\u00f5es de cria\u00e7\u00e3o. NULL = op\u00e7\u00f5es padr\u00e3o minha_thread , // fun\u00e7\u00e3o a ser executada NULL ); // par\u00e2metro passado para a fun\u00e7\u00e3o acima ); Toda thread que rodarmos ter\u00e1 a seguinte assinatura (mudando, \u00e9 claro, o nome da fun\u00e7\u00e3o). void * minha_thread ( void * arg ); Uma vari\u00e1vel do tipo void * representa um endere\u00e7o de mem\u00f3ria cujo conte\u00fado \u00e9 desconhecido. Ou seja, ele diz somente onde encontrar os dados, mas n\u00e3o diz o que est\u00e1 guardado na mem\u00f3ria naquele lugar. Este tipo de vari\u00e1vel \u00e9 usada quando queremos passar blocos de mem\u00f3ria entre fun\u00e7\u00f5es mas n\u00e3o queremos fixar um tipo de dados. Veremos com mais detalhes como isto funciona na parte 2. Example O manual cont\u00e9m entradas muito bem escritas de todas as chamadas de POSIX threads que usaremos. Abra as seguintes e se familiarize com seu conte\u00fado. man 7 pthreads man 3 pthread_create man 3 pthread_join Assim como processos, threads s\u00e3o escalonadas pelo kernel. Isto significa que n\u00e3o controlamos a ordem em que elas rodam no nosso programa. Ou seja, ao executar pthread_create n\u00e3o sabemos se a thread principal (aquela que roda o main ) continuar\u00e1 rodando ou se o controle passar\u00e1 instantaneamente para a nova thread. A primitiva de sincroniza\u00e7\u00e3o mais simples que dispomos \u00e9 pthread_join , que garante que uma thread s\u00f3 prossegue quando outra acabar. Question Retire o pthread_join do programa exemplo e o execute. Repita a execu\u00e7\u00e3o v\u00e1rias vezes. Todas as vezes o resultado \u00e9 o mesmo? O qu\u00ea acontece? Question \u00c9 poss\u00edvel que duas threads chamem pthread_join na mesma thread destino? Consulte o manual para saber esta resposta. A resposta acima indica que precisaremos de outras primitivas de sincroniza\u00e7\u00e3o mais sofisticadas no futuro. Veremos isso nas pr\u00f3ximas aulas. Example Crie quatro threads, cada uma executando uma fun\u00e7\u00e3o que faz um print diferente. Compile e execute seu programa v\u00e1rias vezes. A sa\u00edda muda?","title":"Criando tarefas e esperando elas acabarem"},{"location":"aulas/18-threads/#passando-argumentos-para-threads","text":"Nossas threads ainda s\u00e3o muito limitadas: elas n\u00e3o recebem nenhum argumento nem devolvem resultados. Vamos consertar isso nesta se\u00e7\u00e3o. Vimos na parte 1 que o \u00faltimo argumento de pthread_create \u00e9 um ponteiro para os dados que nossa fun\u00e7\u00e3o dever\u00e1 receber. Neste sequ\u00eancia de exerc\u00edcios iremos aprender a usar este argumento para passar dados para nossas threads. Nosso primeiro exerc\u00edcio ser\u00e1 feito passo a passo. Siga cada um dos passos a risca e depois responda as quest\u00f5es. Vamos trabalhar a partir de um arquivo vazio. Example Crie um programa simples com uma fun\u00e7\u00e3o main que aloca (usando malloc) um vetor vi com 4 int s e um vetor tids com 4 pthread_t s. Example Adicione ao seu programa um for que cria 4 threads (colocando seus ids no vetor tids ). Passe como \u00faltimo argumento o endere\u00e7o do elemento correspondente de vi . Example Espere pelo fim desta thread. Example Crie uma fun\u00e7\u00e3o void *tarefa_print_i(void *arg) que declara uma vari\u00e1vel int *i e d\u00e1 print em seu conte\u00fado. Inicialize a vari\u00e1vel i como mostrado abaixo: int *i = (int *) arg; Se seu programa estiver correto voc\u00ea dever\u00e1 ver no terminal 4 prints com n\u00fameros de 0 a 3, cada um vindo de um thread. Warning Se tiver problemas valide seu c\u00f3digo com algum colega que j\u00e1 tenha sido validado pelo professor. Se n\u00e3o tiver ningu\u00e9m por perto j\u00e1 validado me chame ;) Question Explique como \u00e9 feita a passagem do argumento para a thread. Question Passamos para a thread um valor alocado dinamicamente. Por que isso \u00e9 necess\u00e1rio? Vamos explorar a resposta da pergunta acima nos pr\u00f3ximos exerc\u00edcios. Para cada exerc\u00edcio, encontre seu problema, descreva-o usando suas pr\u00f3prias palavras e mostre um exemplo de sa\u00edda poss\u00edvel. Somente depois de escrever sua resposta rode o programa. Warning Cada exerc\u00edcio foca em um problema diferente. A resposta n\u00e3o \u00e9 a mesma para ambas. Question Identifique um problema de escopo de dados no c\u00f3digo abaixo (arquivo parte2-1.c ) void * minha_thread ( void * arg ) { int * i = ( int * ) arg ; printf ( \"Hello thread! %d \\n \" , * i ); } // dentro do main for ( int i = 0 ; i < 4 ; i ++ ) { pthread_create ( & tid [ i ], NULL , minha_thread , & i ); } Question Identifique um problema de escopo de dados no c\u00f3digo abaixo (arquivo parte2-2.c ) void * minha_thread ( void * arg ) { int * i = ( int * ) arg ; printf ( \"Hello thread! %d \\n \" , * i ); } pthread_t * criar_threads ( int n ) { pthread_t * tids = malloc ( sizeof ( pthread_t ) * n ); for ( int i = 0 ; i < n ; i ++ ) { pthread_create ( & tids [ i ], NULL , minha_thread , & i ); } return tids ; } // dentro do main pthread_t * tids = criar_threads ( 4 ); Warning Valide sua solu\u00e7\u00e3o com o professor. Agora que j\u00e1 entendemos como passar um argumento e que devemos sempre coloc\u00e1-lo no heap , passar v\u00e1rios \u00e9 muito simples: alocamos um struct com todos os dados que queremos enviar e passamos seu endere\u00e7o no \u00faltimo argumento. Ao receb\u00ea-lo, a fun\u00e7\u00e3o faz um cast de void * para um ponteiro para o struct . Example Modifique seu exerc\u00edcio do come\u00e7o desta parte para receber dois argumentos do tipo inteiro e imprimir ambos valores.","title":"Passando argumentos para threads"},{"location":"aulas/18-threads/#retornando-valores","text":"Na pr\u00e1tica, ao passar struct s para threads como argumentos j\u00e1 sabemos como retornar valores: basta adicionar um campo que pr\u00f3pria thread deve preencher com o resultado de sua execu\u00e7\u00e3o. Isso \u00e9 equivalente a criar uma fun\u00e7\u00e3o que retorna valores em vari\u00e1veis passadas por refer\u00eancia (ou seja, escrevendo em vari\u00e1veis passadas como ponteiros). Example Modifique seu exerc\u00edcio da parte anterior para que as threads retornem a multiplica\u00e7\u00e3o dos dois inteiros passados. Fa\u00e7a o print deste valor no main .","title":"Retornando valores"},{"location":"aulas/19-sincronizacao/","text":"19 - Sincroniza\u00e7\u00e3o \u00b6 Na \u00faltima aula aprendemos as APIs da biblioteca pthread para criar e esperar a finaliza\u00e7\u00e3o de threads. Tamb\u00e9m aprendemos a passar argumentos e receber de volta valores usando um struct alocado dinamicamente. Aquecimento \u00b6 Vamos iniciar uma revis\u00e3o trabalhando em cima do arquivo soma_global.c . Example Abra o arquivo e analise seu conte\u00fado. Question Qual o papel da fun\u00e7\u00e3o soma_parcial ? Explique o papel de cada atributo de Question Como voc\u00ea setaria os atributos de struct soma_partical_args para obter a soma do vetor todo? E para obter somente a soma da primeira metade do vetor? Para fins did\u00e1ticos, estamos atualizando diretamente a vari\u00e1vel soma_total dentro do for . Example Complete as partes faltantes e rode o programa. Ele d\u00e1 os resultados esperados? Teste para valores de n incrementalmente maiores. Question Os resultados acima estar\u00e3o errados. Voc\u00ea consegue explicar por que? Sincroniza\u00e7\u00e3o usando mutex \u00b6 Vamos agora trabalhar agora para corrigir este erro! Lembrando da aula, as opera\u00e7\u00f5es poss\u00edveis s\u00e3o as seguintes: lock - se tiver destravado, trava e continua; se n\u00e3o estiver espera. unlock - se tiver a trava, a destrava e permite que outras tarefas travem. Note que n\u00e3o existe garantia de ordem! Ou seja, se tiverem v\u00e1rios processos esperando por um mutex qualquer um deles pode receber o acesso. Inclusive, uma thread pode esperar \"para sempre\" e nunca receber o acesso. N\u00e3o \u00e9 prov\u00e1vel, mas \u00e9 poss\u00edvel. Warning Voc\u00ea pode precisar instalar o pacote manpages-posix-dev para obter as p\u00e1ginas do manual usadas neste roteiro. Question Identifique no seu c\u00f3digo quais linhas comp\u00f5e a regi\u00e3o cr\u00edtica e onde deveriam estar as diretivas lock e unlock . Escreva abaixo suas conclu\u00f5es. ! !1 example Coloque um coment\u00e1rio nas linhas identificadas acima. J\u00e1 sabemos onde iremos colocar as opera\u00e7\u00f5es de lock e unlock do mutex. Agora falta s\u00f3 cri\u00e1-lo. Question O mutex precisa ser criado e inicializado. Onde isto deve ser feito? Como ele pode ser recebido pela fun\u00e7\u00e3o da thread? Question Consulte o manual de pthread_mutex_init e escreva abaixo como criar e inicializar um mutex. Question Consulte o manual de pthread_mutex_lock e pthread_mutex_unlock e escreva abaixo como us\u00e1-las. Example Com base nas suas respostas acima, conserte seu programa soma_global.c e verifique que ele retorna os resultados corretos. Question Agora me\u00e7a o tempo de execu\u00e7\u00e3o e anote abaixo. Compare com o original (que n\u00e3o funcionava) e explique a diferen\u00e7a. Tip Usar mutex \u00e9 muito caro! Al\u00e9m de acabar com o paralelismo, as opera\u00e7\u00f5es lock e unlock tamb\u00e9m s\u00e3o custosas. Economizando mutex \u00b6 Nesta parte final iremos ver como diminuir o n\u00famero de chamadas ao mutex . Question \u00c9 necess\u00e1rio atualizar a vari\u00e1vel global soma a cada itera\u00e7\u00e3o do for ? E \u00e9 poss\u00edvel atualiz\u00e1-la somente uma vez? Example Implemente a ideia acima e veja se houve melhora. Salve como soma-global2.c . O exerc\u00edcio acima dever\u00e1 ter desempenho bom, j\u00e1 que limitamos a quantidade de vezes que usamos o mutex . Vamos tentar outra ideia agora. Question Precisamos da vari\u00e1vel global? E se cada thread retornasse sua soma parcial? Como o programa poderia ser organizado para que essa ideia funcione? Question A ideia acima precisou de mutex ? Por que? Example Implemente a ideia acima e confira os resultados. Houve melhora no desempenho?","title":"19 - Sincroniza\u00e7\u00e3o"},{"location":"aulas/19-sincronizacao/#19-sincronizacao","text":"Na \u00faltima aula aprendemos as APIs da biblioteca pthread para criar e esperar a finaliza\u00e7\u00e3o de threads. Tamb\u00e9m aprendemos a passar argumentos e receber de volta valores usando um struct alocado dinamicamente.","title":"19 - Sincroniza\u00e7\u00e3o"},{"location":"aulas/19-sincronizacao/#aquecimento","text":"Vamos iniciar uma revis\u00e3o trabalhando em cima do arquivo soma_global.c . Example Abra o arquivo e analise seu conte\u00fado. Question Qual o papel da fun\u00e7\u00e3o soma_parcial ? Explique o papel de cada atributo de Question Como voc\u00ea setaria os atributos de struct soma_partical_args para obter a soma do vetor todo? E para obter somente a soma da primeira metade do vetor? Para fins did\u00e1ticos, estamos atualizando diretamente a vari\u00e1vel soma_total dentro do for . Example Complete as partes faltantes e rode o programa. Ele d\u00e1 os resultados esperados? Teste para valores de n incrementalmente maiores. Question Os resultados acima estar\u00e3o errados. Voc\u00ea consegue explicar por que?","title":"Aquecimento"},{"location":"aulas/19-sincronizacao/#sincronizacao-usando-mutex","text":"Vamos agora trabalhar agora para corrigir este erro! Lembrando da aula, as opera\u00e7\u00f5es poss\u00edveis s\u00e3o as seguintes: lock - se tiver destravado, trava e continua; se n\u00e3o estiver espera. unlock - se tiver a trava, a destrava e permite que outras tarefas travem. Note que n\u00e3o existe garantia de ordem! Ou seja, se tiverem v\u00e1rios processos esperando por um mutex qualquer um deles pode receber o acesso. Inclusive, uma thread pode esperar \"para sempre\" e nunca receber o acesso. N\u00e3o \u00e9 prov\u00e1vel, mas \u00e9 poss\u00edvel. Warning Voc\u00ea pode precisar instalar o pacote manpages-posix-dev para obter as p\u00e1ginas do manual usadas neste roteiro. Question Identifique no seu c\u00f3digo quais linhas comp\u00f5e a regi\u00e3o cr\u00edtica e onde deveriam estar as diretivas lock e unlock . Escreva abaixo suas conclu\u00f5es. ! !1 example Coloque um coment\u00e1rio nas linhas identificadas acima. J\u00e1 sabemos onde iremos colocar as opera\u00e7\u00f5es de lock e unlock do mutex. Agora falta s\u00f3 cri\u00e1-lo. Question O mutex precisa ser criado e inicializado. Onde isto deve ser feito? Como ele pode ser recebido pela fun\u00e7\u00e3o da thread? Question Consulte o manual de pthread_mutex_init e escreva abaixo como criar e inicializar um mutex. Question Consulte o manual de pthread_mutex_lock e pthread_mutex_unlock e escreva abaixo como us\u00e1-las. Example Com base nas suas respostas acima, conserte seu programa soma_global.c e verifique que ele retorna os resultados corretos. Question Agora me\u00e7a o tempo de execu\u00e7\u00e3o e anote abaixo. Compare com o original (que n\u00e3o funcionava) e explique a diferen\u00e7a. Tip Usar mutex \u00e9 muito caro! Al\u00e9m de acabar com o paralelismo, as opera\u00e7\u00f5es lock e unlock tamb\u00e9m s\u00e3o custosas.","title":"Sincroniza\u00e7\u00e3o usando mutex"},{"location":"aulas/19-sincronizacao/#economizando-mutex","text":"Nesta parte final iremos ver como diminuir o n\u00famero de chamadas ao mutex . Question \u00c9 necess\u00e1rio atualizar a vari\u00e1vel global soma a cada itera\u00e7\u00e3o do for ? E \u00e9 poss\u00edvel atualiz\u00e1-la somente uma vez? Example Implemente a ideia acima e veja se houve melhora. Salve como soma-global2.c . O exerc\u00edcio acima dever\u00e1 ter desempenho bom, j\u00e1 que limitamos a quantidade de vezes que usamos o mutex . Vamos tentar outra ideia agora. Question Precisamos da vari\u00e1vel global? E se cada thread retornasse sua soma parcial? Como o programa poderia ser organizado para que essa ideia funcione? Question A ideia acima precisou de mutex ? Por que? Example Implemente a ideia acima e confira os resultados. Houve melhora no desempenho?","title":"Economizando mutex"},{"location":"projetos/bomblab/","text":"Bomb Lab \u00b6 Entrega: 16/10 O prop\u00f3sito desta atividade \u00e9 torn\u00e1-los proficientes na engenharia reversa de execut\u00e1veis. Cada um de voc\u00eas recebeu um execut\u00e1vel \"bomba\" que pede uma s\u00e9rie de senhas para ser desativado. Estas senhas devem ser descobertas atrav\u00e9s da an\u00e1lise do c\u00f3digo Assembly do execut\u00e1vel. O pacote \"bombs.zip\" disponibilizado no reposit\u00f3rio da disciplina contem os execut\u00e1veis bomba de toda a sala. Trabalhe somente com o execut\u00e1vel com o seu login! Entrega \u00b6 Voc\u00ea dever\u00e1 submeter um arquivo contendo as senhas usadas para desativar cada n\u00edvel. Cada senha dever\u00e1 estar em uma linha. O arquivo entregue deve funcionar como entrada para desativar sua bomba. $>./<seu_nome> < sol_<seu_nome>.txt Pontua\u00e7\u00e3o \u00b6 Os n\u00edveis tem a seguinte pontua\u00e7\u00e3o: Level1: 1 Level2: 1 Level3: 1 Level4: 1 Level5: 1 Level6: 1 Level7: 1 Level8: 1 Level9: 1 Desativa\u00e7\u00e3o completa: +1","title":"Bomb Lab"},{"location":"projetos/bomblab/#bomb-lab","text":"Entrega: 16/10 O prop\u00f3sito desta atividade \u00e9 torn\u00e1-los proficientes na engenharia reversa de execut\u00e1veis. Cada um de voc\u00eas recebeu um execut\u00e1vel \"bomba\" que pede uma s\u00e9rie de senhas para ser desativado. Estas senhas devem ser descobertas atrav\u00e9s da an\u00e1lise do c\u00f3digo Assembly do execut\u00e1vel. O pacote \"bombs.zip\" disponibilizado no reposit\u00f3rio da disciplina contem os execut\u00e1veis bomba de toda a sala. Trabalhe somente com o execut\u00e1vel com o seu login!","title":"Bomb Lab"},{"location":"projetos/bomblab/#entrega","text":"Voc\u00ea dever\u00e1 submeter um arquivo contendo as senhas usadas para desativar cada n\u00edvel. Cada senha dever\u00e1 estar em uma linha. O arquivo entregue deve funcionar como entrada para desativar sua bomba. $>./<seu_nome> < sol_<seu_nome>.txt","title":"Entrega"},{"location":"projetos/bomblab/#pontuacao","text":"Os n\u00edveis tem a seguinte pontua\u00e7\u00e3o: Level1: 1 Level2: 1 Level3: 1 Level4: 1 Level5: 1 Level6: 1 Level7: 1 Level8: 1 Level9: 1 Desativa\u00e7\u00e3o completa: +1","title":"Pontua\u00e7\u00e3o"},{"location":"projetos/posix/","text":"Linux do Zero \u00b6 Na aula 12 - Linux do zero compilamos um sistema Linux a partir do c\u00f3digo fonte e montamos uma imagem bootavel manualmente. Vamos neste lab completar nosso sistema com alguns execut\u00e1veis essenciais para o funcionamento b\u00e1sico do nosso sistema. echo : mostra uma mensagem no terminal cat : mostra um arquivo head : mostra as primeiras linhas de um arquivo tail : mostra as primeiras linhas de um arquivo ls : mostra os arquivos em uma pasta. shell : recebe comandos e executa programas. init : primeiro processo rodado. Inicializa sistema e recolhe processos orf\u00e3os. Seu trabalho ser\u00e1 implementar estes comandos e inclu\u00ed-los em seu sistema Linux criado na aula 12. Voc\u00ea ir\u00e1 substituir uma por\u00e7\u00e3o de execut\u00e1veis do busybox por implementa\u00e7\u00f5s pr\u00f3prias. A avalia\u00e7\u00e3o ser\u00e1 feita no sistema criado na aula 12. O comportamento esperado dos programas dever\u00e1 ser id\u00eantico aos j\u00e1 presentes no Ubuntu. Voc\u00eas podem comparar a sa\u00edda dos programas usando o comando diff . Quanto maior o n\u00famero de op\u00e7\u00f5es implementadas maior ser\u00e1 a nota do projeto. As se\u00e7\u00f5es abaixo definem quais op\u00e7\u00f5es s\u00e3o necess\u00e1rias para obter cada conceito. O funcionamento de cada programa pode ser conferido usando o manual man . Conceito D \u00b6 Um script que compila os execut\u00e1veis implementados \u00e9 disponibilizado. echo foi implementado. N\u00e3o \u00e9 necess\u00e1rio implementar nenhuma flag da linha de comando. cat foi implementado. N\u00e3o \u00e9 necess\u00e1rio implementar nenhuma flag da linha de comando nem receber v\u00e1rios arquivos. Conceito C \u00b6 Um shell simples foi implementado. Ele permite executar um programa e esperar por seu retorno. Repassa somente um argumento para os processos lan\u00e7ados mudar de pasta atual ls foi implementado sem op\u00e7\u00f5es extras (somente para a pasta atual). Seu programa dever\u00e1 produzir sa\u00edda id\u00eantica a ls -1 no Ubuntu. head foi implementado usando as op\u00e7\u00f5es padr\u00e3o. Somente um arquivo \u00e9 mostrado. tail foi implementado usando as op\u00e7\u00f5es padr\u00e3o. Somente um arquivo \u00e9 mostrado. Conceito B+ \u00b6 head e tail foram implementados com a op\u00e7\u00e3o -n . head , tail e cat aceitam receber mais de um arquivo. shell suporta repassar um n\u00famero arbitr\u00e1rio de argumentos para os processos lan\u00e7ados. ls aceita a op\u00e7\u00e3o -l . Conceito A+ \u00b6 um programa init foi implementado. Ele executa os processos listados em /etc/init.sh em ordem e depois fica em loop infinito recolhendo processos orf\u00e3os.","title":"Linux do Zero"},{"location":"projetos/posix/#linux-do-zero","text":"Na aula 12 - Linux do zero compilamos um sistema Linux a partir do c\u00f3digo fonte e montamos uma imagem bootavel manualmente. Vamos neste lab completar nosso sistema com alguns execut\u00e1veis essenciais para o funcionamento b\u00e1sico do nosso sistema. echo : mostra uma mensagem no terminal cat : mostra um arquivo head : mostra as primeiras linhas de um arquivo tail : mostra as primeiras linhas de um arquivo ls : mostra os arquivos em uma pasta. shell : recebe comandos e executa programas. init : primeiro processo rodado. Inicializa sistema e recolhe processos orf\u00e3os. Seu trabalho ser\u00e1 implementar estes comandos e inclu\u00ed-los em seu sistema Linux criado na aula 12. Voc\u00ea ir\u00e1 substituir uma por\u00e7\u00e3o de execut\u00e1veis do busybox por implementa\u00e7\u00f5s pr\u00f3prias. A avalia\u00e7\u00e3o ser\u00e1 feita no sistema criado na aula 12. O comportamento esperado dos programas dever\u00e1 ser id\u00eantico aos j\u00e1 presentes no Ubuntu. Voc\u00eas podem comparar a sa\u00edda dos programas usando o comando diff . Quanto maior o n\u00famero de op\u00e7\u00f5es implementadas maior ser\u00e1 a nota do projeto. As se\u00e7\u00f5es abaixo definem quais op\u00e7\u00f5es s\u00e3o necess\u00e1rias para obter cada conceito. O funcionamento de cada programa pode ser conferido usando o manual man .","title":"Linux do Zero"},{"location":"projetos/posix/#conceito-d","text":"Um script que compila os execut\u00e1veis implementados \u00e9 disponibilizado. echo foi implementado. N\u00e3o \u00e9 necess\u00e1rio implementar nenhuma flag da linha de comando. cat foi implementado. N\u00e3o \u00e9 necess\u00e1rio implementar nenhuma flag da linha de comando nem receber v\u00e1rios arquivos.","title":"Conceito D"},{"location":"projetos/posix/#conceito-c","text":"Um shell simples foi implementado. Ele permite executar um programa e esperar por seu retorno. Repassa somente um argumento para os processos lan\u00e7ados mudar de pasta atual ls foi implementado sem op\u00e7\u00f5es extras (somente para a pasta atual). Seu programa dever\u00e1 produzir sa\u00edda id\u00eantica a ls -1 no Ubuntu. head foi implementado usando as op\u00e7\u00f5es padr\u00e3o. Somente um arquivo \u00e9 mostrado. tail foi implementado usando as op\u00e7\u00f5es padr\u00e3o. Somente um arquivo \u00e9 mostrado.","title":"Conceito C"},{"location":"projetos/posix/#conceito-b","text":"head e tail foram implementados com a op\u00e7\u00e3o -n . head , tail e cat aceitam receber mais de um arquivo. shell suporta repassar um n\u00famero arbitr\u00e1rio de argumentos para os processos lan\u00e7ados. ls aceita a op\u00e7\u00e3o -l .","title":"Conceito B+"},{"location":"projetos/posix/#conceito-a","text":"um programa init foi implementado. Ele executa os processos listados em /etc/init.sh em ordem e depois fica em loop infinito recolhendo processos orf\u00e3os.","title":"Conceito A+"}]}